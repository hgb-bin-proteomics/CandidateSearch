{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033
{\fonttbl {\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}
{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}
}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;\red0\green128\blue0;\red96\green64\blue32;\rede0\green128\blue0;\red128\green0\blue0;\red128\green96\blue32;\red0\green32\blue128;\red0\green128\blue128;\red255\green0\blue255;\red0\green0\blue0;\red112\green0\blue112;\red255\green0\blue0;}
{\stylesheet
{\widctlpar\adjustright \fs20\cgrid \snext0 Normal;}
{\paperw11900\paperh16840\margl1800\margr1800\margt1440\margb1440\gutter0\ltrsect}
{\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \sbasedon0 \snext0 heading 1;}
{\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid \sbasedon0 \snext0 heading 2;}
{\s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid \sbasedon0 \snext0 heading 3;}
{\s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 4;}{\*\cs10 \additive Default Paragraph Font;}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 5;}{\*\cs10 \additive Default Paragraph Font;}
{\s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid \sbasedon0 \snext15 Title;}
{\s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid \sbasedon0 \snext16 Subtitle;}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid \sbasedon0 \snext17 BodyText;}
{\s18\widctlpar\fs22\cgrid \sbasedon0 \snext18 DenseText;}
{\s28\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext28 header;}
{\s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid \sbasedon0 \snext29 footer;}
{\s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext30 GroupHeader;}
{\s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext41 Code Example 0;}
{\s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext42 Code Example 1;}
{\s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext43 Code Example 2;}
{\s43\li1080\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext44 Code Example 3;}
{\s44\li1440\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext45 Code Example 4;}
{\s45\li1800\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext46 Code Example 5;}
{\s46\li2160\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext47 Code Example 6;}
{\s47\li2520\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext48 Code Example 7;}
{\s48\li2880\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 8;}
{\s49\li3240\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext50 Code Example 9;}
{\s50\li3600\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext51 Code Example 10;}
{\s51\li3960\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext52 Code Example 11;}
{\s52\li4320\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 12;}
{\s53\li4680\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 13;}
{\s60\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext61 List Continue 0;}
{\s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext62 List Continue 1;}
{\s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext63 List Continue 2;}
{\s63\li1080\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext64 List Continue 3;}
{\s64\li1440\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext65 List Continue 4;}
{\s65\li1800\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext66 List Continue 5;}
{\s66\li2160\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext67 List Continue 6;}
{\s67\li2520\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext68 List Continue 7;}
{\s68\li2880\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext69 List Continue 8;}
{\s69\li3240\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext70 List Continue 9;}
{\s70\li3600\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext71 List Continue 10;}
{\s71\li3960\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext72 List Continue 11;}
{\s72\li4320\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 12;}
{\s73\li4680\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 13;}
{\s80\li0\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext81 DescContinue 0;}
{\s81\li360\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext82 DescContinue 1;}
{\s82\li720\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext83 DescContinue 2;}
{\s83\li1080\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext84 DescContinue 3;}
{\s84\li1440\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext85 DescContinue 4;}
{\s85\li1800\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext86 DescContinue 5;}
{\s86\li2160\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext87 DescContinue 6;}
{\s87\li2520\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext88 DescContinue 7;}
{\s88\li2880\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext89 DescContinue 8;}
{\s89\li3240\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext90 DescContinue 9;}
{\s90\li3600\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext91 DescContinue 10;}
{\s91\li3960\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext92 DescContinue 11;}
{\s92\li4320\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 12;}
{\s93\li4680\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 13;}
{\s100\li0\sa30\sb30\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext101 LatexTOC 0;}
{\s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext102 LatexTOC 1;}
{\s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext103 LatexTOC 2;}
{\s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext104 LatexTOC 3;}
{\s104\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext105 LatexTOC 4;}
{\s105\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext106 LatexTOC 5;}
{\s106\li2160\sa12\sb12\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext107 LatexTOC 6;}
{\s107\li2520\sa9\sb9\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext108 LatexTOC 7;}
{\s108\li2880\sa6\sb6\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext109 LatexTOC 8;}
{\s109\li3240\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext110 LatexTOC 9;}
{\s110\li3600\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext111 LatexTOC 10;}
{\s111\li3960\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext112 LatexTOC 11;}
{\s112\li4320\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 12;}
{\s113\li4680\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 13;}
{\s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext121 \sautoupd List Bullet 0;}
{\s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext122 \sautoupd List Bullet 1;}
{\s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext123 \sautoupd List Bullet 2;}
{\s123\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext124 \sautoupd List Bullet 3;}
{\s124\fi-360\li1800\widctlpar\jclisttab\tx1800{\*\pn \pnlvlbody\ilvl0\ls5\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext125 \sautoupd List Bullet 4;}
{\s125\fi-360\li2160\widctlpar\jclisttab\tx2160{\*\pn \pnlvlbody\ilvl0\ls6\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext126 \sautoupd List Bullet 5;}
{\s126\fi-360\li2520\widctlpar\jclisttab\tx2520{\*\pn \pnlvlbody\ilvl0\ls7\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext127 \sautoupd List Bullet 6;}
{\s127\fi-360\li2880\widctlpar\jclisttab\tx2880{\*\pn \pnlvlbody\ilvl0\ls8\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext128 \sautoupd List Bullet 7;}
{\s128\fi-360\li3240\widctlpar\jclisttab\tx3240{\*\pn \pnlvlbody\ilvl0\ls9\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext129 \sautoupd List Bullet 8;}
{\s129\fi-360\li3600\widctlpar\jclisttab\tx3600{\*\pn \pnlvlbody\ilvl0\ls10\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext130 \sautoupd List Bullet 9;}
{\s130\fi-360\li3960\widctlpar\jclisttab\tx3960{\*\pn \pnlvlbody\ilvl0\ls11\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext131 \sautoupd List Bullet 10;}
{\s131\fi-360\li4320\widctlpar\jclisttab\tx4320{\*\pn \pnlvlbody\ilvl0\ls12\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext132 \sautoupd List Bullet 11;}
{\s132\fi-360\li4680\widctlpar\jclisttab\tx4680{\*\pn \pnlvlbody\ilvl0\ls13\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 12;}
{\s133\fi-360\li5040\widctlpar\jclisttab\tx5040{\*\pn \pnlvlbody\ilvl0\ls14\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 13;}
{\s140\fi-360\li360\widctlpar\fs20\cgrid \sbasedon0 \snext141 \sautoupd List Enum 0;}
{\s141\fi-360\li720\widctlpar\fs20\cgrid \sbasedon0 \snext142 \sautoupd List Enum 1;}
{\s142\fi-360\li1080\widctlpar\fs20\cgrid \sbasedon0 \snext143 \sautoupd List Enum 2;}
{\s143\fi-360\li1440\widctlpar\fs20\cgrid \sbasedon0 \snext144 \sautoupd List Enum 3;}
{\s144\fi-360\li1800\widctlpar\fs20\cgrid \sbasedon0 \snext145 \sautoupd List Enum 4;}
{\s145\fi-360\li2160\widctlpar\fs20\cgrid \sbasedon0 \snext146 \sautoupd List Enum 5;}
{\s146\fi-360\li2520\widctlpar\fs20\cgrid \sbasedon0 \snext147 \sautoupd List Enum 6;}
{\s147\fi-360\li2880\widctlpar\fs20\cgrid \sbasedon0 \snext148 \sautoupd List Enum 7;}
{\s148\fi-360\li3240\widctlpar\fs20\cgrid \sbasedon0 \snext149 \sautoupd List Enum 8;}
{\s149\fi-360\li3600\widctlpar\fs20\cgrid \sbasedon0 \snext150 \sautoupd List Enum 9;}
{\s150\fi-360\li3960\widctlpar\fs20\cgrid \sbasedon0 \snext151 \sautoupd List Enum 10;}
{\s151\fi-360\li4320\widctlpar\fs20\cgrid \sbasedon0 \snext152 \sautoupd List Enum 11;}
{\s152\fi-360\li4680\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 12;}
{\s153\fi-360\li5040\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 13;}
}
{\info 
{\title {\comment CandidateSearch  {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
1.0.0 \par
}}CandidateSearch}
{\comment Generated by doxygen 1.9.8.}
}\pard\plain 
\sectd\pgnlcrm
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\vertalc\qc\par\par\par\par\par\par\par
\pard\plain \s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid 
{\field\fldedit {\*\fldinst TITLE \\*MERGEFORMAT}{\fldrslt CandidateSearch}}\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\par
\par\par\par\par\par\par\par\par\par\par\par\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
{\field\fldedit {\*\fldinst AUTHOR \\*MERGEFORMAT}{\fldrslt AUTHOR}}\par
Version 1.0.0\par\page\page\vertalt
\pard\plain 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Table of Contents\par
\pard\plain \par
{\field\fldedit {\*\fldinst TOC \\f \\*MERGEFORMAT}{\fldrslt Table of contents}}\par
\pard\plain 
\sect \sbkpage \pgndec \pgnrestart
\sect \sectd \sbknone
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}
\par \pard\plain 
\par \pard\plain 
\pard\plain \s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
CandidateSearch\par \pard\plain 
{\tc\tcl1 \v CandidateSearch}
{\xe \v CandidateSearch}
{\bkmkstart AAAAAAAAAM}
{\bkmkend AAAAAAAAAM}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\bkmkstart AAAAAAAAAN}
{\bkmkend AAAAAAAAAN}
 Proof-of-concept implementation of a search engine that uses {\f2 CandidateVectorSearch} to identify the best peptide candidates for a given mass spectrum. {\i {\b CandidateSearch}}  creates the vector encodings of peptides and spectra that are needed for the sparse matrix search of {\i CandidateVectorSearch} .\par
{\i {\b CandidateSearch}}  can identify peptide candidates from a given mass spectrum without any precursor ion/mass information and no previous knowledge about potential fixed or variable modifications. {\i {\b CandidateSearch}}  can also identify peptidoform candidates if a set of fixed and variable modifications is provided. The aim of {\i {\b CandidateSearch}}  is to reduce the search space for a given identification task by filtering out unlikely peptide or peptidoform candidates. It is {\b NOT}  meant to be a standalone search engine for peptide/peptidoform identification.\par
A simplified break down of the {\i {\b CandidateSearch}}  algorithm is given in the following:{
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Read the given MS2 spectra from the mgf file.\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Generate the encoding vectors for each spectrum.\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Transform spectrum encoding vectors into the representation needed for {\i CandidateVectorSearch} .\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Read the given fasta file.\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Digest the proteins of the fasta file into peptides.\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
[Optional] Generate decoy peptides and peptidoforms.\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Calculate theoretical ion m/z values for all peptides.\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Generate the encoding vectors for each peptide.\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Transform the peptide encoding vectors into the representation needed for {\i CandidateVectorSearch} .\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Run {\i CandidateVectorSearch} .\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Process the results of {\i CandidateVectorSearch} .\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Create a csv file that maps every spectrum (scan number) to a list of the best {\i n}  peptide candidates.\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Done!\par}
\par
{\bkmkstart AAAAAAAAAO}
{\bkmkend AAAAAAAAAO}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Usage
\par}
{\tc\tcl2 \v Usage}
Running {\i {\b CandidateSearch}}  requires three files:{
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
An mgf file containing MS2 spectra.\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
A fasta file containing sample proteins.\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
A settings file containing parameters for digestion, ion calculation and search (see below for an explanation of the settings file).\par}
\par
The {\i {\b CandidateSearch}}  executable can then be run like this:\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid CandidateSearch.exe spectra.mgf database.fasta settings.txt\par
}
\par
Example files that can be used to test {\i {\b CandidateSearch}}  can be found in {\f2 /data} .\par}
{\bkmkstart AAAAAAAAAP}
{\bkmkend AAAAAAAAAP}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Settings
\par}
{\tc\tcl2 \v Settings}
The settings file accepts the following parameters:{
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
MAX_CLEAVAGES: The maximum number of allowed missed cleavages during digestion. (integer, default = 2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
MIN_PEP_LENGTH: The minimum length of a peptide to be considered for search. (integer, default = 5)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
MAX_PEP_LENGTH: The maximum length of a peptide to be considered for search. (integer, default = 30)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
MAX_PRECURSOR_CHARGE: The maximum considered precursor ion charge. (integer, default = 4)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
MAX_FRAGMENT_CHARGE: The maximum considered fragment ion charge. (string, default = +1)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
MAX_NEUTRAL_LOSSES: The maximum number of neutral losses considered during ion calculation. (integer, default = 1)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
MAX_NEUTRAL_LOSS_MODS: The maximum number of neutral loss modifications considered during ion calculation. (integer, default = 2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
FIXED_MODIFICATIONS: Fixed modifications that should be considered during search given as {\f2 (char)amino_acid:(double)modification_mass} . An example would be carbamidomethylation of cysteine, which would be denoted as {\f2 C:57.021464;} . Several fixed modifications can be provided. (string, default = None)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
VARIABLE_MODIFICATIONS: Variable modifications that should be considered during search given as {\f2 (char)amino_acid:(double)modification_mass} . An example would be oxidation of methionine, which would be denoted as {\f2 M:15.994915;} . Several variable modifications can be provided. If no modifications are given, {\i {\b CandidateSearch}}  will return the best scoring unmodified peptidoforms for a given spectrum. (string, default = None)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
DECOY_SEARCH: Whether decoy search should be performed or not. Accepts {\f2 true}  or {\f2 false} . (bool, default = true)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
TOP_N: The number of best candidates that should be returned by the search. (integer, default = 1000)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
TOLERANCE: Tolerance used for matching theoretical ions to experimental peaks. Given in Dalton. (double, default = 0.02)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
NORMALIZE: Whether or not {\i CandidateVectorSearch}  scores should be normalized before selecting the best {\i n}  candidates. Accepts {\f2 true}  or {\f2 false} . (bool, default = false)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
USE_GAUSSIAN: Whether or not experimental peaks should be modelled as gaussian distributions with {\f2 mu = (m/z)}  and {\f2 sigma = (tolerance/3)} . Accepts {\f2 true}  or {\f2 false} . (bool, default = true) \par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
MODE: Search approach used by {\i CandidateVectorSearch} . One of the following (default = CPU_DV):{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CPU_DV: Sparse matrix - dense vector search on the CPU.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CPU_DM: Sparse matrix - dense matrix search on the CPU.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CPU_SV: Sparse matrix - sparse vector search on the CPU.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CPU_SM: Sparse matrix - sparse matrix search on the CPU.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
GPU_DV: Sparse matrix - dense vector search on the GPU (see {\f2 requirements}).\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
GPU_DM: Sparse matrix - dense matrix search on the GPU (see {\f2 requirements}).\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
GPU_SM: Sparse matrix - sparse matrix search on the GPU (see {\f2 requirements}).\par}
}
\par
For the last five parameters you might additionally want to check the documentation of {\f2 CandidateVectorSearch} to get a better understanding of their meaning.\par
An empty {\f2 settings.txt}  file is a valid configuration for search (default parameters will be used), however not providing a settings file at all is not valid.\par
An example {\f2 settings.txt}  file is provided {\f2 here}.\par
Additionally its contents are listed below, which should help in understanding the formatting:\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ## DIGESTIONS PARAMETERS\par
MAX_CLEAVAGES = 2\par
MIN_PEP_LENGTH = 5\par
MAX_PEP_LENGTH = 30\par
\par
## ION CALCULATION PARAMETERS\par
MAX_PRECURSOR_CHARGE = 4\par
MAX_FRAGMENT_CHARGE = +1\par
MAX_NEUTRAL_LOSSES = 1\par
MAX_NEUTRAL_LOSS_MODS = 2\par
#FIXED_MODIFICATIONS = None\par
FIXED_MODIFICATIONS = C:57.021464;\par
#VARIABLE_MODIFICATIONS = None\par
VARIABLE_MODIFICATIONS = M:15.994915;\par
#VARIABLE_MODIFICATIONS = M:15.994915;K:284.173607;\par
\par
## SEARCH PARAMETERS\par
DECOY_SEARCH = true\par
\par
## VECTOR SEARCH PARAMETERS\par
TOP_N = 1000\par
TOLERANCE = 0.02\par
NORMALIZE = false\par
USE_GAUSSIAN = true\par
MODE = CPU_DV\par
}
\par}
{\bkmkstart AAAAAAAAAQ}
{\bkmkend AAAAAAAAAQ}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Documentation
\par}
{\tc\tcl2 \v Documentation}
The code of this search engine is fully documented within the {\f2 .cs}  code files. A good entry point is the main function of {\i {\b CandidateSearch}}  which is implemented {\f2 here}. Documentation generated by {\f2 Doxygen} is also available here: {\f2 https://hgb-bin-proteomics.github.io/CandidateSearch/}\par}
{\bkmkstart AAAAAAAAAR}
{\bkmkend AAAAAAAAAR}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Limitations
\par}
{\tc\tcl2 \v Limitations}
This a proof-of-concept implementation that shows the applicability of our {\i CandidateVectorSearch}  approach and not a fully fledged search engine, therefore this implementation comes with a few limitations:\par
{
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
We currently only have implemented tryptic digestion.{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
You can implement your own digestion {\f2 here}.\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
We currently have not implemented support for N- or C-terminal modifications.\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
We currently have only implemented support for one possible modification per amino acid.\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
We only support spectra in centroid mode (we can't really do anything with spectra in profile mode).\par}
\par
\par}
{\bkmkstart AAAAAAAAAS}
{\bkmkend AAAAAAAAAS}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Results
\par}
{\tc\tcl2 \v Results}
Example results of {\i {\b CandidateSearch}}  and results analysis are given in {\f2 tests} .\par
{\b Figure 1:}  Identifying peptide candidates and peptidoform candidates with {\i {\b CandidateSearch}}  in a {\f2 HeLa dataset} using the human swissprot database. The considered ground truth was an {\f2 MS Amanda} search validated with {\f2 Percolator}. For every high-confidence PSM we checked if the identified peptide/peptidoform was among the top 50/100/500/1000 hits of {\i {\b CandidateSearch}} . We reach almost 100% coverage within the first 1000 hits of {\i {\b CandidateSearch}}  (for reference: the whole database contained ~4 200 000 peptides or ~10 500 000 peptidoforms).\par}
{\bkmkstart AAAAAAAAAT}
{\bkmkend AAAAAAAAAT}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Known Issues
\par}
{\tc\tcl2 \v Known Issues}
{\f2 List of known issues}\par}
{\bkmkstart AAAAAAAAAU}
{\bkmkend AAAAAAAAAU}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Citing
\par}
{\tc\tcl2 \v Citing}
If you are using [parts of] {\i {\b CandidateSearch}}  please cite:\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid MS Annika 3.0 (publication wip)\par
}
\par}
{\bkmkstart AAAAAAAAAV}
{\bkmkend AAAAAAAAAV}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
License
\par}
{\tc\tcl2 \v License}
{
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 MIT}\par}
\par
\par}
{\bkmkstart AAAAAAAAAW}
{\bkmkend AAAAAAAAAW}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Contact
\par}
{\tc\tcl2 \v Contact}
{\f2 micha.birklbauer@fh-hagenberg.at} \par}
}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Namespace Index\par \pard\plain 
{\tc \v Namespace Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Package List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here are the packages with brief descriptions (if available):}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b CandidateSearch} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CandidateSearch.util} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MSAMANDA_CHEMICALUTILS} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MSAMANDA_FASTAPARSER} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MSAMANDA_IONCALCULATION} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MSAMANDA_MGFPARSER} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b VectorSearchInterface} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Hierarchical Index\par \pard\plain 
{\tc \v Hierarchical Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Class Hierarchy\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This inheritance list is sorted roughly, but not completely, alphabetically:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
MSAMANDA_MGFPARSER.AMassCentroid\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
MSAMANDA_CHEMICALUTILS.AminoAcid\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
CandidateSearch.CandidateSearch\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
MSAMANDA_CHEMICALUTILS.ChemicalElement\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
MSAMANDA_FASTAPARSER.DBPeptide\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
MSAMANDA_FASTAPARSER.DBProtein\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
MSAMANDA_FASTAPARSER.DBProtRef\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
MSAMANDA_FASTAPARSER.DigesterDB\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
MSAMANDA_FASTAPARSER.Enzyme\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
MSAMANDA_FASTAPARSER.FASTAParser\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
IEquatable
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
MSAMANDA_CHEMICALUTILS.Permutations\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
MSAMANDA_IONCALCULATION.InstrumentSetting\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
List
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
MSAMANDA_IONCALCULATION.IonWithNL\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
MSAMANDA_IONCALCULATION.Modification\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
CandidateSearch.util.Peptide\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
MSAMANDA_MGFPARSER.Precursor\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
MSAMANDA_FASTAPARSER.ProteinDigester\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
CandidateSearch.util.Result\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
CandidateSearch.util.Settings\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
CandidateSearch.util.Spectrum\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
MSAMANDA_MGFPARSER.Spectrum\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
VectorSearchInterface.VectorSearchAPI\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Class Index\par \pard\plain 
{\tc \v Class Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Class List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here are the classes, structs, unions and interfaces with brief descriptions:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b MSAMANDA_MGFPARSER.AMassCentroid} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MSAMANDA_CHEMICALUTILS.AminoAcid} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CandidateSearch.CandidateSearch} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Searching for candidates using VectorSearch. Requires VectorSearch.dll v1.5.1 Requires VectorSearchCUDA.dll v1.4.7 })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MSAMANDA_CHEMICALUTILS.ChemicalElement} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MSAMANDA_FASTAPARSER.DBPeptide} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MSAMANDA_FASTAPARSER.DBProtein} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MSAMANDA_FASTAPARSER.DBProtRef} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MSAMANDA_FASTAPARSER.DigesterDB} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MSAMANDA_FASTAPARSER.Enzyme} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MSAMANDA_FASTAPARSER.FASTAParser} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MSAMANDA_IONCALCULATION.InstrumentSetting} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MSAMANDA_IONCALCULATION.IonWithNL} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MSAMANDA_IONCALCULATION.Modification} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CandidateSearch.util.Peptide} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Simplified peptide class that stores peptide/peptidoform information })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MSAMANDA_CHEMICALUTILS.Permutations} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MSAMANDA_MGFPARSER.Precursor} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MSAMANDA_FASTAPARSER.ProteinDigester} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CandidateSearch.util.Result} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Result class to transform and store the returned integer array of VectorSearch })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CandidateSearch.util.Settings} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Settings for digestion, ion calculation and VectorSearch })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CandidateSearch.util.Spectrum} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Simplified spectrum class implemention of a mass spectrum })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MSAMANDA_MGFPARSER.Spectrum} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b VectorSearchInterface.VectorSearchAPI} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
File Index\par \pard\plain 
{\tc \v File Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
File List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here is a list of all documented files with brief descriptions:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b CandidateSearch.cs} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CandidateSearchCPU.cs} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CandidateSearchGPU.cs} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b amanda/{\b ChemicalUtils.cs} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b amanda/{\b FASTAParser.cs} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b amanda/{\b IonCalculator.cs} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b amanda/{\b MGFParser.cs} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b dll/{\b VectorSearchAPI.cs} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b util/{\b Database.cs} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b util/{\b Result.cs} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b util/{\b Settings.cs} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b util/{\b Spectra.cs} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Namespace Documentation\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CandidateSearch Namespace Reference\par \pard\plain 
{\tc\tcl2 \v CandidateSearch}
{\xe \v CandidateSearch}
{\bkmkstart AAAAAAAAAX}
{\bkmkend AAAAAAAAAX}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CandidateSearch}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Searching for candidates using VectorSearch. Requires VectorSearch.dll v1.5.1 Requires VectorSearchCUDA.dll v1.4.7. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CandidateSearchCPU}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Searching for candidates on the CPU. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CandidateSearchGPU}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Searching for candidates on the GPU. }}\par}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CandidateSearch.util Namespace Reference\par \pard\plain 
{\tc\tcl2 \v CandidateSearch.util}
{\xe \v CandidateSearch.util}
{\bkmkstart AAAAAAAABB}
{\bkmkend AAAAAAAABB}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b DatabaseReader}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reader class to read a fasta file. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MGFReader}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reader class to read mgf files. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Peptide}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Simplified peptide class that stores peptide/peptidoform information. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Result}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Result class to transform and store the returned integer array of VectorSearch. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Settings}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Settings for digestion, ion calculation and VectorSearch. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b SettingsReader}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reader class to read a settings file. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Spectrum}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Simplified spectrum class implemention of a mass spectrum. }}\par}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MSAMANDA_CHEMICALUTILS Namespace Reference\par \pard\plain 
{\tc\tcl2 \v MSAMANDA_CHEMICALUTILS}
{\xe \v MSAMANDA_CHEMICALUTILS}
{\bkmkstart AAAAAAAACR}
{\bkmkend AAAAAAAACR}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b AminoAcid}\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ChemicalElement}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ChemicalUtils}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Permutations}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MSAMANDA_FASTAPARSER Namespace Reference\par \pard\plain 
{\tc\tcl2 \v MSAMANDA_FASTAPARSER}
{\xe \v MSAMANDA_FASTAPARSER}
{\bkmkstart AAAAAAAADP}
{\bkmkend AAAAAAAADP}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b DBPeptide}\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b DBProtein}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b DBProtRef}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b DigesterDB}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Enzyme}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b FASTAParser}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b HelperMethods}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ProteinDigester}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MSAMANDA_IONCALCULATION Namespace Reference\par \pard\plain 
{\tc\tcl2 \v MSAMANDA_IONCALCULATION}
{\xe \v MSAMANDA_IONCALCULATION}
{\bkmkstart AAAAAAAAFC}
{\bkmkend AAAAAAAAFC}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b InstrumentSetting}\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b IonCalculator}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b IonMassStabilizer}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b IonWithNL}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Modification}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MSAMANDA_MGFPARSER Namespace Reference\par \pard\plain 
{\tc\tcl2 \v MSAMANDA_MGFPARSER}
{\xe \v MSAMANDA_MGFPARSER}
{\bkmkstart AAAAAAAAGZ}
{\bkmkend AAAAAAAAGZ}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b AMassCentroid}\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MGFParser}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Precursor}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Spectrum}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
VectorSearchInterface Namespace Reference\par \pard\plain 
{\tc\tcl2 \v VectorSearchInterface}
{\xe \v VectorSearchInterface}
{\bkmkstart AAAAAAAAHW}
{\bkmkend AAAAAAAAHW}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b VectorSearchAPI}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Class Documentation{\tc \v Class Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MSAMANDA_MGFPARSER.AMassCentroid Class Reference\par \pard\plain 
{\tc\tcl2 \v MSAMANDA_MGFPARSER.AMassCentroid}
{\xe \v MSAMANDA_MGFPARSER.AMassCentroid}
{\bkmkstart AAAAAAAAHA}
{\bkmkend AAAAAAAAHA}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AMassCentroid} {\b Clone} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AMassCentroid} {\b Clone} (int charge)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Properties\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b Position}{\f2  [get, set]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b Intensity}{\f2  [get, set]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b Charge}{\f2  [get, set]}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 6} of file {\b MGFParser.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v Clone\:MSAMANDA_MGFPARSER.AMassCentroid}
{\xe \v MSAMANDA_MGFPARSER.AMassCentroid\:Clone}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b AMassCentroid} MSAMANDA_MGFPARSER.AMassCentroid.Clone ()}}
\par
{\bkmkstart AAAAAAAAHB}
{\bkmkend AAAAAAAAHB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 12} of file {\b MGFParser.cs}.}\par
}
{\xe \v Clone\:MSAMANDA_MGFPARSER.AMassCentroid}
{\xe \v MSAMANDA_MGFPARSER.AMassCentroid\:Clone}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b AMassCentroid} MSAMANDA_MGFPARSER.AMassCentroid.Clone (int  {\i charge})}}
\par
{\bkmkstart AAAAAAAAHC}
{\bkmkend AAAAAAAAHC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 17} of file {\b MGFParser.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Property Documentation\par
\pard\plain 
{\xe \v Charge\:MSAMANDA_MGFPARSER.AMassCentroid}
{\xe \v MSAMANDA_MGFPARSER.AMassCentroid\:Charge}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int MSAMANDA_MGFPARSER.AMassCentroid.Charge{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAAHD}
{\bkmkend AAAAAAAAHD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 10} of file {\b MGFParser.cs}.}\par
}
{\xe \v Intensity\:MSAMANDA_MGFPARSER.AMassCentroid}
{\xe \v MSAMANDA_MGFPARSER.AMassCentroid\:Intensity}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double MSAMANDA_MGFPARSER.AMassCentroid.Intensity{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAAHE}
{\bkmkend AAAAAAAAHE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 9} of file {\b MGFParser.cs}.}\par
}
{\xe \v Position\:MSAMANDA_MGFPARSER.AMassCentroid}
{\xe \v MSAMANDA_MGFPARSER.AMassCentroid\:Position}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double MSAMANDA_MGFPARSER.AMassCentroid.Position{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAAHF}
{\bkmkend AAAAAAAAHF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 8} of file {\b MGFParser.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
amanda/MGFParser.cs\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MSAMANDA_CHEMICALUTILS.AminoAcid Class Reference\par \pard\plain 
{\tc\tcl2 \v MSAMANDA_CHEMICALUTILS.AminoAcid}
{\xe \v MSAMANDA_CHEMICALUTILS.AminoAcid}
{\bkmkstart AAAAAAAACS}
{\bkmkend AAAAAAAACS}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b Mass} (bool mono)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AminoAcid} (char oneLetter, string threeLetter, string name, double monoisotopicMass, double avgMass, double immoniumMass)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AminoAcid} (char oneLetter, string threeLetter, string name, double monoisotopicMass, double avgMass, bool mono=true)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
readonly string {\b Name}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
readonly string {\b ThreeLetterCode}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
readonly char {\b OneLetterCode}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
readonly double {\b ImmoniumMass}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 19} of file {\b ChemicalUtils.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v AminoAcid\:MSAMANDA_CHEMICALUTILS.AminoAcid}
{\xe \v MSAMANDA_CHEMICALUTILS.AminoAcid\:AminoAcid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MSAMANDA_CHEMICALUTILS.AminoAcid.AminoAcid (char  {\i oneLetter}, string  {\i threeLetter}, string  {\i name}, double  {\i monoisotopicMass}, double  {\i avgMass}, double  {\i immoniumMass})}}
\par
{\bkmkstart AAAAAAAACT}
{\bkmkend AAAAAAAACT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 33} of file {\b ChemicalUtils.cs}.}\par
}
{\xe \v AminoAcid\:MSAMANDA_CHEMICALUTILS.AminoAcid}
{\xe \v MSAMANDA_CHEMICALUTILS.AminoAcid\:AminoAcid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MSAMANDA_CHEMICALUTILS.AminoAcid.AminoAcid (char  {\i oneLetter}, string  {\i threeLetter}, string  {\i name}, double  {\i monoisotopicMass}, double  {\i avgMass}, bool  {\i mono} = {\f2 true})}}
\par
{\bkmkstart AAAAAAAACU}
{\bkmkend AAAAAAAACU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 43} of file {\b ChemicalUtils.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v Mass\:MSAMANDA_CHEMICALUTILS.AminoAcid}
{\xe \v MSAMANDA_CHEMICALUTILS.AminoAcid\:Mass}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double MSAMANDA_CHEMICALUTILS.AminoAcid.Mass (bool  {\i mono})}}
\par
{\bkmkstart AAAAAAAACV}
{\bkmkend AAAAAAAACV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 28} of file {\b ChemicalUtils.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v ImmoniumMass\:MSAMANDA_CHEMICALUTILS.AminoAcid}
{\xe \v MSAMANDA_CHEMICALUTILS.AminoAcid\:ImmoniumMass}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
readonly double MSAMANDA_CHEMICALUTILS.AminoAcid.ImmoniumMass}}
\par
{\bkmkstart AAAAAAAACW}
{\bkmkend AAAAAAAACW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 26} of file {\b ChemicalUtils.cs}.}\par
}
{\xe \v Name\:MSAMANDA_CHEMICALUTILS.AminoAcid}
{\xe \v MSAMANDA_CHEMICALUTILS.AminoAcid\:Name}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
readonly string MSAMANDA_CHEMICALUTILS.AminoAcid.Name}}
\par
{\bkmkstart AAAAAAAACX}
{\bkmkend AAAAAAAACX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 21} of file {\b ChemicalUtils.cs}.}\par
}
{\xe \v OneLetterCode\:MSAMANDA_CHEMICALUTILS.AminoAcid}
{\xe \v MSAMANDA_CHEMICALUTILS.AminoAcid\:OneLetterCode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
readonly char MSAMANDA_CHEMICALUTILS.AminoAcid.OneLetterCode}}
\par
{\bkmkstart AAAAAAAACY}
{\bkmkend AAAAAAAACY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 23} of file {\b ChemicalUtils.cs}.}\par
}
{\xe \v ThreeLetterCode\:MSAMANDA_CHEMICALUTILS.AminoAcid}
{\xe \v MSAMANDA_CHEMICALUTILS.AminoAcid\:ThreeLetterCode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
readonly string MSAMANDA_CHEMICALUTILS.AminoAcid.ThreeLetterCode}}
\par
{\bkmkstart AAAAAAAACZ}
{\bkmkend AAAAAAAACZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 22} of file {\b ChemicalUtils.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
amanda/ChemicalUtils.cs\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CandidateSearch.CandidateSearch Class Reference\par \pard\plain 
{\tc\tcl2 \v CandidateSearch.CandidateSearch}
{\xe \v CandidateSearch.CandidateSearch}
{\bkmkstart AAAAAAAAAY}
{\bkmkend AAAAAAAAAY}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Searching for candidates using VectorSearch. Requires VectorSearch.dll v1.5.1 Requires VectorSearchCUDA.dll v1.4.7. }}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b Main} (string[] args)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Main function that is executed when {\b CandidateSearch} is run. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const string {\b version} = "1.0.0"\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Current version of {\b CandidateSearch}. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Searching for candidates using VectorSearch. Requires VectorSearch.dll v1.5.1 Requires VectorSearchCUDA.dll v1.4.7. \par
}{
Definition at line {\b 10} of file {\b CandidateSearch.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v Main\:CandidateSearch.CandidateSearch}
{\xe \v CandidateSearch.CandidateSearch\:Main}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void CandidateSearch.CandidateSearch.Main (string[]  {\i args}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAAZ}
{\bkmkend AAAAAAAAAZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Main function that is executed when {\b CandidateSearch} is run. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i args} \cell }{Arguments passed via commandline.\cell }
{\row }
}
}{
Definition at line {\b 21} of file {\b CandidateSearch.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v version\:CandidateSearch.CandidateSearch}
{\xe \v CandidateSearch.CandidateSearch\:version}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const string CandidateSearch.CandidateSearch.version = "1.0.0"{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAABA}
{\bkmkend AAAAAAAABA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Current version of {\b CandidateSearch}. }}\par
{
Definition at line {\b 15} of file {\b CandidateSearch.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CandidateSearch.cs\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MSAMANDA_CHEMICALUTILS.ChemicalElement Class Reference\par \pard\plain 
{\tc\tcl2 \v MSAMANDA_CHEMICALUTILS.ChemicalElement}
{\xe \v MSAMANDA_CHEMICALUTILS.ChemicalElement}
{\bkmkstart AAAAAAAADA}
{\bkmkend AAAAAAAADA}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ChemicalElement} (string name, string fullName, double monoMass, double avgMass)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
readonly string {\b Name}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
readonly string {\b FullName}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
readonly double {\b MonoMass}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
readonly double {\b AvgMass}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 3} of file {\b ChemicalUtils.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v ChemicalElement\:MSAMANDA_CHEMICALUTILS.ChemicalElement}
{\xe \v MSAMANDA_CHEMICALUTILS.ChemicalElement\:ChemicalElement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MSAMANDA_CHEMICALUTILS.ChemicalElement.ChemicalElement (string  {\i name}, string  {\i fullName}, double  {\i monoMass}, double  {\i avgMass})}}
\par
{\bkmkstart AAAAAAAADB}
{\bkmkend AAAAAAAADB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 10} of file {\b ChemicalUtils.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v AvgMass\:MSAMANDA_CHEMICALUTILS.ChemicalElement}
{\xe \v MSAMANDA_CHEMICALUTILS.ChemicalElement\:AvgMass}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
readonly double MSAMANDA_CHEMICALUTILS.ChemicalElement.AvgMass}}
\par
{\bkmkstart AAAAAAAADC}
{\bkmkend AAAAAAAADC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 8} of file {\b ChemicalUtils.cs}.}\par
}
{\xe \v FullName\:MSAMANDA_CHEMICALUTILS.ChemicalElement}
{\xe \v MSAMANDA_CHEMICALUTILS.ChemicalElement\:FullName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
readonly string MSAMANDA_CHEMICALUTILS.ChemicalElement.FullName}}
\par
{\bkmkstart AAAAAAAADD}
{\bkmkend AAAAAAAADD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 6} of file {\b ChemicalUtils.cs}.}\par
}
{\xe \v MonoMass\:MSAMANDA_CHEMICALUTILS.ChemicalElement}
{\xe \v MSAMANDA_CHEMICALUTILS.ChemicalElement\:MonoMass}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
readonly double MSAMANDA_CHEMICALUTILS.ChemicalElement.MonoMass}}
\par
{\bkmkstart AAAAAAAADE}
{\bkmkend AAAAAAAADE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 7} of file {\b ChemicalUtils.cs}.}\par
}
{\xe \v Name\:MSAMANDA_CHEMICALUTILS.ChemicalElement}
{\xe \v MSAMANDA_CHEMICALUTILS.ChemicalElement\:Name}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
readonly string MSAMANDA_CHEMICALUTILS.ChemicalElement.Name}}
\par
{\bkmkstart AAAAAAAADF}
{\bkmkend AAAAAAAADF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5} of file {\b ChemicalUtils.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
amanda/ChemicalUtils.cs\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MSAMANDA_FASTAPARSER.DBPeptide Class Reference\par \pard\plain 
{\tc\tcl2 \v MSAMANDA_FASTAPARSER.DBPeptide}
{\xe \v MSAMANDA_FASTAPARSER.DBPeptide}
{\bkmkstart AAAAAAAADQ}
{\bkmkend AAAAAAAADQ}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DBPeptide} (string sequence, string sequenceOriginal, int missedCleavages, bool proteinStartFlag, {\b DBProtRef} protRef)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b CreateMD5} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Properties\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b Mass}{\f2  [get, set]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b MassInt}{\f2  [get, set]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b Sequence}{\f2  [get, set]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b ProteinStartFlag}{\f2  [get, set]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
List< {\b DBProtRef} > {\b DbProtRefs}{\f2  [get, set]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b SequenceOriginal}{\f2  [get, set]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b MissedCleavages}{\f2  [get, set]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SeqHash}{\f2  [get, set]}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 397} of file {\b FASTAParser.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v DBPeptide\:MSAMANDA_FASTAPARSER.DBPeptide}
{\xe \v MSAMANDA_FASTAPARSER.DBPeptide\:DBPeptide}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MSAMANDA_FASTAPARSER.DBPeptide.DBPeptide ()}}
\par
{\bkmkstart AAAAAAAADR}
{\bkmkend AAAAAAAADR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 416} of file {\b FASTAParser.cs}.}\par
}
{\xe \v DBPeptide\:MSAMANDA_FASTAPARSER.DBPeptide}
{\xe \v MSAMANDA_FASTAPARSER.DBPeptide\:DBPeptide}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MSAMANDA_FASTAPARSER.DBPeptide.DBPeptide (string  {\i sequence}, string  {\i sequenceOriginal}, int  {\i missedCleavages}, bool  {\i proteinStartFlag}, {\b DBProtRef}  {\i protRef})}}
\par
{\bkmkstart AAAAAAAADS}
{\bkmkend AAAAAAAADS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 423} of file {\b FASTAParser.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v CreateMD5\:MSAMANDA_FASTAPARSER.DBPeptide}
{\xe \v MSAMANDA_FASTAPARSER.DBPeptide\:CreateMD5}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int MSAMANDA_FASTAPARSER.DBPeptide.CreateMD5 ()}}
\par
{\bkmkstart AAAAAAAADT}
{\bkmkend AAAAAAAADT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 446} of file {\b FASTAParser.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Property Documentation\par
\pard\plain 
{\xe \v DbProtRefs\:MSAMANDA_FASTAPARSER.DBPeptide}
{\xe \v MSAMANDA_FASTAPARSER.DBPeptide\:DbProtRefs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
List<{\b DBProtRef}> MSAMANDA_FASTAPARSER.DBPeptide.DbProtRefs{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAADU}
{\bkmkend AAAAAAAADU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 408} of file {\b FASTAParser.cs}.}\par
}
{\xe \v Mass\:MSAMANDA_FASTAPARSER.DBPeptide}
{\xe \v MSAMANDA_FASTAPARSER.DBPeptide\:Mass}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double MSAMANDA_FASTAPARSER.DBPeptide.Mass{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAADV}
{\bkmkend AAAAAAAADV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 400} of file {\b FASTAParser.cs}.}\par
}
{\xe \v MassInt\:MSAMANDA_FASTAPARSER.DBPeptide}
{\xe \v MSAMANDA_FASTAPARSER.DBPeptide\:MassInt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int MSAMANDA_FASTAPARSER.DBPeptide.MassInt{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAADW}
{\bkmkend AAAAAAAADW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 402} of file {\b FASTAParser.cs}.}\par
}
{\xe \v MissedCleavages\:MSAMANDA_FASTAPARSER.DBPeptide}
{\xe \v MSAMANDA_FASTAPARSER.DBPeptide\:MissedCleavages}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int MSAMANDA_FASTAPARSER.DBPeptide.MissedCleavages{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAADX}
{\bkmkend AAAAAAAADX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 412} of file {\b FASTAParser.cs}.}\par
}
{\xe \v ProteinStartFlag\:MSAMANDA_FASTAPARSER.DBPeptide}
{\xe \v MSAMANDA_FASTAPARSER.DBPeptide\:ProteinStartFlag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MSAMANDA_FASTAPARSER.DBPeptide.ProteinStartFlag{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAADY}
{\bkmkend AAAAAAAADY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 406} of file {\b FASTAParser.cs}.}\par
}
{\xe \v SeqHash\:MSAMANDA_FASTAPARSER.DBPeptide}
{\xe \v MSAMANDA_FASTAPARSER.DBPeptide\:SeqHash}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int MSAMANDA_FASTAPARSER.DBPeptide.SeqHash{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAADZ}
{\bkmkend AAAAAAAADZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 414} of file {\b FASTAParser.cs}.}\par
}
{\xe \v Sequence\:MSAMANDA_FASTAPARSER.DBPeptide}
{\xe \v MSAMANDA_FASTAPARSER.DBPeptide\:Sequence}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string MSAMANDA_FASTAPARSER.DBPeptide.Sequence{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAAEA}
{\bkmkend AAAAAAAAEA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 404} of file {\b FASTAParser.cs}.}\par
}
{\xe \v SequenceOriginal\:MSAMANDA_FASTAPARSER.DBPeptide}
{\xe \v MSAMANDA_FASTAPARSER.DBPeptide\:SequenceOriginal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string MSAMANDA_FASTAPARSER.DBPeptide.SequenceOriginal{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAAEB}
{\bkmkend AAAAAAAAEB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 410} of file {\b FASTAParser.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
amanda/FASTAParser.cs\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MSAMANDA_FASTAPARSER.DBProtein Class Reference\par \pard\plain 
{\tc\tcl2 \v MSAMANDA_FASTAPARSER.DBProtein}
{\xe \v MSAMANDA_FASTAPARSER.DBProtein}
{\bkmkstart AAAAAAAAEC}
{\bkmkend AAAAAAAAEC}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DBProtein} (string identifier, int id, string sequence, bool isDecoy=false)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Properties\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b Sequence}{\f2  [get, set]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b IsDecoy}{\f2  [get, set]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DBProtRef} {\b DbProtRef}{\f2  [get, set]}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 296} of file {\b FASTAParser.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v DBProtein\:MSAMANDA_FASTAPARSER.DBProtein}
{\xe \v MSAMANDA_FASTAPARSER.DBProtein\:DBProtein}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MSAMANDA_FASTAPARSER.DBProtein.DBProtein (string  {\i identifier}, int  {\i id}, string  {\i sequence}, bool  {\i isDecoy} = {\f2 false})}}
\par
{\bkmkstart AAAAAAAAED}
{\bkmkend AAAAAAAAED}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 302} of file {\b FASTAParser.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Property Documentation\par
\pard\plain 
{\xe \v DbProtRef\:MSAMANDA_FASTAPARSER.DBProtein}
{\xe \v MSAMANDA_FASTAPARSER.DBProtein\:DbProtRef}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DBProtRef} MSAMANDA_FASTAPARSER.DBProtein.DbProtRef{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAAEE}
{\bkmkend AAAAAAAAEE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 300} of file {\b FASTAParser.cs}.}\par
}
{\xe \v IsDecoy\:MSAMANDA_FASTAPARSER.DBProtein}
{\xe \v MSAMANDA_FASTAPARSER.DBProtein\:IsDecoy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MSAMANDA_FASTAPARSER.DBProtein.IsDecoy{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAAEF}
{\bkmkend AAAAAAAAEF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 299} of file {\b FASTAParser.cs}.}\par
}
{\xe \v Sequence\:MSAMANDA_FASTAPARSER.DBProtein}
{\xe \v MSAMANDA_FASTAPARSER.DBProtein\:Sequence}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string MSAMANDA_FASTAPARSER.DBProtein.Sequence{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAAEG}
{\bkmkend AAAAAAAAEG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 298} of file {\b FASTAParser.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
amanda/FASTAParser.cs\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MSAMANDA_FASTAPARSER.DBProtRef Struct Reference\par \pard\plain 
{\tc\tcl2 \v MSAMANDA_FASTAPARSER.DBProtRef}
{\xe \v MSAMANDA_FASTAPARSER.DBProtRef}
{\bkmkstart AAAAAAAAEH}
{\bkmkend AAAAAAAAEH}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Properties\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ProtId}{\f2  [get, set]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b MappingId}{\f2  [get, set]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b ProtIdentifier}{\f2  [get, set]}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 329} of file {\b FASTAParser.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Property Documentation\par
\pard\plain 
{\xe \v MappingId\:MSAMANDA_FASTAPARSER.DBProtRef}
{\xe \v MSAMANDA_FASTAPARSER.DBProtRef\:MappingId}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int MSAMANDA_FASTAPARSER.DBProtRef.MappingId{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAAEI}
{\bkmkend AAAAAAAAEI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 334} of file {\b FASTAParser.cs}.}\par
}
{\xe \v ProtId\:MSAMANDA_FASTAPARSER.DBProtRef}
{\xe \v MSAMANDA_FASTAPARSER.DBProtRef\:ProtId}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int MSAMANDA_FASTAPARSER.DBProtRef.ProtId{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAAEJ}
{\bkmkend AAAAAAAAEJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 332} of file {\b FASTAParser.cs}.}\par
}
{\xe \v ProtIdentifier\:MSAMANDA_FASTAPARSER.DBProtRef}
{\xe \v MSAMANDA_FASTAPARSER.DBProtRef\:ProtIdentifier}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string MSAMANDA_FASTAPARSER.DBProtRef.ProtIdentifier{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAAEK}
{\bkmkend AAAAAAAAEK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 336} of file {\b FASTAParser.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
amanda/FASTAParser.cs\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MSAMANDA_FASTAPARSER.DigesterDB Class Reference\par \pard\plain 
{\tc\tcl2 \v MSAMANDA_FASTAPARSER.DigesterDB}
{\xe \v MSAMANDA_FASTAPARSER.DigesterDB}
{\bkmkstart AAAAAAAAEL}
{\bkmkend AAAAAAAAEL}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Properties\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Dictionary< int, List< {\b DBPeptide} > > {\b DbPeptidesDictMassKey}{\f2  [get, set]}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 965} of file {\b FASTAParser.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v DigesterDB\:MSAMANDA_FASTAPARSER.DigesterDB}
{\xe \v MSAMANDA_FASTAPARSER.DigesterDB\:DigesterDB}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MSAMANDA_FASTAPARSER.DigesterDB.DigesterDB ()}}
\par
{\bkmkstart AAAAAAAAEM}
{\bkmkend AAAAAAAAEM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 970} of file {\b FASTAParser.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Property Documentation\par
\pard\plain 
{\xe \v DbPeptidesDictMassKey\:MSAMANDA_FASTAPARSER.DigesterDB}
{\xe \v MSAMANDA_FASTAPARSER.DigesterDB\:DbPeptidesDictMassKey}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Dictionary<int, List<{\b DBPeptide}> > MSAMANDA_FASTAPARSER.DigesterDB.DbPeptidesDictMassKey{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAAEN}
{\bkmkend AAAAAAAAEN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 968} of file {\b FASTAParser.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
amanda/FASTAParser.cs\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MSAMANDA_FASTAPARSER.Enzyme Class Reference\par \pard\plain 
{\tc\tcl2 \v MSAMANDA_FASTAPARSER.Enzyme}
{\xe \v MSAMANDA_FASTAPARSER.Enzyme}
{\bkmkstart AAAAAAAAEO}
{\bkmkend AAAAAAAAEO}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b CLEAVAGE_SPECIFICITY} \{ {\b FULL}
, {\b SEMI}
, {\b SEMI_N}
, {\b SEMI_C}
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Properties\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b CleavageSites}{\f2  [get, set]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b CleavageInhibitors}{\f2  [get, set]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CLEAVAGE_SPECIFICITY {\b Specificity}{\f2  [get, set]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b Offset}{\f2  [get, set]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b Name}{\f2  [get, set]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Regex {\b TheRegex}{\f2  [get]}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 340} of file {\b FASTAParser.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Enumeration Documentation\par
\pard\plain 
{\xe \v CLEAVAGE_SPECIFICITY\:MSAMANDA_FASTAPARSER.Enzyme}
{\xe \v MSAMANDA_FASTAPARSER.Enzyme\:CLEAVAGE_SPECIFICITY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum MSAMANDA_FASTAPARSER.Enzyme.CLEAVAGE_SPECIFICITY}}
\par
{\bkmkstart AAAAAAAAEP}
{\bkmkend AAAAAAAAEP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 351} of file {\b FASTAParser.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Enzyme\:MSAMANDA_FASTAPARSER.Enzyme}
{\xe \v MSAMANDA_FASTAPARSER.Enzyme\:Enzyme}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MSAMANDA_FASTAPARSER.Enzyme.Enzyme ()}}
\par
{\bkmkstart AAAAAAAAEQ}
{\bkmkend AAAAAAAAEQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 342} of file {\b FASTAParser.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Property Documentation\par
\pard\plain 
{\xe \v CleavageInhibitors\:MSAMANDA_FASTAPARSER.Enzyme}
{\xe \v MSAMANDA_FASTAPARSER.Enzyme\:CleavageInhibitors}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string MSAMANDA_FASTAPARSER.Enzyme.CleavageInhibitors{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAAER}
{\bkmkend AAAAAAAAER}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 354} of file {\b FASTAParser.cs}.}\par
}
{\xe \v CleavageSites\:MSAMANDA_FASTAPARSER.Enzyme}
{\xe \v MSAMANDA_FASTAPARSER.Enzyme\:CleavageSites}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string MSAMANDA_FASTAPARSER.Enzyme.CleavageSites{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAAES}
{\bkmkend AAAAAAAAES}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 353} of file {\b FASTAParser.cs}.}\par
}
{\xe \v Name\:MSAMANDA_FASTAPARSER.Enzyme}
{\xe \v MSAMANDA_FASTAPARSER.Enzyme\:Name}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string MSAMANDA_FASTAPARSER.Enzyme.Name{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAAET}
{\bkmkend AAAAAAAAET}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 357} of file {\b FASTAParser.cs}.}\par
}
{\xe \v Offset\:MSAMANDA_FASTAPARSER.Enzyme}
{\xe \v MSAMANDA_FASTAPARSER.Enzyme\:Offset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int MSAMANDA_FASTAPARSER.Enzyme.Offset{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAAEU}
{\bkmkend AAAAAAAAEU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 356} of file {\b FASTAParser.cs}.}\par
}
{\xe \v Specificity\:MSAMANDA_FASTAPARSER.Enzyme}
{\xe \v MSAMANDA_FASTAPARSER.Enzyme\:Specificity}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CLEAVAGE_SPECIFICITY MSAMANDA_FASTAPARSER.Enzyme.Specificity{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAAEV}
{\bkmkend AAAAAAAAEV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 355} of file {\b FASTAParser.cs}.}\par
}
{\xe \v TheRegex\:MSAMANDA_FASTAPARSER.Enzyme}
{\xe \v MSAMANDA_FASTAPARSER.Enzyme\:TheRegex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Regex MSAMANDA_FASTAPARSER.Enzyme.TheRegex{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAAEW}
{\bkmkend AAAAAAAAEW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 359} of file {\b FASTAParser.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
amanda/FASTAParser.cs\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MSAMANDA_FASTAPARSER.FASTAParser Class Reference\par \pard\plain 
{\tc\tcl2 \v MSAMANDA_FASTAPARSER.FASTAParser}
{\xe \v MSAMANDA_FASTAPARSER.FASTAParser}
{\bkmkstart AAAAAAAAEX}
{\bkmkend AAAAAAAAEX}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static List< {\b Peptide} > {\b DigestFasta} (string fastaFileName, {\b Settings} settings, bool generateDecoys=false, double coreUsage=0.75)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 10} of file {\b FASTAParser.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v DigestFasta\:MSAMANDA_FASTAPARSER.FASTAParser}
{\xe \v MSAMANDA_FASTAPARSER.FASTAParser\:DigestFasta}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static List< {\b Peptide} > MSAMANDA_FASTAPARSER.FASTAParser.DigestFasta (string  {\i fastaFileName}, {\b Settings}  {\i settings}, bool  {\i generateDecoys} = {\f2 false}, double  {\i coreUsage} = {\f2 0::75}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAEY}
{\bkmkend AAAAAAAAEY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 12} of file {\b FASTAParser.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
amanda/FASTAParser.cs\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MSAMANDA_IONCALCULATION.InstrumentSetting Class Reference\par \pard\plain 
{\tc\tcl2 \v MSAMANDA_IONCALCULATION.InstrumentSetting}
{\xe \v MSAMANDA_IONCALCULATION.InstrumentSetting}
{\bkmkstart AAAAAAAAFD}
{\bkmkend AAAAAAAAFD}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b InstrumentSetting} {\b Clone} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Properties\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b Name}{\f2  [get, set]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b UseAIon}{\f2  [get, set]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b UseBIon}{\f2  [get, set]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b UseYIon}{\f2  [get, set]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b UseWaterLosses}{\f2  [get, set]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b UseAmmoniaLosses}{\f2  [get, set]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b UseImmoniumIons}{\f2  [get, set]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b UseZIon}{\f2  [get, set]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b UseZPlusHIon}{\f2  [get, set]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b UseZPlusTwoHIon}{\f2  [get, set]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b UseXIon}{\f2  [get, set]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b UseCIon}{\f2  [get, set]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b UseInternalFragments}{\f2  [get, set]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b UseAPlusHIon}{\f2  [get, set]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b UseAMinusHIon}{\f2  [get, set]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b UseBPlusHIon}{\f2  [get, set]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b UseBMinusHIon}{\f2  [get, set]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b UseCPlusHIon}{\f2  [get, set]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b UseCMinusHIon}{\f2  [get, set]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b UseXPlusHIon}{\f2  [get, set]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b UseXMinusHIon}{\f2  [get, set]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b UseYPlusHIon}{\f2  [get, set]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b UseYMinusHIon}{\f2  [get, set]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b UseZMinusHIon}{\f2  [get, set]}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 968} of file {\b IonCalculator.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v InstrumentSetting\:MSAMANDA_IONCALCULATION.InstrumentSetting}
{\xe \v MSAMANDA_IONCALCULATION.InstrumentSetting\:InstrumentSetting}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MSAMANDA_IONCALCULATION.InstrumentSetting.InstrumentSetting ()}}
\par
{\bkmkstart AAAAAAAAFE}
{\bkmkend AAAAAAAAFE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 970} of file {\b IonCalculator.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v Clone\:MSAMANDA_IONCALCULATION.InstrumentSetting}
{\xe \v MSAMANDA_IONCALCULATION.InstrumentSetting\:Clone}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b InstrumentSetting} MSAMANDA_IONCALCULATION.InstrumentSetting.Clone ()}}
\par
{\bkmkstart AAAAAAAAFF}
{\bkmkend AAAAAAAAFF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 998} of file {\b IonCalculator.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Property Documentation\par
\pard\plain 
{\xe \v Name\:MSAMANDA_IONCALCULATION.InstrumentSetting}
{\xe \v MSAMANDA_IONCALCULATION.InstrumentSetting\:Name}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string MSAMANDA_IONCALCULATION.InstrumentSetting.Name{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAAFG}
{\bkmkend AAAAAAAAFG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1031} of file {\b IonCalculator.cs}.}\par
}
{\xe \v UseAIon\:MSAMANDA_IONCALCULATION.InstrumentSetting}
{\xe \v MSAMANDA_IONCALCULATION.InstrumentSetting\:UseAIon}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MSAMANDA_IONCALCULATION.InstrumentSetting.UseAIon{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAAFH}
{\bkmkend AAAAAAAAFH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1032} of file {\b IonCalculator.cs}.}\par
}
{\xe \v UseAMinusHIon\:MSAMANDA_IONCALCULATION.InstrumentSetting}
{\xe \v MSAMANDA_IONCALCULATION.InstrumentSetting\:UseAMinusHIon}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MSAMANDA_IONCALCULATION.InstrumentSetting.UseAMinusHIon{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAAFI}
{\bkmkend AAAAAAAAFI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1047} of file {\b IonCalculator.cs}.}\par
}
{\xe \v UseAmmoniaLosses\:MSAMANDA_IONCALCULATION.InstrumentSetting}
{\xe \v MSAMANDA_IONCALCULATION.InstrumentSetting\:UseAmmoniaLosses}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MSAMANDA_IONCALCULATION.InstrumentSetting.UseAmmoniaLosses{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAAFJ}
{\bkmkend AAAAAAAAFJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1036} of file {\b IonCalculator.cs}.}\par
}
{\xe \v UseAPlusHIon\:MSAMANDA_IONCALCULATION.InstrumentSetting}
{\xe \v MSAMANDA_IONCALCULATION.InstrumentSetting\:UseAPlusHIon}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MSAMANDA_IONCALCULATION.InstrumentSetting.UseAPlusHIon{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAAFK}
{\bkmkend AAAAAAAAFK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1046} of file {\b IonCalculator.cs}.}\par
}
{\xe \v UseBIon\:MSAMANDA_IONCALCULATION.InstrumentSetting}
{\xe \v MSAMANDA_IONCALCULATION.InstrumentSetting\:UseBIon}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MSAMANDA_IONCALCULATION.InstrumentSetting.UseBIon{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAAFL}
{\bkmkend AAAAAAAAFL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1033} of file {\b IonCalculator.cs}.}\par
}
{\xe \v UseBMinusHIon\:MSAMANDA_IONCALCULATION.InstrumentSetting}
{\xe \v MSAMANDA_IONCALCULATION.InstrumentSetting\:UseBMinusHIon}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MSAMANDA_IONCALCULATION.InstrumentSetting.UseBMinusHIon{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAAFM}
{\bkmkend AAAAAAAAFM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1049} of file {\b IonCalculator.cs}.}\par
}
{\xe \v UseBPlusHIon\:MSAMANDA_IONCALCULATION.InstrumentSetting}
{\xe \v MSAMANDA_IONCALCULATION.InstrumentSetting\:UseBPlusHIon}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MSAMANDA_IONCALCULATION.InstrumentSetting.UseBPlusHIon{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAAFN}
{\bkmkend AAAAAAAAFN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1048} of file {\b IonCalculator.cs}.}\par
}
{\xe \v UseCIon\:MSAMANDA_IONCALCULATION.InstrumentSetting}
{\xe \v MSAMANDA_IONCALCULATION.InstrumentSetting\:UseCIon}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MSAMANDA_IONCALCULATION.InstrumentSetting.UseCIon{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAAFO}
{\bkmkend AAAAAAAAFO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1042} of file {\b IonCalculator.cs}.}\par
}
{\xe \v UseCMinusHIon\:MSAMANDA_IONCALCULATION.InstrumentSetting}
{\xe \v MSAMANDA_IONCALCULATION.InstrumentSetting\:UseCMinusHIon}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MSAMANDA_IONCALCULATION.InstrumentSetting.UseCMinusHIon{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAAFP}
{\bkmkend AAAAAAAAFP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1051} of file {\b IonCalculator.cs}.}\par
}
{\xe \v UseCPlusHIon\:MSAMANDA_IONCALCULATION.InstrumentSetting}
{\xe \v MSAMANDA_IONCALCULATION.InstrumentSetting\:UseCPlusHIon}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MSAMANDA_IONCALCULATION.InstrumentSetting.UseCPlusHIon{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAAFQ}
{\bkmkend AAAAAAAAFQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1050} of file {\b IonCalculator.cs}.}\par
}
{\xe \v UseImmoniumIons\:MSAMANDA_IONCALCULATION.InstrumentSetting}
{\xe \v MSAMANDA_IONCALCULATION.InstrumentSetting\:UseImmoniumIons}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MSAMANDA_IONCALCULATION.InstrumentSetting.UseImmoniumIons{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAAFR}
{\bkmkend AAAAAAAAFR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1037} of file {\b IonCalculator.cs}.}\par
}
{\xe \v UseInternalFragments\:MSAMANDA_IONCALCULATION.InstrumentSetting}
{\xe \v MSAMANDA_IONCALCULATION.InstrumentSetting\:UseInternalFragments}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MSAMANDA_IONCALCULATION.InstrumentSetting.UseInternalFragments{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAAFS}
{\bkmkend AAAAAAAAFS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1043} of file {\b IonCalculator.cs}.}\par
}
{\xe \v UseWaterLosses\:MSAMANDA_IONCALCULATION.InstrumentSetting}
{\xe \v MSAMANDA_IONCALCULATION.InstrumentSetting\:UseWaterLosses}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MSAMANDA_IONCALCULATION.InstrumentSetting.UseWaterLosses{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAAFT}
{\bkmkend AAAAAAAAFT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1035} of file {\b IonCalculator.cs}.}\par
}
{\xe \v UseXIon\:MSAMANDA_IONCALCULATION.InstrumentSetting}
{\xe \v MSAMANDA_IONCALCULATION.InstrumentSetting\:UseXIon}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MSAMANDA_IONCALCULATION.InstrumentSetting.UseXIon{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAAFU}
{\bkmkend AAAAAAAAFU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1041} of file {\b IonCalculator.cs}.}\par
}
{\xe \v UseXMinusHIon\:MSAMANDA_IONCALCULATION.InstrumentSetting}
{\xe \v MSAMANDA_IONCALCULATION.InstrumentSetting\:UseXMinusHIon}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MSAMANDA_IONCALCULATION.InstrumentSetting.UseXMinusHIon{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAAFV}
{\bkmkend AAAAAAAAFV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1053} of file {\b IonCalculator.cs}.}\par
}
{\xe \v UseXPlusHIon\:MSAMANDA_IONCALCULATION.InstrumentSetting}
{\xe \v MSAMANDA_IONCALCULATION.InstrumentSetting\:UseXPlusHIon}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MSAMANDA_IONCALCULATION.InstrumentSetting.UseXPlusHIon{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAAFW}
{\bkmkend AAAAAAAAFW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1052} of file {\b IonCalculator.cs}.}\par
}
{\xe \v UseYIon\:MSAMANDA_IONCALCULATION.InstrumentSetting}
{\xe \v MSAMANDA_IONCALCULATION.InstrumentSetting\:UseYIon}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MSAMANDA_IONCALCULATION.InstrumentSetting.UseYIon{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAAFX}
{\bkmkend AAAAAAAAFX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1034} of file {\b IonCalculator.cs}.}\par
}
{\xe \v UseYMinusHIon\:MSAMANDA_IONCALCULATION.InstrumentSetting}
{\xe \v MSAMANDA_IONCALCULATION.InstrumentSetting\:UseYMinusHIon}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MSAMANDA_IONCALCULATION.InstrumentSetting.UseYMinusHIon{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAAFY}
{\bkmkend AAAAAAAAFY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1055} of file {\b IonCalculator.cs}.}\par
}
{\xe \v UseYPlusHIon\:MSAMANDA_IONCALCULATION.InstrumentSetting}
{\xe \v MSAMANDA_IONCALCULATION.InstrumentSetting\:UseYPlusHIon}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MSAMANDA_IONCALCULATION.InstrumentSetting.UseYPlusHIon{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAAFZ}
{\bkmkend AAAAAAAAFZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1054} of file {\b IonCalculator.cs}.}\par
}
{\xe \v UseZIon\:MSAMANDA_IONCALCULATION.InstrumentSetting}
{\xe \v MSAMANDA_IONCALCULATION.InstrumentSetting\:UseZIon}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MSAMANDA_IONCALCULATION.InstrumentSetting.UseZIon{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAAGA}
{\bkmkend AAAAAAAAGA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1038} of file {\b IonCalculator.cs}.}\par
}
{\xe \v UseZMinusHIon\:MSAMANDA_IONCALCULATION.InstrumentSetting}
{\xe \v MSAMANDA_IONCALCULATION.InstrumentSetting\:UseZMinusHIon}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MSAMANDA_IONCALCULATION.InstrumentSetting.UseZMinusHIon{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAAGB}
{\bkmkend AAAAAAAAGB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1056} of file {\b IonCalculator.cs}.}\par
}
{\xe \v UseZPlusHIon\:MSAMANDA_IONCALCULATION.InstrumentSetting}
{\xe \v MSAMANDA_IONCALCULATION.InstrumentSetting\:UseZPlusHIon}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MSAMANDA_IONCALCULATION.InstrumentSetting.UseZPlusHIon{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAAGC}
{\bkmkend AAAAAAAAGC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1039} of file {\b IonCalculator.cs}.}\par
}
{\xe \v UseZPlusTwoHIon\:MSAMANDA_IONCALCULATION.InstrumentSetting}
{\xe \v MSAMANDA_IONCALCULATION.InstrumentSetting\:UseZPlusTwoHIon}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MSAMANDA_IONCALCULATION.InstrumentSetting.UseZPlusTwoHIon{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAAGD}
{\bkmkend AAAAAAAAGD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1040} of file {\b IonCalculator.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
amanda/IonCalculator.cs\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MSAMANDA_IONCALCULATION.IonWithNL Class Reference\par \pard\plain 
{\tc\tcl2 \v MSAMANDA_IONCALCULATION.IonWithNL}
{\xe \v MSAMANDA_IONCALCULATION.IonWithNL}
{\bkmkstart AAAAAAAAGE}
{\bkmkend AAAAAAAAGE}
Inheritance diagram for MSAMANDA_IONCALCULATION.IonWithNL:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_s_a_m_a_n_d_a___i_o_n_c_a_l_c_u_l_a_t_i_o_n_1_1_ion_with_n_l.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IonWithNL} (double baseMZ)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Properties\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b Mz}{\f2  [get, set]}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 791} of file {\b IonCalculator.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v IonWithNL\:MSAMANDA_IONCALCULATION.IonWithNL}
{\xe \v MSAMANDA_IONCALCULATION.IonWithNL\:IonWithNL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MSAMANDA_IONCALCULATION.IonWithNL.IonWithNL (double  {\i baseMZ})}}
\par
{\bkmkstart AAAAAAAAGF}
{\bkmkend AAAAAAAAGF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 796} of file {\b IonCalculator.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Property Documentation\par
\pard\plain 
{\xe \v Mz\:MSAMANDA_IONCALCULATION.IonWithNL}
{\xe \v MSAMANDA_IONCALCULATION.IonWithNL\:Mz}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double MSAMANDA_IONCALCULATION.IonWithNL.Mz{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAAGG}
{\bkmkend AAAAAAAAGG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 793} of file {\b IonCalculator.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
amanda/IonCalculator.cs\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MSAMANDA_IONCALCULATION.Modification Class Reference\par \pard\plain 
{\tc\tcl2 \v MSAMANDA_IONCALCULATION.Modification}
{\xe \v MSAMANDA_IONCALCULATION.Modification}
{\bkmkstart AAAAAAAAGH}
{\bkmkend AAAAAAAAGH}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b Mass} (bool mono)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Modification} (string title, string name, double mono, double avg, char aa, bool fix, double[] neutralLosses, bool nTerminal, bool cTerminal, int id, bool protein, int maxOccurrence, bool semiFixed=false)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Modification} ({\b Modification} m)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Modification} ({\b Modification} m, bool fix, bool nTerminal, bool cTerminal, bool protein, int maxOccurrence)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
override string {\b ToString} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static string {\b GetSaveString} ({\b Modification} modif)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
readonly string {\b Title}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
readonly string {\b FullName}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
readonly char {\b AA}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Properties\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double[] {\b NeutralLosses}{\f2  [get, set]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b NTerminal}{\f2  [get, set]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b CTerminal}{\f2  [get, set]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b ProteinTerminus}{\f2  [get, set]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b MaxOccurrence}{\f2  [get, set]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ID}{\f2  [get, set]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Fixed}{\f2  [get, set]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b SemiFixed}{\f2  [get, set]}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 832} of file {\b IonCalculator.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Modification\:MSAMANDA_IONCALCULATION.Modification}
{\xe \v MSAMANDA_IONCALCULATION.Modification\:Modification}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MSAMANDA_IONCALCULATION.Modification.Modification (string  {\i title}, string  {\i name}, double  {\i mono}, double  {\i avg}, char  {\i aa}, bool  {\i fix}, double[]  {\i neutralLosses}, bool  {\i nTerminal}, bool  {\i cTerminal}, int  {\i id}, bool  {\i protein}, int  {\i maxOccurrence}, bool  {\i semiFixed} = {\f2 false})}}
\par
{\bkmkstart AAAAAAAAGI}
{\bkmkend AAAAAAAAGI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 855} of file {\b IonCalculator.cs}.}\par
}
{\xe \v Modification\:MSAMANDA_IONCALCULATION.Modification}
{\xe \v MSAMANDA_IONCALCULATION.Modification\:Modification}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MSAMANDA_IONCALCULATION.Modification.Modification ({\b Modification}  {\i m})}}
\par
{\bkmkstart AAAAAAAAGJ}
{\bkmkend AAAAAAAAGJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 873} of file {\b IonCalculator.cs}.}\par
}
{\xe \v Modification\:MSAMANDA_IONCALCULATION.Modification}
{\xe \v MSAMANDA_IONCALCULATION.Modification\:Modification}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MSAMANDA_IONCALCULATION.Modification.Modification ({\b Modification}  {\i m}, bool  {\i fix}, bool  {\i nTerminal}, bool  {\i cTerminal}, bool  {\i protein}, int  {\i maxOccurrence})}}
\par
{\bkmkstart AAAAAAAAGK}
{\bkmkend AAAAAAAAGK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 890} of file {\b IonCalculator.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v GetSaveString\:MSAMANDA_IONCALCULATION.Modification}
{\xe \v MSAMANDA_IONCALCULATION.Modification\:GetSaveString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static string MSAMANDA_IONCALCULATION.Modification.GetSaveString ({\b Modification}  {\i modif}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAGL}
{\bkmkend AAAAAAAAGL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 926} of file {\b IonCalculator.cs}.}\par
}
{\xe \v Mass\:MSAMANDA_IONCALCULATION.Modification}
{\xe \v MSAMANDA_IONCALCULATION.Modification\:Mass}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double MSAMANDA_IONCALCULATION.Modification.Mass (bool  {\i mono})}}
\par
{\bkmkstart AAAAAAAAGM}
{\bkmkend AAAAAAAAGM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 847} of file {\b IonCalculator.cs}.}\par
}
{\xe \v ToString\:MSAMANDA_IONCALCULATION.Modification}
{\xe \v MSAMANDA_IONCALCULATION.Modification\:ToString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
override string MSAMANDA_IONCALCULATION.Modification.ToString ()}}
\par
{\bkmkstart AAAAAAAAGN}
{\bkmkend AAAAAAAAGN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 907} of file {\b IonCalculator.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v AA\:MSAMANDA_IONCALCULATION.Modification}
{\xe \v MSAMANDA_IONCALCULATION.Modification\:AA}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
readonly char MSAMANDA_IONCALCULATION.Modification.AA}}
\par
{\bkmkstart AAAAAAAAGO}
{\bkmkend AAAAAAAAGO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 838} of file {\b IonCalculator.cs}.}\par
}
{\xe \v FullName\:MSAMANDA_IONCALCULATION.Modification}
{\xe \v MSAMANDA_IONCALCULATION.Modification\:FullName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
readonly string MSAMANDA_IONCALCULATION.Modification.FullName}}
\par
{\bkmkstart AAAAAAAAGP}
{\bkmkend AAAAAAAAGP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 835} of file {\b IonCalculator.cs}.}\par
}
{\xe \v Title\:MSAMANDA_IONCALCULATION.Modification}
{\xe \v MSAMANDA_IONCALCULATION.Modification\:Title}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
readonly string MSAMANDA_IONCALCULATION.Modification.Title}}
\par
{\bkmkstart AAAAAAAAGQ}
{\bkmkend AAAAAAAAGQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 834} of file {\b IonCalculator.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Property Documentation\par
\pard\plain 
{\xe \v CTerminal\:MSAMANDA_IONCALCULATION.Modification}
{\xe \v MSAMANDA_IONCALCULATION.Modification\:CTerminal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MSAMANDA_IONCALCULATION.Modification.CTerminal{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAAGR}
{\bkmkend AAAAAAAAGR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 841} of file {\b IonCalculator.cs}.}\par
}
{\xe \v Fixed\:MSAMANDA_IONCALCULATION.Modification}
{\xe \v MSAMANDA_IONCALCULATION.Modification\:Fixed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MSAMANDA_IONCALCULATION.Modification.Fixed{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAAGS}
{\bkmkend AAAAAAAAGS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 852} of file {\b IonCalculator.cs}.}\par
}
{\xe \v ID\:MSAMANDA_IONCALCULATION.Modification}
{\xe \v MSAMANDA_IONCALCULATION.Modification\:ID}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int MSAMANDA_IONCALCULATION.Modification.ID{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAAGT}
{\bkmkend AAAAAAAAGT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 845} of file {\b IonCalculator.cs}.}\par
}
{\xe \v MaxOccurrence\:MSAMANDA_IONCALCULATION.Modification}
{\xe \v MSAMANDA_IONCALCULATION.Modification\:MaxOccurrence}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int MSAMANDA_IONCALCULATION.Modification.MaxOccurrence{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAAGU}
{\bkmkend AAAAAAAAGU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 843} of file {\b IonCalculator.cs}.}\par
}
{\xe \v NeutralLosses\:MSAMANDA_IONCALCULATION.Modification}
{\xe \v MSAMANDA_IONCALCULATION.Modification\:NeutralLosses}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double [] MSAMANDA_IONCALCULATION.Modification.NeutralLosses{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAAGV}
{\bkmkend AAAAAAAAGV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 839} of file {\b IonCalculator.cs}.}\par
}
{\xe \v NTerminal\:MSAMANDA_IONCALCULATION.Modification}
{\xe \v MSAMANDA_IONCALCULATION.Modification\:NTerminal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MSAMANDA_IONCALCULATION.Modification.NTerminal{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAAGW}
{\bkmkend AAAAAAAAGW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 840} of file {\b IonCalculator.cs}.}\par
}
{\xe \v ProteinTerminus\:MSAMANDA_IONCALCULATION.Modification}
{\xe \v MSAMANDA_IONCALCULATION.Modification\:ProteinTerminus}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MSAMANDA_IONCALCULATION.Modification.ProteinTerminus{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAAGX}
{\bkmkend AAAAAAAAGX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 842} of file {\b IonCalculator.cs}.}\par
}
{\xe \v SemiFixed\:MSAMANDA_IONCALCULATION.Modification}
{\xe \v MSAMANDA_IONCALCULATION.Modification\:SemiFixed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MSAMANDA_IONCALCULATION.Modification.SemiFixed{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAAGY}
{\bkmkend AAAAAAAAGY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 853} of file {\b IonCalculator.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
amanda/IonCalculator.cs\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CandidateSearch.util.Peptide Class Reference\par \pard\plain 
{\tc\tcl2 \v CandidateSearch.util.Peptide}
{\xe \v CandidateSearch.util.Peptide}
{\bkmkstart AAAAAAAABC}
{\bkmkend AAAAAAAABC}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Simplified peptide class that stores peptide/peptidoform information. }}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Peptide} (string Sequence, double Mass, Dictionary< int, double > Modifications, {\b Settings} IonSettings, bool IsDecoy)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor for a new peptide/pepidoform. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int[] {\b getEnconding} (int massRange=5000, int massMultiplier=100)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the encoding vector of the peptide. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
override string {\b ToString} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructs a string representation of the peptide. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b addModification} (int position, double {\b mass})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds a modification to the peptide if the peptide isn't already modified at that position. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Properties\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b sequence}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Amino acid sequence of the peptide. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b mass}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Mass of the unmodified peptide. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Dictionary< int, double > {\b modifications}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dictionary mapping residue positions (0 based) to modification masses. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isDecoy}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Is the peptide a decoy peptide or target peptide. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
List< double > {\b ions}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
List of theoretical ion m/z values. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Simplified peptide class that stores peptide/peptidoform information. \par
}{
Definition at line {\b 8} of file {\b Database.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Peptide\:CandidateSearch.util.Peptide}
{\xe \v CandidateSearch.util.Peptide\:Peptide}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CandidateSearch.util.Peptide.Peptide (string  {\i Sequence}, double  {\i Mass}, Dictionary< int, double >  {\i Modifications}, {\b Settings}  {\i IonSettings}, bool  {\i IsDecoy})}}
\par
{\bkmkstart AAAAAAAABD}
{\bkmkend AAAAAAAABD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor for a new peptide/pepidoform. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i Sequence} \cell }{Sequence of amino acids.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i Mass} \cell }{Mass of the unmodified peptide.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i Modifications} \cell }{Dictionary that maps amino acid positions (0 based) to modification masses.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i IonSettings} \cell }{Settings used for ion calculation.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i IsDecoy} \cell }{Whether or not the peptide is a decoy peptide.\cell }
{\row }
}
}{
Definition at line {\b 39} of file {\b Database.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v addModification\:CandidateSearch.util.Peptide}
{\xe \v CandidateSearch.util.Peptide\:addModification}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CandidateSearch.util.Peptide.addModification (int  {\i position}, double  {\i mass})}}
\par
{\bkmkstart AAAAAAAABE}
{\bkmkend AAAAAAAABE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds a modification to the peptide if the peptide isn't already modified at that position. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i position} \cell }{The position (0 based) of the modification.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i mass} \cell }{The modification mass.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
True if the modification was added, false if there is already a modification on the specified residue.\par
}}}{
Definition at line {\b 97} of file {\b Database.cs}.}\par
}
{\xe \v getEnconding\:CandidateSearch.util.Peptide}
{\xe \v CandidateSearch.util.Peptide\:getEnconding}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int[] CandidateSearch.util.Peptide.getEnconding (int  {\i massRange} = {\f2 5000}, int  {\i massMultiplier} = {\f2 100})}}
\par
{\bkmkstart AAAAAAAABF}
{\bkmkend AAAAAAAABF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the encoding vector of the peptide. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i massRange} \cell }{Maximum m/z that should be considered while encoding. Has to match the specifications of VectorSearch.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i massMultiplier} \cell }{Precision of the encoding. Has to match the specifications of VectorSearch.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The encoding vector as an integer array.\par
}}}{
Definition at line {\b 54} of file {\b Database.cs}.}\par
}
{\xe \v ToString\:CandidateSearch.util.Peptide}
{\xe \v CandidateSearch.util.Peptide\:ToString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
override string CandidateSearch.util.Peptide.ToString ()}}
\par
{\bkmkstart AAAAAAAABG}
{\bkmkend AAAAAAAABG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructs a string representation of the peptide. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The string representation of the peptide.\par
}}}{
Definition at line {\b 73} of file {\b Database.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Property Documentation\par
\pard\plain 
{\xe \v ions\:CandidateSearch.util.Peptide}
{\xe \v CandidateSearch.util.Peptide\:ions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
List<double> CandidateSearch.util.Peptide.ions{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAABH}
{\bkmkend AAAAAAAABH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
List of theoretical ion m/z values. }}\par
{
Definition at line {\b 29} of file {\b Database.cs}.}\par
}
{\xe \v isDecoy\:CandidateSearch.util.Peptide}
{\xe \v CandidateSearch.util.Peptide\:isDecoy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CandidateSearch.util.Peptide.isDecoy{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAABI}
{\bkmkend AAAAAAAABI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Is the peptide a decoy peptide or target peptide. }}\par
{
Definition at line {\b 25} of file {\b Database.cs}.}\par
}
{\xe \v mass\:CandidateSearch.util.Peptide}
{\xe \v CandidateSearch.util.Peptide\:mass}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double CandidateSearch.util.Peptide.mass{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAABJ}
{\bkmkend AAAAAAAABJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Mass of the unmodified peptide. }}\par
{
Definition at line {\b 17} of file {\b Database.cs}.}\par
}
{\xe \v modifications\:CandidateSearch.util.Peptide}
{\xe \v CandidateSearch.util.Peptide\:modifications}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Dictionary<int, double> CandidateSearch.util.Peptide.modifications{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAABK}
{\bkmkend AAAAAAAABK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dictionary mapping residue positions (0 based) to modification masses. }}\par
{
Definition at line {\b 21} of file {\b Database.cs}.}\par
}
{\xe \v sequence\:CandidateSearch.util.Peptide}
{\xe \v CandidateSearch.util.Peptide\:sequence}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string CandidateSearch.util.Peptide.sequence{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAABL}
{\bkmkend AAAAAAAABL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Amino acid sequence of the peptide. }}\par
{
Definition at line {\b 13} of file {\b Database.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
util/Database.cs\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MSAMANDA_CHEMICALUTILS.Permutations Class Reference\par \pard\plain 
{\tc\tcl2 \v MSAMANDA_CHEMICALUTILS.Permutations}
{\xe \v MSAMANDA_CHEMICALUTILS.Permutations}
{\bkmkstart AAAAAAAADG}
{\bkmkend AAAAAAAADG}
Inheritance diagram for MSAMANDA_CHEMICALUTILS.Permutations:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_s_a_m_a_n_d_a___c_h_e_m_i_c_a_l_u_t_i_l_s_1_1_permutations.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Permutations} (int n, int k)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Permutations} (string key, List< int[]> elems)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int[] {\b Successor} (int[] previous)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b CalculatePermutations} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Equals} ({\b Permutations} other)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Properties\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b N}{\f2  [get, set]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b K}{\f2  [get, set]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
List< int[]> {\b Elements}{\f2  [get, set]}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 59} of file {\b ChemicalUtils.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Permutations\:MSAMANDA_CHEMICALUTILS.Permutations}
{\xe \v MSAMANDA_CHEMICALUTILS.Permutations\:Permutations}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MSAMANDA_CHEMICALUTILS.Permutations.Permutations (int  {\i n}, int  {\i k})}}
\par
{\bkmkstart AAAAAAAADH}
{\bkmkend AAAAAAAADH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 65} of file {\b ChemicalUtils.cs}.}\par
}
{\xe \v Permutations\:MSAMANDA_CHEMICALUTILS.Permutations}
{\xe \v MSAMANDA_CHEMICALUTILS.Permutations\:Permutations}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MSAMANDA_CHEMICALUTILS.Permutations.Permutations (string  {\i key}, List< int[]>  {\i elems})}}
\par
{\bkmkstart AAAAAAAADI}
{\bkmkend AAAAAAAADI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 78} of file {\b ChemicalUtils.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v CalculatePermutations\:MSAMANDA_CHEMICALUTILS.Permutations}
{\xe \v MSAMANDA_CHEMICALUTILS.Permutations\:CalculatePermutations}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MSAMANDA_CHEMICALUTILS.Permutations.CalculatePermutations ()}}
\par
{\bkmkstart AAAAAAAADJ}
{\bkmkend AAAAAAAADJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 107} of file {\b ChemicalUtils.cs}.}\par
}
{\xe \v Equals\:MSAMANDA_CHEMICALUTILS.Permutations}
{\xe \v MSAMANDA_CHEMICALUTILS.Permutations\:Equals}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MSAMANDA_CHEMICALUTILS.Permutations.Equals ({\b Permutations}  {\i other})}}
\par
{\bkmkstart AAAAAAAADK}
{\bkmkend AAAAAAAADK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 119} of file {\b ChemicalUtils.cs}.}\par
}
{\xe \v Successor\:MSAMANDA_CHEMICALUTILS.Permutations}
{\xe \v MSAMANDA_CHEMICALUTILS.Permutations\:Successor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int[] MSAMANDA_CHEMICALUTILS.Permutations.Successor (int[]  {\i previous})}}
\par
{\bkmkstart AAAAAAAADL}
{\bkmkend AAAAAAAADL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 86} of file {\b ChemicalUtils.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Property Documentation\par
\pard\plain 
{\xe \v Elements\:MSAMANDA_CHEMICALUTILS.Permutations}
{\xe \v MSAMANDA_CHEMICALUTILS.Permutations\:Elements}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
List<int[]> MSAMANDA_CHEMICALUTILS.Permutations.Elements{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAADM}
{\bkmkend AAAAAAAADM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 63} of file {\b ChemicalUtils.cs}.}\par
}
{\xe \v K\:MSAMANDA_CHEMICALUTILS.Permutations}
{\xe \v MSAMANDA_CHEMICALUTILS.Permutations\:K}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int MSAMANDA_CHEMICALUTILS.Permutations.K{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAADN}
{\bkmkend AAAAAAAADN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 62} of file {\b ChemicalUtils.cs}.}\par
}
{\xe \v N\:MSAMANDA_CHEMICALUTILS.Permutations}
{\xe \v MSAMANDA_CHEMICALUTILS.Permutations\:N}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int MSAMANDA_CHEMICALUTILS.Permutations.N{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAADO}
{\bkmkend AAAAAAAADO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 61} of file {\b ChemicalUtils.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
amanda/ChemicalUtils.cs\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MSAMANDA_MGFPARSER.Precursor Class Reference\par \pard\plain 
{\tc\tcl2 \v MSAMANDA_MGFPARSER.Precursor}
{\xe \v MSAMANDA_MGFPARSER.Precursor}
{\bkmkstart AAAAAAAAHG}
{\bkmkend AAAAAAAAHG}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetMassCharge} (double mz, int charge, bool mono)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Properties\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b MOverZ}{\f2  [get]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b UnChargedMass}{\f2  [get]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b Intensity}{\f2  [get, set]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b Charge}{\f2  [get]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b Rank}{\f2  [get, set]}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 23} of file {\b MGFParser.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v SetMassCharge\:MSAMANDA_MGFPARSER.Precursor}
{\xe \v MSAMANDA_MGFPARSER.Precursor\:SetMassCharge}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MSAMANDA_MGFPARSER.Precursor.SetMassCharge (double  {\i mz}, int  {\i charge}, bool  {\i mono})}}
\par
{\bkmkstart AAAAAAAAHH}
{\bkmkend AAAAAAAAHH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 31} of file {\b MGFParser.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Property Documentation\par
\pard\plain 
{\xe \v Charge\:MSAMANDA_MGFPARSER.Precursor}
{\xe \v MSAMANDA_MGFPARSER.Precursor\:Charge}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int MSAMANDA_MGFPARSER.Precursor.Charge{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAAHI}
{\bkmkend AAAAAAAAHI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 28} of file {\b MGFParser.cs}.}\par
}
{\xe \v Intensity\:MSAMANDA_MGFPARSER.Precursor}
{\xe \v MSAMANDA_MGFPARSER.Precursor\:Intensity}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double MSAMANDA_MGFPARSER.Precursor.Intensity{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAAHJ}
{\bkmkend AAAAAAAAHJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 27} of file {\b MGFParser.cs}.}\par
}
{\xe \v MOverZ\:MSAMANDA_MGFPARSER.Precursor}
{\xe \v MSAMANDA_MGFPARSER.Precursor\:MOverZ}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double MSAMANDA_MGFPARSER.Precursor.MOverZ{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAAHK}
{\bkmkend AAAAAAAAHK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 25} of file {\b MGFParser.cs}.}\par
}
{\xe \v Rank\:MSAMANDA_MGFPARSER.Precursor}
{\xe \v MSAMANDA_MGFPARSER.Precursor\:Rank}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int MSAMANDA_MGFPARSER.Precursor.Rank{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAAHL}
{\bkmkend AAAAAAAAHL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 29} of file {\b MGFParser.cs}.}\par
}
{\xe \v UnChargedMass\:MSAMANDA_MGFPARSER.Precursor}
{\xe \v MSAMANDA_MGFPARSER.Precursor\:UnChargedMass}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double MSAMANDA_MGFPARSER.Precursor.UnChargedMass{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAAHM}
{\bkmkend AAAAAAAAHM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 26} of file {\b MGFParser.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
amanda/MGFParser.cs\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MSAMANDA_FASTAPARSER.ProteinDigester Class Reference\par \pard\plain 
{\tc\tcl2 \v MSAMANDA_FASTAPARSER.ProteinDigester}
{\xe \v MSAMANDA_FASTAPARSER.ProteinDigester}
{\bkmkstart AAAAAAAAEZ}
{\bkmkend AAAAAAAAEZ}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ProteinDigester} ({\b Enzyme} enzyme, int missedCleavages, bool useMonoisotopicMass, int minPepLength, int maxPepLength, {\b DBProtein} dbProtein)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
List< {\b DBPeptide} > {\b DigestProteinIntoList} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 536} of file {\b FASTAParser.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v ProteinDigester\:MSAMANDA_FASTAPARSER.ProteinDigester}
{\xe \v MSAMANDA_FASTAPARSER.ProteinDigester\:ProteinDigester}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MSAMANDA_FASTAPARSER.ProteinDigester.ProteinDigester ({\b Enzyme}  {\i enzyme}, int  {\i missedCleavages}, bool  {\i useMonoisotopicMass}, int  {\i minPepLength}, int  {\i maxPepLength}, {\b DBProtein}  {\i dbProtein})}}
\par
{\bkmkstart AAAAAAAAFA}
{\bkmkend AAAAAAAAFA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 553} of file {\b FASTAParser.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v DigestProteinIntoList\:MSAMANDA_FASTAPARSER.ProteinDigester}
{\xe \v MSAMANDA_FASTAPARSER.ProteinDigester\:DigestProteinIntoList}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
List< {\b DBPeptide} > MSAMANDA_FASTAPARSER.ProteinDigester.DigestProteinIntoList ()}}
\par
{\bkmkstart AAAAAAAAFB}
{\bkmkend AAAAAAAAFB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 564} of file {\b FASTAParser.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
amanda/FASTAParser.cs\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CandidateSearch.util.Result Class Reference\par \pard\plain 
{\tc\tcl2 \v CandidateSearch.util.Result}
{\xe \v CandidateSearch.util.Result}
{\bkmkstart AAAAAAAABM}
{\bkmkend AAAAAAAABM}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Result class to transform and store the returned integer array of VectorSearch. }}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Result} (ref int[] SearchResult, ref List< {\b Peptide} > Peptides, ref List< {\b Spectrum} > Spectra, int TopN)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor creating a result item that stores the processed VectorSearch result. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b export} (string filename)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Exports the results to csv format into a file with the given filename. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Properties\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Dictionary< int, List< {\b Peptide} > > {\b result}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dictionary that maps scan numbers to lists of peptide candidates. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Result class to transform and store the returned integer array of VectorSearch. \par
}{
Definition at line {\b 6} of file {\b Result.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Result\:CandidateSearch.util.Result}
{\xe \v CandidateSearch.util.Result\:Result}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CandidateSearch.util.Result.Result (ref int[]  {\i SearchResult}, ref List< {\b Peptide} >  {\i Peptides}, ref List< {\b Spectrum} >  {\i Spectra}, int  {\i TopN})}}
\par
{\bkmkstart AAAAAAAABN}
{\bkmkend AAAAAAAABN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor creating a result item that stores the processed VectorSearch result. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i SearchResult} \cell }{The search result of the VectorSearch.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i Peptides} \cell }{The complete list of considered peptides/peptidoforms.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i Spectra} \cell }{The complete list of searched spectra.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i TopN} \cell }{The number of top candidates reported for each spectrum.\cell }
{\row }
}
}{
Definition at line {\b 20} of file {\b Result.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v export\:CandidateSearch.util.Result}
{\xe \v CandidateSearch.util.Result\:export}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CandidateSearch.util.Result.export (string  {\i filename})}}
\par
{\bkmkstart AAAAAAAABO}
{\bkmkend AAAAAAAABO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Exports the results to csv format into a file with the given filename. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i filename} \cell }{The output filename.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
0 if the export was successful, 1 if it was unsuccessful.\par
}}}{
Definition at line {\b 49} of file {\b Result.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Property Documentation\par
\pard\plain 
{\xe \v result\:CandidateSearch.util.Result}
{\xe \v CandidateSearch.util.Result\:result}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Dictionary<int, List<{\b Peptide}> > CandidateSearch.util.Result.result{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAABP}
{\bkmkend AAAAAAAABP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dictionary that maps scan numbers to lists of peptide candidates. }}\par
{
Definition at line {\b 11} of file {\b Result.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
util/Result.cs\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CandidateSearch.util.Settings Class Reference\par \pard\plain 
{\tc\tcl2 \v CandidateSearch.util.Settings}
{\xe \v CandidateSearch.util.Settings}
{\bkmkstart AAAAAAAABQ}
{\bkmkend AAAAAAAABQ}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Settings for digestion, ion calculation and VectorSearch. }}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Settings} (int MaxCleavages=2, int MinPepLength=5, int MaxPepLength=30, int MaxPrecursorCharge=4, string MaxFragmentCharge="+1", int MaxNeutralLosses=1, int MaxNeutralLossMods=2, bool DecoySearch=true, int TopN=1000, float Tolerance=0.02f, bool Normalize=false, bool UseGaussian=true, string Mode="CPU_DV")\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Settings constructor to set the specified search parameters. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b addFixedModification} (string aminoAcid, double mass)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add a fixed modification to the fixed modification dictionary. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b addVariableModification} (string aminoAcid, double mass)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add a variable modification to the variable modification dictionary. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b modificationsToString} (bool variable=false)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a string representation of the modifications. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
override string {\b ToString} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a string representation of the settings. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Properties\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b MAX_CLEAVAGES}{\f2  [get, set]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Maximum number of missed cleavages allowed during digestion. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b MIN_PEP_LENGTH}{\f2  [get, set]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Minimum peptide length. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b MAX_PEP_LENGTH}{\f2  [get, set]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Maximum peptide length. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b MAX_PRECURSOR_CHARGE}{\f2  [get, set]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Maximum considered precursor ion charge. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b MAX_FRAGMENT_CHARGE}{\f2  [get, set]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Maximum considered fragment ion charge. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b MAX_NEUTRAL_LOSSES}{\f2  [get, set]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Maximum number of considered neutral losses. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b MAX_NEUTRAL_LOSS_MODS}{\f2  [get, set]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Maximum number of considered neutral loss modifications. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Dictionary< string, double > {\b FIXED_MODIFICATIONS}{\f2  [get, set]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dictionary for fixed modifications that maps amino acids to their possible modification masses. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Dictionary< string, double > {\b VARIABLE_MODIFICATIONS}{\f2  [get, set]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dictionary for variable modifications that maps amino acids to their possible modification masses. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b DECOY_SEARCH}{\f2  [get, set]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether or not decoy search should be performed. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b TOP_N}{\f2  [get, set]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The top n candidates that should be returned by the VectorSearch. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b TOLERANCE}{\f2  [get, set]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The tolerance used for the VectorSearch. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b NORMALIZE}{\f2  [get, set]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether or not scores should be normalized by the VectorSearch. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b USE_GAUSSIAN}{\f2  [get, set]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether or not peaks should be modelled as gaussian distributions by the VectorSearch. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b MODE}{\f2  [get, set]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The search approach used by the VectorSearch. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Settings for digestion, ion calculation and VectorSearch. \par
}{
Definition at line {\b 8} of file {\b Settings.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Settings\:CandidateSearch.util.Settings}
{\xe \v CandidateSearch.util.Settings\:Settings}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CandidateSearch.util.Settings.Settings (int  {\i MaxCleavages} = {\f2 2}, int  {\i MinPepLength} = {\f2 5}, int  {\i MaxPepLength} = {\f2 30}, int  {\i MaxPrecursorCharge} = {\f2 4}, string  {\i MaxFragmentCharge} = {\f2 "+1"}, int  {\i MaxNeutralLosses} = {\f2 1}, int  {\i MaxNeutralLossMods} = {\f2 2}, bool  {\i DecoySearch} = {\f2 true}, int  {\i TopN} = {\f2 1000}, float  {\i Tolerance} = {\f2 0::02f}, bool  {\i Normalize} = {\f2 false}, bool  {\i UseGaussian} = {\f2 true}, string  {\i Mode} = {\f2 "CPU_DV"})}}
\par
{\bkmkstart AAAAAAAABR}
{\bkmkend AAAAAAAABR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Settings constructor to set the specified search parameters. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i MaxCleavages} \cell }{Maximum number of missed cleavages allowed during digestion.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i MinPepLength} \cell }{Minimum peptide length.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i MaxPepLength} \cell }{Maximum peptide length.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i MaxPrecursorCharge} \cell }{Maximum considered precursor ion charge.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i MaxFragmentCharge} \cell }{Maximum considered fragment ion charge.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i MaxNeutralLosses} \cell }{Maximum number of considered neutral losses.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i MaxNeutralLossMods} \cell }{Maximum number of considered neutral loss modifications.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i DecoySearch} \cell }{Whether or not decoy search should be performed.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i TopN} \cell }{The top n candidates that should be returned by the VectorSearch.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i Tolerance} \cell }{The tolerance used for the VectorSearch.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i Normalize} \cell }{Whether or not scores should be normalized by the VectorSearch.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i UseGaussian} \cell }{Whether or not peaks should be modelled as gaussian distributions by the VectorSearch.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i Mode} \cell }{The search approach used by the VectorSearch.\cell }
{\row }
}
}{
Definition at line {\b 94} of file {\b Settings.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v addFixedModification\:CandidateSearch.util.Settings}
{\xe \v CandidateSearch.util.Settings\:addFixedModification}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CandidateSearch.util.Settings.addFixedModification (string  {\i aminoAcid}, double  {\i mass})}}
\par
{\bkmkstart AAAAAAAABS}
{\bkmkend AAAAAAAABS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add a fixed modification to the fixed modification dictionary. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i aminoAcid} \cell }{The amino acid that will be modified.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i mass} \cell }{The mass of the modification.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
True if there is no modification for that amino acid yet, false if there already exists a modification for that amino acid.\par
}}}{
Definition at line {\b 125} of file {\b Settings.cs}.}\par
}
{\xe \v addVariableModification\:CandidateSearch.util.Settings}
{\xe \v CandidateSearch.util.Settings\:addVariableModification}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CandidateSearch.util.Settings.addVariableModification (string  {\i aminoAcid}, double  {\i mass})}}
\par
{\bkmkstart AAAAAAAABT}
{\bkmkend AAAAAAAABT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add a variable modification to the variable modification dictionary. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i aminoAcid} \cell }{The amino acid that can be modified.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i mass} \cell }{The mass of the modification.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
True if there is no modification for that amino acid yet, false if there already exists a modification for that amino acid.\par
}}}{
Definition at line {\b 140} of file {\b Settings.cs}.}\par
}
{\xe \v modificationsToString\:CandidateSearch.util.Settings}
{\xe \v CandidateSearch.util.Settings\:modificationsToString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string CandidateSearch.util.Settings.modificationsToString (bool  {\i variable} = {\f2 false})}}
\par
{\bkmkstart AAAAAAAABU}
{\bkmkend AAAAAAAABU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a string representation of the modifications. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i variable} \cell }{Whether to process fixed or variable modifications.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The string representation of the specified modification set.\par
}}}{
Definition at line {\b 154} of file {\b Settings.cs}.}\par
}
{\xe \v ToString\:CandidateSearch.util.Settings}
{\xe \v CandidateSearch.util.Settings\:ToString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
override string CandidateSearch.util.Settings.ToString ()}}
\par
{\bkmkstart AAAAAAAABV}
{\bkmkend AAAAAAAABV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a string representation of the settings. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The string representation of the settings.\par
}}}{
Definition at line {\b 178} of file {\b Settings.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Property Documentation\par
\pard\plain 
{\xe \v DECOY_SEARCH\:CandidateSearch.util.Settings}
{\xe \v CandidateSearch.util.Settings\:DECOY_SEARCH}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CandidateSearch.util.Settings.DECOY_SEARCH{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAABW}
{\bkmkend AAAAAAAABW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether or not decoy search should be performed. }}\par
{
Definition at line {\b 54} of file {\b Settings.cs}.}\par
}
{\xe \v FIXED_MODIFICATIONS\:CandidateSearch.util.Settings}
{\xe \v CandidateSearch.util.Settings\:FIXED_MODIFICATIONS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Dictionary<string, double> CandidateSearch.util.Settings.FIXED_MODIFICATIONS{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAABX}
{\bkmkend AAAAAAAABX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dictionary for fixed modifications that maps amino acids to their possible modification masses. }}\par
{
Definition at line {\b 44} of file {\b Settings.cs}.}\par
}
{\xe \v MAX_CLEAVAGES\:CandidateSearch.util.Settings}
{\xe \v CandidateSearch.util.Settings\:MAX_CLEAVAGES}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CandidateSearch.util.Settings.MAX_CLEAVAGES{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAABY}
{\bkmkend AAAAAAAABY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Maximum number of missed cleavages allowed during digestion. }}\par
{
Definition at line {\b 14} of file {\b Settings.cs}.}\par
}
{\xe \v MAX_FRAGMENT_CHARGE\:CandidateSearch.util.Settings}
{\xe \v CandidateSearch.util.Settings\:MAX_FRAGMENT_CHARGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string CandidateSearch.util.Settings.MAX_FRAGMENT_CHARGE{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAABZ}
{\bkmkend AAAAAAAABZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Maximum considered fragment ion charge. }}\par
{
Definition at line {\b 32} of file {\b Settings.cs}.}\par
}
{\xe \v MAX_NEUTRAL_LOSS_MODS\:CandidateSearch.util.Settings}
{\xe \v CandidateSearch.util.Settings\:MAX_NEUTRAL_LOSS_MODS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CandidateSearch.util.Settings.MAX_NEUTRAL_LOSS_MODS{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAACA}
{\bkmkend AAAAAAAACA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Maximum number of considered neutral loss modifications. }}\par
{
Definition at line {\b 40} of file {\b Settings.cs}.}\par
}
{\xe \v MAX_NEUTRAL_LOSSES\:CandidateSearch.util.Settings}
{\xe \v CandidateSearch.util.Settings\:MAX_NEUTRAL_LOSSES}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CandidateSearch.util.Settings.MAX_NEUTRAL_LOSSES{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAACB}
{\bkmkend AAAAAAAACB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Maximum number of considered neutral losses. }}\par
{
Definition at line {\b 36} of file {\b Settings.cs}.}\par
}
{\xe \v MAX_PEP_LENGTH\:CandidateSearch.util.Settings}
{\xe \v CandidateSearch.util.Settings\:MAX_PEP_LENGTH}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CandidateSearch.util.Settings.MAX_PEP_LENGTH{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAACC}
{\bkmkend AAAAAAAACC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Maximum peptide length. }}\par
{
Definition at line {\b 22} of file {\b Settings.cs}.}\par
}
{\xe \v MAX_PRECURSOR_CHARGE\:CandidateSearch.util.Settings}
{\xe \v CandidateSearch.util.Settings\:MAX_PRECURSOR_CHARGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CandidateSearch.util.Settings.MAX_PRECURSOR_CHARGE{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAACD}
{\bkmkend AAAAAAAACD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Maximum considered precursor ion charge. }}\par
{
Definition at line {\b 28} of file {\b Settings.cs}.}\par
}
{\xe \v MIN_PEP_LENGTH\:CandidateSearch.util.Settings}
{\xe \v CandidateSearch.util.Settings\:MIN_PEP_LENGTH}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CandidateSearch.util.Settings.MIN_PEP_LENGTH{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAACE}
{\bkmkend AAAAAAAACE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Minimum peptide length. }}\par
{
Definition at line {\b 18} of file {\b Settings.cs}.}\par
}
{\xe \v MODE\:CandidateSearch.util.Settings}
{\xe \v CandidateSearch.util.Settings\:MODE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string CandidateSearch.util.Settings.MODE{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAACF}
{\bkmkend AAAAAAAACF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The search approach used by the VectorSearch. }}\par
{
Definition at line {\b 76} of file {\b Settings.cs}.}\par
}
{\xe \v NORMALIZE\:CandidateSearch.util.Settings}
{\xe \v CandidateSearch.util.Settings\:NORMALIZE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CandidateSearch.util.Settings.NORMALIZE{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAACG}
{\bkmkend AAAAAAAACG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether or not scores should be normalized by the VectorSearch. }}\par
{
Definition at line {\b 68} of file {\b Settings.cs}.}\par
}
{\xe \v TOLERANCE\:CandidateSearch.util.Settings}
{\xe \v CandidateSearch.util.Settings\:TOLERANCE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float CandidateSearch.util.Settings.TOLERANCE{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAACH}
{\bkmkend AAAAAAAACH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The tolerance used for the VectorSearch. }}\par
{
Definition at line {\b 64} of file {\b Settings.cs}.}\par
}
{\xe \v TOP_N\:CandidateSearch.util.Settings}
{\xe \v CandidateSearch.util.Settings\:TOP_N}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CandidateSearch.util.Settings.TOP_N{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAACI}
{\bkmkend AAAAAAAACI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The top n candidates that should be returned by the VectorSearch. }}\par
{
Definition at line {\b 60} of file {\b Settings.cs}.}\par
}
{\xe \v USE_GAUSSIAN\:CandidateSearch.util.Settings}
{\xe \v CandidateSearch.util.Settings\:USE_GAUSSIAN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CandidateSearch.util.Settings.USE_GAUSSIAN{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAACJ}
{\bkmkend AAAAAAAACJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether or not peaks should be modelled as gaussian distributions by the VectorSearch. }}\par
{
Definition at line {\b 72} of file {\b Settings.cs}.}\par
}
{\xe \v VARIABLE_MODIFICATIONS\:CandidateSearch.util.Settings}
{\xe \v CandidateSearch.util.Settings\:VARIABLE_MODIFICATIONS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Dictionary<string, double> CandidateSearch.util.Settings.VARIABLE_MODIFICATIONS{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAACK}
{\bkmkend AAAAAAAACK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dictionary for variable modifications that maps amino acids to their possible modification masses. }}\par
{
Definition at line {\b 48} of file {\b Settings.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
util/Settings.cs\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CandidateSearch.util.Spectrum Class Reference\par \pard\plain 
{\tc\tcl2 \v CandidateSearch.util.Spectrum}
{\xe \v CandidateSearch.util.Spectrum}
{\bkmkstart AAAAAAAACL}
{\bkmkend AAAAAAAACL}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Simplified spectrum class implemention of a mass spectrum. }}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Spectrum} (double[] Mz, double[] Intensity, int ScanNumber)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor to create a new spectrum. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int[] {\b getEncoding} (int massRange=5000, int massMultiplier=100)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the encoding vector of the spectrum. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Properties\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double[] {\b mz}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Array containing m/z values of centroid peaks. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double[] {\b intensity}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Array containing intensities of centroid peaks. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b scanNumber}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The scan number of the spectrum. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Simplified spectrum class implemention of a mass spectrum. \par
}{
Definition at line {\b 6} of file {\b Spectra.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Spectrum\:CandidateSearch.util.Spectrum}
{\xe \v CandidateSearch.util.Spectrum\:Spectrum}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CandidateSearch.util.Spectrum.Spectrum (double[]  {\i Mz}, double[]  {\i Intensity}, int  {\i ScanNumber})}}
\par
{\bkmkstart AAAAAAAACM}
{\bkmkend AAAAAAAACM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor to create a new spectrum. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i Mz} \cell }{Array containing m/z values of centroid peaks.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i Intensity} \cell }{Array containing intensities of centroid peaks.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ScanNumber} \cell }{The scan number of the spectrum.\cell }
{\row }
}
}{
Definition at line {\b 27} of file {\b Spectra.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v getEncoding\:CandidateSearch.util.Spectrum}
{\xe \v CandidateSearch.util.Spectrum\:getEncoding}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int[] CandidateSearch.util.Spectrum.getEncoding (int  {\i massRange} = {\f2 5000}, int  {\i massMultiplier} = {\f2 100})}}
\par
{\bkmkstart AAAAAAAACN}
{\bkmkend AAAAAAAACN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the encoding vector of the spectrum. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i massRange} \cell }{Maximum m/z that should be considered while encoding. Has to match the specifications of VectorSearch.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i massMultiplier} \cell }{Precision of the encoding. Has to match the specifications of VectorSearch.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The encoding vector as an integer array.\par
}}}{
Definition at line {\b 41} of file {\b Spectra.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Property Documentation\par
\pard\plain 
{\xe \v intensity\:CandidateSearch.util.Spectrum}
{\xe \v CandidateSearch.util.Spectrum\:intensity}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double [] CandidateSearch.util.Spectrum.intensity{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAACO}
{\bkmkend AAAAAAAACO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Array containing intensities of centroid peaks. }}\par
{
Definition at line {\b 15} of file {\b Spectra.cs}.}\par
}
{\xe \v mz\:CandidateSearch.util.Spectrum}
{\xe \v CandidateSearch.util.Spectrum\:mz}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double [] CandidateSearch.util.Spectrum.mz{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAACP}
{\bkmkend AAAAAAAACP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Array containing m/z values of centroid peaks. }}\par
{
Definition at line {\b 11} of file {\b Spectra.cs}.}\par
}
{\xe \v scanNumber\:CandidateSearch.util.Spectrum}
{\xe \v CandidateSearch.util.Spectrum\:scanNumber}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CandidateSearch.util.Spectrum.scanNumber{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAACQ}
{\bkmkend AAAAAAAACQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The scan number of the spectrum. }}\par
{
Definition at line {\b 19} of file {\b Spectra.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
util/Spectra.cs\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MSAMANDA_MGFPARSER.Spectrum Class Reference\par \pard\plain 
{\tc\tcl2 \v MSAMANDA_MGFPARSER.Spectrum}
{\xe \v MSAMANDA_MGFPARSER.Spectrum}
{\bkmkstart AAAAAAAAHN}
{\bkmkend AAAAAAAAHN}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Properties\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ScanNumber}{\f2  [get, set]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SpectrumId}{\f2  [get, set]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b RT}{\f2  [get, set]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
List< {\b AMassCentroid} > {\b FragmentsPeaks}{\f2  [get, set]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Dictionary< int, double > {\b ImmunePeaks}{\f2  [get, set]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
SortedSet< double > {\b ImmuneMasses}{\f2  [get, set]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Precursor} {\b Precursor}{\f2  [get, set]}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 39} of file {\b MGFParser.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Spectrum\:MSAMANDA_MGFPARSER.Spectrum}
{\xe \v MSAMANDA_MGFPARSER.Spectrum\:Spectrum}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MSAMANDA_MGFPARSER.Spectrum.Spectrum ()}}
\par
{\bkmkstart AAAAAAAAHO}
{\bkmkend AAAAAAAAHO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 49} of file {\b MGFParser.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Property Documentation\par
\pard\plain 
{\xe \v FragmentsPeaks\:MSAMANDA_MGFPARSER.Spectrum}
{\xe \v MSAMANDA_MGFPARSER.Spectrum\:FragmentsPeaks}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
List<{\b AMassCentroid}> MSAMANDA_MGFPARSER.Spectrum.FragmentsPeaks{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAAHP}
{\bkmkend AAAAAAAAHP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 44} of file {\b MGFParser.cs}.}\par
}
{\xe \v ImmuneMasses\:MSAMANDA_MGFPARSER.Spectrum}
{\xe \v MSAMANDA_MGFPARSER.Spectrum\:ImmuneMasses}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
SortedSet<double> MSAMANDA_MGFPARSER.Spectrum.ImmuneMasses{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAAHQ}
{\bkmkend AAAAAAAAHQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 46} of file {\b MGFParser.cs}.}\par
}
{\xe \v ImmunePeaks\:MSAMANDA_MGFPARSER.Spectrum}
{\xe \v MSAMANDA_MGFPARSER.Spectrum\:ImmunePeaks}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Dictionary<int, double> MSAMANDA_MGFPARSER.Spectrum.ImmunePeaks{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAAHR}
{\bkmkend AAAAAAAAHR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 45} of file {\b MGFParser.cs}.}\par
}
{\xe \v Precursor\:MSAMANDA_MGFPARSER.Spectrum}
{\xe \v MSAMANDA_MGFPARSER.Spectrum\:Precursor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Precursor} MSAMANDA_MGFPARSER.Spectrum.Precursor{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAAHS}
{\bkmkend AAAAAAAAHS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 47} of file {\b MGFParser.cs}.}\par
}
{\xe \v RT\:MSAMANDA_MGFPARSER.Spectrum}
{\xe \v MSAMANDA_MGFPARSER.Spectrum\:RT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double MSAMANDA_MGFPARSER.Spectrum.RT{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAAHT}
{\bkmkend AAAAAAAAHT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 43} of file {\b MGFParser.cs}.}\par
}
{\xe \v ScanNumber\:MSAMANDA_MGFPARSER.Spectrum}
{\xe \v MSAMANDA_MGFPARSER.Spectrum\:ScanNumber}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int MSAMANDA_MGFPARSER.Spectrum.ScanNumber{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAAHU}
{\bkmkend AAAAAAAAHU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 41} of file {\b MGFParser.cs}.}\par
}
{\xe \v SpectrumId\:MSAMANDA_MGFPARSER.Spectrum}
{\xe \v MSAMANDA_MGFPARSER.Spectrum\:SpectrumId}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int MSAMANDA_MGFPARSER.Spectrum.SpectrumId{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAAHV}
{\bkmkend AAAAAAAAHV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 42} of file {\b MGFParser.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
amanda/MGFParser.cs\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
VectorSearchInterface.VectorSearchAPI Class Reference\par \pard\plain 
{\tc\tcl2 \v VectorSearchInterface.VectorSearchAPI}
{\xe \v VectorSearchInterface.VectorSearchAPI}
{\bkmkstart AAAAAAAAHX}
{\bkmkend AAAAAAAAHX}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int[] {\b searchCPU} (ref int[] candidatesValues, ref int[] candidatesIdx, ref int[] spectraValues, ref int[] spectraIdx, int topN, float tolerance, bool normalize, bool useGaussianTol, bool batched, int batchSize, bool useSparse, int cores, int verbose, out int memStat)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calculates the top n candidates for each spectrum on the CPU using Eigen. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int[] {\b searchGPU} (ref int[] csrRowoffsets, ref int[] csrColIdx, ref int[] spectraValues, ref int[] spectraIdx, int topN, float tolerance, bool normalize, bool useGaussianTol, bool batched, int batchSize, bool useSparse, int verbose, out int memStat)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calculates the top n candidates for each spectrum on the (Nvidia) GPU using CUDA. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 5} of file {\b VectorSearchAPI.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v searchCPU\:VectorSearchInterface.VectorSearchAPI}
{\xe \v VectorSearchInterface.VectorSearchAPI\:searchCPU}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int[] VectorSearchInterface.VectorSearchAPI.searchCPU (ref int[]  {\i candidatesValues}, ref int[]  {\i candidatesIdx}, ref int[]  {\i spectraValues}, ref int[]  {\i spectraIdx}, int  {\i topN}, float  {\i tolerance}, bool  {\i normalize}, bool  {\i useGaussianTol}, bool  {\i batched}, int  {\i batchSize}, bool  {\i useSparse}, int  {\i cores}, int  {\i verbose}, out int  {\i memStat}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAHY}
{\bkmkend AAAAAAAAHY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calculates the top n candidates for each spectrum on the CPU using Eigen. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i candidatesValues} \cell }{An integer array of theoretical ion m/z values for all candidates flattened.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i candidatesIdx} \cell }{An integer array that contains indices indicating where each candidate starts in candidatesValues.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i spectraValues} \cell }{An integer array of peak m/z values from experimental spectra flattened.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i spectraIdx} \cell }{An integer array that contains indices indicating where each spectrum starts in spectraValues.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i topN} \cell }{The number (int) of top candidates that should be returned for each spectrum.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i tolerance} \cell }{Tolerance used for matching peaks in Dalton (float).\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i normalize} \cell }{Whether or not the candidate scores should be normalized by candidate length (bool).\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i useGaussianTol} \cell }{Whether or not experimental peaks should be modelled as gaussian normal distributions (bool).\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i batched} \cell }{Whether a batched approach (MM) or not (MV) should be used (bool).\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i batchSize} \cell }{If a batched approach is used, how big should batches be (integer).\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i useSparse} \cell }{Whether a sparse approach (SPMV/SPMM) or not (GEMV/GEMM) should be used (bool).\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i cores} \cell }{The number of CPU cores that should be used for computation (int).\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i verbose} \cell }{An integer parameter controlling how often progress should be printed to std::out. If 0 no progress will be printed.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i memStat} \cell }{An integer out parameter indicating if memory was successfully freed after execution, 0 = success, 1 = error.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
An integer array with length (number of spectra * topN) containing the indices of the top n candidates for every spectrum.\par
}}}{
Definition at line {\b 97} of file {\b VectorSearchAPI.cs}.}\par
}
{\xe \v searchGPU\:VectorSearchInterface.VectorSearchAPI}
{\xe \v VectorSearchInterface.VectorSearchAPI\:searchGPU}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int[] VectorSearchInterface.VectorSearchAPI.searchGPU (ref int[]  {\i csrRowoffsets}, ref int[]  {\i csrColIdx}, ref int[]  {\i spectraValues}, ref int[]  {\i spectraIdx}, int  {\i topN}, float  {\i tolerance}, bool  {\i normalize}, bool  {\i useGaussianTol}, bool  {\i batched}, int  {\i batchSize}, bool  {\i useSparse}, int  {\i verbose}, out int  {\i memStat}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAHZ}
{\bkmkend AAAAAAAAHZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calculates the top n candidates for each spectrum on the (Nvidia) GPU using CUDA. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i csrRowoffsets} \cell }{An integer array of rowoffsets of the CSR sparse matrix with length (rows + 1 = number of candidates + 1).\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i csrColIdx} \cell }{An integer array of column indices of the CSR sparse matrix with length (NNZ = total number of theoretical ions).\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i spectraValues} \cell }{An integer array of peak m/z values from experimental spectra flattened.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i spectraIdx} \cell }{An integer array that contains indices indicating where each spectrum starts in spectraValues.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i topN} \cell }{The number (int) of top candidates that should be returned for each spectrum.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i tolerance} \cell }{Tolerance used for matching peaks in Dalton (float).\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i normalize} \cell }{Whether or not the candidate scores should be normalized by candidate length (bool).\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i useGaussianTol} \cell }{Whether or not experimental peaks should be modelled as gaussian normal distributions (bool).\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i batched} \cell }{Whether a batched approach (MM) or not (MV) should be used (bool).\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i batchSize} \cell }{If a batched approach is used, how big should batches be (integer).\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i useSparse} \cell }{Whether a sparse approach (SPMV/SPMM) or not (GEMV/GEMM) should be used (bool).\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i verbose} \cell }{An integer parameter controlling how often progress should be printed to std::out. If 0 no progress will be printed.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i memStat} \cell }{An integer out parameter indicating if memory was successfully freed after execution, 0 = success, 1 = error.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
An integer array with length (number of spectra * topN) containing the indices of the top n candidates for every spectrum.\par
}}}{
Definition at line {\b 210} of file {\b VectorSearchAPI.cs}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
dll/VectorSearchAPI.cs\par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
File Documentation{\tc \v File Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ChemicalUtils.cs\par \pard\plain 
{\tc\tcl2 \v amanda/ChemicalUtils.cs}
{\xe \v amanda/ChemicalUtils.cs}
{\bkmkstart AAAAAAAAAA}
{\bkmkend AAAAAAAAAA}
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf17 namespace }MSAMANDA_CHEMICALUTILS\par
00002 \{\par
00003     {\cf17 public} {\cf17 class }ChemicalElement\par
00004     \{\par
00005         {\cf17 public} readonly {\cf18 string} Name;\par
00006         {\cf17 public} readonly {\cf18 string} FullName;\par
00007         {\cf17 public} readonly {\cf18 double} MonoMass;\par
00008         {\cf17 public} readonly {\cf18 double} AvgMass;\par
00009 \par
00010         {\cf17 public} ChemicalElement({\cf18 string} name, {\cf18 string} fullName, {\cf18 double} monoMass, {\cf18 double} avgMass)\par
00011         \{\par
00012             Name = name;\par
00013             FullName = fullName;\par
00014             MonoMass = monoMass;\par
00015             AvgMass = avgMass;\par
00016         \}\par
00017     \}\par
00018 \par
00019     {\cf17 public} {\cf17 class }AminoAcid\par
00020     \{\par
00021         {\cf17 public} readonly {\cf18 string} Name;\par
00022         {\cf17 public} readonly {\cf18 string} ThreeLetterCode;\par
00023         {\cf17 public} readonly {\cf18 char} OneLetterCode;\par
00024         {\cf17 private} readonly {\cf18 double} AverageMass;\par
00025         {\cf17 private} readonly {\cf18 double} MonoisotopicMass;\par
00026         {\cf17 public} readonly {\cf18 double} ImmoniumMass;\par
00027 \par
00028         {\cf17 public} {\cf18 double} Mass({\cf18 bool} mono)\par
00029         \{\par
00030             {\cf19 return} mono ? MonoisotopicMass : AverageMass;\par
00031         \}\par
00032 \par
00033         {\cf17 public} AminoAcid({\cf18 char} oneLetter, {\cf18 string} threeLetter, {\cf18 string} name, {\cf18 double} monoisotopicMass, {\cf18 double} avgMass, {\cf18 double} immoniumMass)\par
00034         \{\par
00035             AverageMass = avgMass;\par
00036             MonoisotopicMass = monoisotopicMass;\par
00037             Name = name;\par
00038             ThreeLetterCode = threeLetter;\par
00039             OneLetterCode = oneLetter;\par
00040             ImmoniumMass = immoniumMass;\par
00041         \}\par
00042 \par
00043         {\cf17 public} AminoAcid({\cf18 char} oneLetter, {\cf18 string} threeLetter, {\cf18 string} name, {\cf18 double} monoisotopicMass, {\cf18 double} avgMass, {\cf18 bool} mono = {\cf17 true})\par
00044         \{\par
00045             AverageMass = avgMass;\par
00046             MonoisotopicMass = monoisotopicMass;\par
00047             Name = name;\par
00048             ThreeLetterCode = threeLetter;\par
00049             OneLetterCode = oneLetter;\par
00050             {\cf19 if} (mono)\par
00051                 ImmoniumMass = MonoisotopicMass + ChemicalUtils.Chemicals[{\cf22 "H"}].MonoMass -\par
00052                 ChemicalUtils.Chemicals[{\cf22 "C"}].MonoMass - ChemicalUtils.Chemicals[{\cf22 "O"}].MonoMass;\par
00053             {\cf19 else}\par
00054                 ImmoniumMass = AverageMass + ChemicalUtils.Chemicals[{\cf22 "H"}].AvgMass -\par
00055                 ChemicalUtils.Chemicals[{\cf22 "C"}].AvgMass - ChemicalUtils.Chemicals[{\cf22 "O"}].AvgMass;\par
00056         \}\par
00057     \}\par
00058 \par
00059     {\cf17 public} {\cf17 class }Permutations : IEquatable<Permutations>\par
00060     \{\par
00061         {\cf17 public} {\cf18 int} N \{ {\cf17 get}; {\cf17 set}; \}\par
00062         {\cf17 public} {\cf18 int} K \{ {\cf17 get}; {\cf17 set}; \}\par
00063         {\cf17 public} List<int[]> Elements \{ {\cf17 get}; {\cf17 set}; \}\par
00064 \par
00065         {\cf17 public} Permutations({\cf18 int} n, {\cf18 int} k)\par
00066         \{\par
00067             N = n;\par
00068             K = k;\par
00069             Elements = {\cf17 new} List<int[]>();\par
00070             {\cf18 int}[] data = {\cf17 new} {\cf18 int}[k];\par
00071             {\cf19 for} ({\cf18 int} i = 0; i < k; ++i)\par
00072                 data[i] = i;\par
00073             Elements.Add(data);\par
00074 \par
00075             CalculatePermutations();\par
00076         \}\par
00077 \par
00078         {\cf17 public} Permutations({\cf18 string} key, List<{\cf18 int}[]> elems)\par
00079         \{\par
00080             {\cf18 string}[] s = key.Split({\cf23 '_'});\par
00081             N = Int32.Parse(s[0]);\par
00082             K = Int32.Parse(s[1]);\par
00083             Elements = elems;\par
00084         \}\par
00085 \par
00086         {\cf17 public} {\cf18 int}[] Successor({\cf18 int}[] previous)\par
00087         \{\par
00088             {\cf19 if} (previous.Length == 0 || previous[0] == {\cf17 this}.N - {\cf17 this}.K)\par
00089                 {\cf19 return} {\cf17 null};\par
00090 \par
00091             {\cf18 int}[] next = {\cf17 new} {\cf18 int}[K];\par
00092 \par
00093             {\cf18 int} i;\par
00094             {\cf19 for} (i = 0; i < this.K; ++i)\par
00095                 next[i] = previous[i];\par
00096 \par
00097             {\cf19 for} (i = this.K - 1; i > 0 && next[i] == this.N - this.K + i; --i) \{ \}\par
00098 \par
00099             ++next[i];\par
00100 \par
00101             {\cf19 for} ({\cf18 int} j = i; j < this.K - 1; ++j)\par
00102                 next[j + 1] = next[j] + 1;\par
00103 \par
00104             {\cf19 return} next;\par
00105         \}\par
00106 \par
00107         {\cf17 public} {\cf18 void} CalculatePermutations()\par
00108         \{\par
00109             {\cf18 int}[] last = Elements[0];\par
00110             {\cf18 int}[] next = Successor(last);\par
00111             {\cf19 while} (next != {\cf17 null})\par
00112             \{\par
00113                 Elements.Add(next);\par
00114                 last = next;\par
00115                 next = Successor(last);\par
00116             \}\par
00117         \}\par
00118 \par
00119         {\cf17 public} {\cf18 bool} Equals(Permutations other)\par
00120         \{\par
00121             {\cf19 return} (N == other.N && K == other.K);\par
00122         \}\par
00123     \}\par
00124 \par
00125     {\cf17 public} {\cf17 static} {\cf17 class }ChemicalUtils\par
00126     \{\par
00127         {\cf17 public} {\cf17 static} Dictionary<string, ChemicalElement> Chemicals = {\cf17 new} Dictionary<string, ChemicalElement>() \{\par
00128             \{{\cf22 "H"}, {\cf17 new} ChemicalElement({\cf22 "H"}, {\cf22 "Hydrogen"}, 1.007825035, 1.00794)\},\par
00129             \{{\cf22 "C"}, {\cf17 new} ChemicalElement({\cf22 "C"}, {\cf22 "Carbon"}, 12.0, 12.0107)\},\par
00130             \{{\cf22 "N"}, {\cf17 new} ChemicalElement({\cf22 "N"}, {\cf22 "Nitrogen"}, 14.003074, 14.0067)\},\par
00131             \{{\cf22 "O"}, {\cf17 new} ChemicalElement({\cf22 "O"}, {\cf22 "Oxygen"}, 15.99491463, 15.9994)\},\par
00132             \{{\cf22 "p"}, {\cf17 new} ChemicalElement({\cf22 "p"}, {\cf22 "Proton"}, 1.007276466812, 1.007276466812)\},\par
00133             \{{\cf22 "i"}, {\cf17 new} ChemicalElement({\cf22 "i"}, {\cf22 "C13IsotopeDiff"}, 1.00335, 1.00335)\}\par
00134         \};\par
00135 \par
00136         {\cf17 public} {\cf17 static} Dictionary<char, AminoAcid> AminoAcids = {\cf17 new} Dictionary<char, AminoAcid>() \{\par
00137             \{{\cf23 'A'}, {\cf17 new} AminoAcid({\cf23 'A'}, {\cf22 "Ala"}, {\cf22 "Alanine"}, 71.037114, 71.0779)\}, {\cf20 //71.03712}\par
00138             \{{\cf23 'R'}, {\cf17 new} AminoAcid({\cf23 'R'}, {\cf22 "Arg"}, {\cf22 "Arginine"}, 156.101111, 156.1857)\}, {\cf20 //156.10112}\par
00139             \{{\cf23 'N'}, {\cf17 new} AminoAcid({\cf23 'N'}, {\cf22 "Asn"}, {\cf22 "Asparagine"}, 114.042927, 114.1026)\}, {\cf20 //114.04293}\par
00140             \{{\cf23 'D'}, {\cf17 new} AminoAcid({\cf23 'D'}, {\cf22 "Asp"}, {\cf22 "Aspartic acid"}, 115.026943, 115.0874)\}, {\cf20 //115.02695}\par
00141             \{{\cf23 'C'}, {\cf17 new} AminoAcid({\cf23 'C'}, {\cf22 "Cys"}, {\cf22 "Cysteine"}, 103.009185, 103.1429)\}, {\cf20 //103.00919}\par
00142             \{{\cf23 'E'}, {\cf17 new} AminoAcid({\cf23 'E'}, {\cf22 "Glu"}, {\cf22 "Glutamic acid"}, 129.042593, 129.114)\}, {\cf20 //129.0426}\par
00143             \{{\cf23 'Q'}, {\cf17 new} AminoAcid({\cf23 'Q'}, {\cf22 "Gln"}, {\cf22 "Glutamine"}, 128.058578, 128.1292)\}, {\cf20 //128.05858}\par
00144             \{{\cf23 'G'}, {\cf17 new} AminoAcid({\cf23 'G'}, {\cf22 "Gly"}, {\cf22 "Glycine"}, 57.021464, 57.0513)\}, {\cf20 //57.02147}\par
00145             \{{\cf23 'H'}, {\cf17 new} AminoAcid({\cf23 'H'}, {\cf22 "His"}, {\cf22 "Histidine"}, 137.058912, 137.1393)\}, {\cf20 //137.05891}\par
00146             \{{\cf23 'I'}, {\cf17 new} AminoAcid({\cf23 'I'}, {\cf22 "Ile"}, {\cf22 "Isoleucine"}, 113.084064, 113.1576)\}, {\cf20 //113.08407}\par
00147             \{{\cf23 'L'}, {\cf17 new} AminoAcid({\cf23 'L'}, {\cf22 "Leu"}, {\cf22 "Leucine"}, 113.084064, 113.1576)\},\par
00148             \{{\cf23 'K'}, {\cf17 new} AminoAcid({\cf23 'K'}, {\cf22 "Lys"}, {\cf22 "Lysine"}, 128.094963, 128.1723)\}, {\cf20 //128.09497}\par
00149             \{{\cf23 'M'}, {\cf17 new} AminoAcid({\cf23 'M'}, {\cf22 "Met"}, {\cf22 "Methionine"}, 131.040485, 131.1961)\}, {\cf20 //131.0405}\par
00150             \{{\cf23 'F'}, {\cf17 new} AminoAcid({\cf23 'F'}, {\cf22 "Phe"}, {\cf22 "Phenylalanine"}, 147.068414, 147.1739)\}, {\cf20 //147.06842}\par
00151             \{{\cf23 'P'}, {\cf17 new} AminoAcid({\cf23 'P'}, {\cf22 "Pro"}, {\cf22 "Proline"}, 97.052764, 97.1152)\}, {\cf20 //97.05277}\par
00152             \{{\cf23 'S'}, {\cf17 new} AminoAcid({\cf23 'S'}, {\cf22 "Ser"}, {\cf22 "Serine"}, 87.032028, 87.0773)\}, {\cf20 //87.03203}\par
00153             \{{\cf23 'T'}, {\cf17 new} AminoAcid({\cf23 'T'}, {\cf22 "Thr"}, {\cf22 "Threonine"}, 101.047679, 101.1039)\}, {\cf20 //101.04768}\par
00154             \{{\cf23 'U'}, {\cf17 new} AminoAcid({\cf23 'U'}, {\cf22 "Sec"}, {\cf22 "Selenocysteine"}, 150.95363, 150.0379)\},\par
00155             \{{\cf23 'W'}, {\cf17 new} AminoAcid({\cf23 'W'}, {\cf22 "Trp"}, {\cf22 "Tryptophane"}, 186.079313, 186.2099)\}, {\cf20 //186.07932}\par
00156             \{{\cf23 'Y'}, {\cf17 new} AminoAcid({\cf23 'Y'}, {\cf22 "Tyr"}, {\cf22 "Tyrosine"}, 163.06332, 163.1733)\}, {\cf20 //163.06332}\par
00157             \{{\cf23 'V'}, {\cf17 new} AminoAcid({\cf23 'V'}, {\cf22 "Val"}, {\cf22 "Valine"}, 99.068414, 99.1311)\}, {\cf20 //99.06842}\par
00158             \{{\cf23 'J'}, {\cf17 new} AminoAcid({\cf23 'J'}, {\cf22 "LeI"}, {\cf22 "Leu_Isoleu"}, 113.084064, 113.1576)\},\par
00159             \{{\cf23 'O'}, {\cf17 new} AminoAcid({\cf23 'O'}, {\cf22 "Pyl"}, {\cf22 "Pyrrolysin"}, 237.14772677, 237.300713363271)\},\par
00160             \{{\cf23 '$'}, {\cf17 new} AminoAcid({\cf23 '$'}, {\cf22 ""}, {\cf22 "N-Term"}, 0.0, 0.0)\},\par
00161             \{{\cf23 '^'}, {\cf17 new} AminoAcid({\cf23 '^'}, {\cf22 ""}, {\cf22 "C-Term"}, 0.0, 0.0)\}\par
00162         \};\par
00163 \par
00164 \par
00165         {\cf17 public} {\cf17 static} Dictionary<string, Permutations> Combinations = {\cf17 new} Dictionary<string, Permutations>();\par
00166 \par
00167         {\cf17 public} {\cf17 static} {\cf18 int} GetMassIndex({\cf18 double} mass)\par
00168         \{\par
00169             {\cf19 return} ({\cf18 int})(mass * 10000);\par
00170         \}\par
00171 \par
00172         {\cf17 public} {\cf17 static} {\cf18 double} GetMassDoubleKey({\cf18 double} moverz)\par
00173         \{\par
00174             {\cf19 return} Math.Round(moverz, 7);\par
00175         \}\par
00176 \par
00177         {\cf17 public} {\cf17 static} {\cf18 double} CalculatePeptideMass({\cf18 string} sequence, {\cf18 bool} mono)\par
00178         \{\par
00179             {\cf18 double} pepMass = Chemicals[{\cf22 "H"}].MonoMass * 2 + Chemicals[{\cf22 "O"}].MonoMass;\par
00180             {\cf19 if} (!mono)\par
00181                 pepMass = Chemicals[{\cf22 "H"}].AvgMass * 2 + Chemicals[{\cf22 "O"}].AvgMass;\par
00182             {\cf19 for} ({\cf18 int} i = 0; i < sequence.Length; ++i)\par
00183             \{\par
00184                 pepMass += AminoAcids[sequence[i]].Mass(mono);\par
00185             \}\par
00186             {\cf19 return} pepMass;\par
00187         \}\par
00188 \par
00189         {\cf20 //public static double CalculatePeptideMass(string sequence, bool mono)}\par
00190         {\cf20 //\{}\par
00191         {\cf20 //  return CalculatePeptideMass(sequence, 0, sequence.Length, mono);}\par
00192         {\cf20 //\}}\par
00193 \par
00194         {\cf17 public} {\cf17 static} {\cf18 double} CalculatePrecursorMassToCharge({\cf18 int} charge, {\cf18 double} mass, {\cf18 bool} mono)\par
00195         \{\par
00196             {\cf19 if} (mono)\par
00197                 {\cf19 return} (mass + charge * Chemicals[{\cf22 "p"}].MonoMass) / charge;\par
00198             {\cf19 else}\par
00199                 {\cf19 return} (mass + charge * Chemicals[{\cf22 "p"}].AvgMass) / charge;\par
00200         \}\par
00201 \par
00202         {\cf17 public} {\cf17 static} {\cf18 double} CalculateUnchargedMass({\cf18 double} mass, {\cf18 int} charge, {\cf18 bool} mono)\par
00203         \{\par
00204             {\cf19 if} (mono)\par
00205                 {\cf19 return} ((mass * charge) - (charge) * Chemicals[{\cf22 "p"}].MonoMass);\par
00206             {\cf19 else}\par
00207                 {\cf19 return} ((mass * charge) - (charge) * Chemicals[{\cf22 "p"}].AvgMass);\par
00208         \}\par
00209 \par
00210         {\cf17 public} {\cf17 static} Permutations GetAscendingPermutations({\cf18 int} n, {\cf18 int} k)\par
00211         \{\par
00212             {\cf18 string} key = n + {\cf22 "_"} + k;\par
00213             lock (Combinations)\par
00214             \{\par
00215                 {\cf19 if} (Combinations.ContainsKey(key))\par
00216                     {\cf19 return} Combinations[key];\par
00217                 {\cf19 else}\par
00218                 \{\par
00219                     Permutations m = {\cf17 new} Permutations(n, k);\par
00220                     lock (Combinations)\par
00221                     \{\par
00222                         {\cf19 if} (!Combinations.ContainsKey(key))\par
00223                         \{\par
00224                             Combinations.Add(key, m);\par
00225                         \}\par
00226                     \}\par
00227                     {\cf19 return} m;\par
00228                 \}\par
00229             \}\par
00230         \}\par
00231 \par
00232         {\cf17 public} {\cf17 static} {\cf18 double} CalculateMassDiffInPPM({\cf18 double} expMass, {\cf18 double} theoMass)\par
00233         \{\par
00234             {\cf18 double} ppm = (Math.Abs(expMass - theoMass) / theoMass) * (1000000.0);\par
00235             {\cf19 return} ppm;\par
00236         \}\par
00237     \}\par
00238 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
FASTAParser.cs\par \pard\plain 
{\tc\tcl2 \v amanda/FASTAParser.cs}
{\xe \v amanda/FASTAParser.cs}
{\bkmkstart AAAAAAAAAB}
{\bkmkend AAAAAAAAAB}
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf17 using }System.Collections.Concurrent;\par
00002 {\cf17 using }System.Text.RegularExpressions;\par
00003 {\cf17 using }System.Text;\par
00004 {\cf17 using }MessagePack;\par
00005 {\cf17 using }CandidateSearch.util;\par
00006 {\cf17 using }MSAMANDA_CHEMICALUTILS;\par
00007 \par
00008 {\cf17 namespace }MSAMANDA_FASTAPARSER\par
00009 \{\par
00010     {\cf17 public} {\cf17 class }FASTAParser\par
00011     \{\par
00012         {\cf17 public} {\cf17 static} List<Peptide> DigestFasta({\cf18 string} fastaFileName,\par
00013                                                 Settings settings,\par
00014                                                 {\cf18 bool} generateDecoys = {\cf17 false}, \par
00015                                                 {\cf18 double} coreUsage = 0.75)\par
00016         \{\par
00017             var trypsin = {\cf17 new} Enzyme();\par
00018             trypsin.Name = {\cf22 "Trypsin"};\par
00019             trypsin.CleavageSites = {\cf22 "KR"};\par
00020             trypsin.CleavageInhibitors = {\cf22 "P"};\par
00021             trypsin.Specificity = Enzyme.CLEAVAGE_SPECIFICITY.FULL;\par
00022             trypsin.Offset = 1;\par
00023 \par
00024             var proteins = ReadInFasta(fastaFileName, {\cf17 false});\par
00025 \par
00026             var peptides = DigestProteins(proteins, \par
00027                                           trypsin, \par
00028                                           settings,\par
00029                                           {\cf17 false}, \par
00030                                           coreUsage);\par
00031 \par
00032             {\cf19 if} (generateDecoys)\par
00033             \{\par
00034                 var decoyProteins = {\cf17 new} List<DBProtein>();\par
00035                 {\cf19 foreach} (var protein {\cf19 in} proteins)\par
00036                 \{\par
00037                     var decoySequence = ReverseSequence(protein.Sequence);\par
00038                     var decoyProtein = {\cf17 new} DBProtein(protein.DbProtRef.ProtIdentifier, -protein.DbProtRef.MappingId, decoySequence, {\cf17 true});\par
00039                     decoyProteins.Add(decoyProtein);\par
00040                 \}\par
00041 \par
00042                 var decoyPeptides = DigestProteins(decoyProteins,\par
00043                                                    trypsin,\par
00044                                                    settings,\par
00045                                                    {\cf17 true},\par
00046                                                    coreUsage);\par
00047 \par
00048                 peptides.AddRange(decoyPeptides);\par
00049             \}\par
00050 \par
00051             {\cf19 return} peptides;\par
00052         \}\par
00053 \par
00054         {\cf17 private} {\cf17 static} {\cf18 string} ReverseSequence({\cf18 string} seq)\par
00055         \{\par
00056             {\cf18 char}[] array = seq.ToCharArray();\par
00057             Array.Reverse(array);\par
00058             {\cf19 return} {\cf17 new} String(array);\par
00059         \}\par
00060 \par
00061         {\cf17 private} {\cf17 static} List<Peptide> DigestProteins(List<DBProtein> proteins, \par
00062                                                     Enzyme enzyme,\par
00063                                                     Settings settings,\par
00064                                                     {\cf18 bool} isDecoy,\par
00065                                                     {\cf18 double} coreUsage)\par
00066         \{\par
00067             var opts = {\cf17 new} ParallelOptions \{ MaxDegreeOfParallelism = (int) Math.Ceiling(Environment.ProcessorCount * coreUsage) \};\par
00068             var concurrentPeptideList = {\cf17 new} ConcurrentBag<List<DBPeptide>>();\par
00069             Parallel.ForEach(proteins, opts, (protein) => \{\par
00070                 var digester = {\cf17 new} ProteinDigester(enzyme, settings.MAX_CLEAVAGES, {\cf17 true}, settings.MIN_PEP_LENGTH, settings.MAX_PEP_LENGTH, protein);\par
00071                 concurrentPeptideList.Add(digester.DigestProteinIntoList());\par
00072             \});\par
00073 \par
00074             var peptideList = concurrentPeptideList.SelectMany(x => x).ToList();\par
00075             var massToPeptides = {\cf17 new} DigesterDB();\par
00076             HelperMethods.MergeToDBDictionaries(peptideList, ref massToPeptides, opts);\par
00077 \par
00078             var peptides = {\cf17 new} List<Peptide>();\par
00079             {\cf19 foreach} (var item {\cf19 in} massToPeptides.DbPeptidesDictMassKey)\par
00080             \{\par
00081                 var currentPeptides = item.Value;\par
00082                 {\cf19 foreach} (var peptide {\cf19 in} currentPeptides)\par
00083                 \{\par
00084                     var peptidoforms = GetPeptidoforms(peptide, settings, isDecoy);\par
00085                     peptides.AddRange(peptidoforms);\par
00086                 \}\par
00087             \}\par
00088 \par
00089             {\cf19 return} peptides;\par
00090         \}\par
00091 \par
00092         {\cf17 private} {\cf17 static} List<Peptide> GetPeptidoforms(DBPeptide dbPeptide, Settings settings, {\cf18 bool} isDecoy)\par
00093         \{\par
00094             var peptides = {\cf17 new} List<Peptide>();\par
00095             var mods = {\cf17 new} Dictionary<int, double>();\par
00096 \par
00097             {\cf19 if} (settings.FIXED_MODIFICATIONS.Count > 0)\par
00098             \{\par
00099                 {\cf19 for} ({\cf18 int} i = 0; i < dbPeptide.Sequence.Length; i++)\par
00100                 \{\par
00101                     {\cf19 if} (settings.FIXED_MODIFICATIONS.ContainsKey(dbPeptide.Sequence[i].ToString()))\par
00102                     \{\par
00103                         mods.Add(i, settings.FIXED_MODIFICATIONS[dbPeptide.Sequence[i].ToString()]);\par
00104                     \}\par
00105                 \}\par
00106             \}\par
00107 \par
00108             var peptide = {\cf17 new} Peptide(dbPeptide.Sequence, dbPeptide.Mass, mods, settings, isDecoy);\par
00109             peptides.Add(peptide);\par
00110 \par
00111             {\cf19 if} (settings.VARIABLE_MODIFICATIONS.Count > 0)\par
00112             \{\par
00113                 {\cf19 foreach} (var modification {\cf19 in} settings.VARIABLE_MODIFICATIONS)\par
00114                 \{\par
00115                     addPeptidoformsForModification(peptides, modification, settings);\par
00116                 \}\par
00117             \}\par
00118 \par
00119             {\cf19 return} peptides;\par
00120         \}\par
00121 \par
00122         {\cf17 private} {\cf17 static} {\cf18 void} addPeptidoformsForModification(List<Peptide> peptides,\par
00123                                                            KeyValuePair<string, double> modification,\par
00124                                                            Settings settings)\par
00125         \{\par
00126             var peptidoforms = {\cf17 new} List<Peptide>();\par
00127 \par
00128             {\cf19 foreach} (var peptide {\cf19 in} peptides)\par
00129             \{\par
00130                 var possibleModificationSites = {\cf17 new} List<int>();\par
00131                 {\cf19 for} ({\cf18 int} i = 0; i < peptide.sequence.Length; i++)\par
00132                 \{\par
00133                     {\cf19 if} (peptide.sequence[i].ToString() == modification.Key)\par
00134                     \{\par
00135                         possibleModificationSites.Add(i);\par
00136                     \}\par
00137                 \}\par
00138 \par
00139                 var possibleCombinations = getAllPossibleCombinations(possibleModificationSites);\par
00140 \par
00141                 {\cf19 foreach} (var combination {\cf19 in} possibleCombinations)\par
00142                 \{\par
00143                     var peptidoform = {\cf17 new} Peptide(peptide.sequence,\par
00144                                                   peptide.mass,\par
00145                                                   {\cf17 new} Dictionary<int, double>(),\par
00146                                                   settings,\par
00147                                                   peptide.isDecoy);\par
00148 \par
00149                     {\cf19 foreach} (var mod {\cf19 in} peptide.modifications)\par
00150                     \{\par
00151                         peptidoform.addModification(mod.Key, mod.Value);\par
00152                     \}\par
00153 \par
00154 \par
00155                     {\cf19 foreach} (var position {\cf19 in} combination)\par
00156                     \{\par
00157                         peptidoform.addModification(position, modification.Value);\par
00158                     \}\par
00159 \par
00160                     peptidoforms.Add(peptidoform);\par
00161                 \}\par
00162             \}\par
00163 \par
00164             peptides.AddRange(peptidoforms);\par
00165         \}\par
00166 \par
00167         {\cf17 private} {\cf17 static} List<List<int>> getAllPossibleCombinations(List<int> possibleModificationSites)\par
00168         \{\par
00169             var possibleCombinations = {\cf17 new} List<List<int>>();\par
00170 \par
00171             {\cf19 for} ({\cf18 int} i = 0; i < (1 << possibleModificationSites.Count); ++i)\par
00172             \{\par
00173                 var combination = {\cf17 new} List<int>();\par
00174                 {\cf19 for} ({\cf18 int} j = 0; j < possibleModificationSites.Count; ++j)\par
00175                 \{\par
00176                     {\cf19 if} ((i & (1 << j)) != 0)\par
00177                     \{\par
00178                         combination.Add(possibleModificationSites[j]);\par
00179                     \}\par
00180                 \}\par
00181                 possibleCombinations.Add(combination);\par
00182             \}\par
00183 \par
00184             {\cf19 return} possibleCombinations;\par
00185         \}\par
00186 \par
00187         {\cf17 private} {\cf17 static} List<DBProtein> ReadInFasta({\cf18 string} fastaFileName, {\cf18 bool} isDecoy)\par
00188         \{\par
00189             List<DBProtein> proteins = {\cf17 new} List<DBProtein>();\par
00190             {\cf18 string} regexPatternSequence = {\cf22 "[^ARNDCEQGHILKMFPSTUWYVXBZJO]"};\par
00191             {\cf18 int} mappingID = 0;\par
00192 \par
00193             StreamReader fastaFileReader = {\cf17 new} StreamReader(fastaFileName);\par
00194             {\cf19 try}\par
00195             \{\par
00196                 {\cf18 string} currentLine = {\cf22 ""};\par
00197                 {\cf18 string} sequence = {\cf22 ""};\par
00198                 {\cf18 string} identifier = {\cf22 ""};\par
00199 \par
00200                 {\cf19 while} ((currentLine = fastaFileReader.ReadLine()) != {\cf17 null})\par
00201                 \{\par
00202                     {\cf19 if} (currentLine.StartsWith({\cf22 ">"}, StringComparison.Ordinal))\par
00203                     \{\par
00204                         {\cf19 if} (!{\cf18 string}.IsNullOrWhiteSpace(sequence))\par
00205                         \{\par
00206                             {\cf20 //sequence = sequence.Replace('J', 'L');}\par
00207                             {\cf19 if} (Regex.IsMatch(sequence, regexPatternSequence))\par
00208                             \{\par
00209                                 var builder = {\cf17 new} StringBuilder({\cf22 "Cannot parse "});\par
00210                                 builder.Append({\cf22 "fasta file at identifier "} + identifier + {\cf22 ". Sequence error. "});\par
00211                                 Console.WriteLine(builder.ToString());\par
00212                                 sequence = String.Empty;\par
00213                                 identifier = {\cf18 string}.Empty;\par
00214                                 {\cf19 throw} {\cf17 new} Exception({\cf22 "Parsing error."});\par
00215                             \}\par
00216                             proteins.Add(GenerateDbProtein(mappingID, isDecoy, identifier, sequence));\par
00217                             sequence = {\cf22 ""};\par
00218                             mappingID++;\par
00219                         \}\par
00220 \par
00221                         {\cf18 int} index = currentLine.IndexOfAny({\cf17 new}[] \{ {\cf23 ' '}, {\cf23 '|'} \}, 0);\par
00222 \par
00223                         {\cf19 if} (index == -1)\par
00224                         \{\par
00225                             identifier = currentLine.Substring(1);\par
00226                         \}\par
00227                         {\cf19 else}\par
00228                         \{\par
00229                             identifier = currentLine.Substring(1, index - 1);\par
00230                             {\cf18 int} indexNumber = identifier.IndexOfAny({\cf17 new}[]\par
00231                                 \{{\cf23 '0'}, {\cf23 '1'}, {\cf23 '2'}, {\cf23 '3'}, {\cf23 '4'}, {\cf23 '5'}, {\cf23 '6'}, {\cf23 '7'}, {\cf23 '8'}, {\cf23 '9'}\});\par
00232                             {\cf19 while} (indexNumber == -1)\par
00233                             \{\par
00234                                 index = currentLine.IndexOfAny({\cf17 new}[] \{ {\cf23 ' '}, {\cf23 '|'} \}, index + 1);\par
00235                                 {\cf19 if} (index == -1)\par
00236                                 \{\par
00237                                     identifier = currentLine.Substring(1);\par
00238                                     {\cf19 break};\par
00239                                 \}\par
00240 \par
00241                                 identifier = currentLine.Substring(1, index - 1);\par
00242                                 indexNumber = identifier.IndexOfAny({\cf17 new}[]\par
00243                                     \{{\cf23 '0'}, {\cf23 '1'}, {\cf23 '2'}, {\cf23 '3'}, {\cf23 '4'}, {\cf23 '5'}, {\cf23 '6'}, {\cf23 '7'}, {\cf23 '8'}, {\cf23 '9'}\});\par
00244                             \}\par
00245                         \}\par
00246                     \}\par
00247                     {\cf19 else}\par
00248                     \{\par
00249                         sequence += currentLine.ToUpper();\par
00250                     \}\par
00251                 \}\par
00252 \par
00253                 {\cf19 if} (!{\cf18 string}.IsNullOrWhiteSpace(sequence))\par
00254                 \{\par
00255                     {\cf19 if} (Regex.IsMatch(sequence, regexPatternSequence))\par
00256                     \{\par
00257                         var builder = {\cf17 new} StringBuilder({\cf22 "Cannot parse "});\par
00258                         builder.Append({\cf22 "fasta file at identifier "} + identifier + {\cf22 ". Sequence error. "});\par
00259                         Console.WriteLine(builder.ToString());\par
00260                         {\cf19 throw} {\cf17 new} Exception({\cf22 "Parsing error."});\par
00261                     \}\par
00262                     {\cf19 else}\par
00263                     \{\par
00264                         proteins.Add(GenerateDbProtein(mappingID, isDecoy, identifier, sequence));\par
00265                         sequence = {\cf22 ""};\par
00266                         mappingID++;\par
00267                     \}\par
00268                 \}\par
00269             \}\par
00270             {\cf19 catch} (Exception e)\par
00271             \{\par
00272                 Console.WriteLine({\cf22 "Fasta file error"});\par
00273                 Console.WriteLine(e.ToString());\par
00274                 {\cf19 throw};\par
00275             \}\par
00276             {\cf19 finally}\par
00277             \{\par
00278                 fastaFileReader.Close();\par
00279             \}\par
00280 \par
00281             {\cf19 return} proteins;\par
00282         \}\par
00283 \par
00284         {\cf17 private} {\cf17 static} DBProtein GenerateDbProtein({\cf18 int} mappingID, {\cf18 bool} isDecoy, {\cf18 string} identifier, {\cf18 string} sequence)\par
00285         \{\par
00286 \par
00287             {\cf19 if} (isDecoy)\par
00288             \{\par
00289                 {\cf20 //mark proteins as decoys by negative ProteinIDs;}\par
00290                 {\cf19 return} {\cf17 new} DBProtein(identifier, -mappingID, sequence);\par
00291             \}\par
00292             {\cf19 return} {\cf17 new} DBProtein(identifier, mappingID, sequence);\par
00293         \}\par
00294     \}\par
00295 \par
00296     {\cf17 public} {\cf17 class }DBProtein\par
00297     \{\par
00298         {\cf17 public} {\cf18 string} Sequence \{ {\cf17 get}; {\cf17 set}; \}\par
00299         {\cf17 public} {\cf18 bool} IsDecoy \{ {\cf17 get}; {\cf17 set}; \}\par
00300         {\cf17 public} DBProtRef DbProtRef \{ {\cf17 get}; {\cf17 set}; \}\par
00301 \par
00302         {\cf17 public} DBProtein({\cf18 string} identifier, {\cf18 int} {\cf18 id}, {\cf18 string} sequence, {\cf18 bool} isDecoy = {\cf17 false})\par
00303         \{\par
00304             var ok = {\cf18 int}.TryParse(identifier, out {\cf18 int} identy);\par
00305             {\cf19 if} (ok)\par
00306             \{\par
00307                 DbProtRef = {\cf17 new} DBProtRef\par
00308                 \{\par
00309                     ProtId = identy,\par
00310                     MappingId = id,\par
00311                     ProtIdentifier = identifier\par
00312                 \};\par
00313             \}\par
00314             {\cf19 else}\par
00315             \{\par
00316                 DbProtRef = {\cf17 new} DBProtRef\par
00317                 \{\par
00318                     ProtId = id,\par
00319                     MappingId = id,\par
00320                     ProtIdentifier = identifier\par
00321                 \};\par
00322             \}\par
00323             Sequence = sequence;\par
00324             IsDecoy = isDecoy;\par
00325         \}\par
00326     \}\par
00327 \par
00328     [MessagePackObject]\par
00329     {\cf17 public} {\cf17 struct }DBProtRef\par
00330     \{\par
00331         [Key(0)]\par
00332         {\cf17 public} {\cf18 int} ProtId \{ {\cf17 get}; {\cf17 set}; \}\par
00333         [Key(1)]\par
00334         {\cf17 public} {\cf18 int} MappingId \{ {\cf17 get}; {\cf17 set}; \}\par
00335         [Key(2)]\par
00336         {\cf17 public} {\cf18 string} ProtIdentifier \{ {\cf17 get}; {\cf17 set}; \}\par
00337 \par
00338     \}\par
00339 \par
00340     {\cf17 public} {\cf17 class }Enzyme\par
00341     \{\par
00342         {\cf17 public} Enzyme()\par
00343         \{\par
00344             CleavageInhibitors = {\cf22 ""};\par
00345             CleavageSites = {\cf22 ""};\par
00346             Offset = 0;\par
00347             Specificity = CLEAVAGE_SPECIFICITY.FULL;\par
00348             Name = {\cf22 ""};\par
00349         \}\par
00350 \par
00351         {\cf17 public} {\cf17 enum} CLEAVAGE_SPECIFICITY \{ FULL, SEMI, SEMI_N, SEMI_C \};\par
00352 \par
00353         {\cf17 public} {\cf18 string} CleavageSites \{ {\cf17 get}; {\cf17 set}; \}\par
00354         {\cf17 public} {\cf18 string} CleavageInhibitors \{ {\cf17 get}; {\cf17 set}; \}\par
00355         {\cf17 public} CLEAVAGE_SPECIFICITY Specificity \{ {\cf17 get}; {\cf17 set}; \}\par
00356         {\cf17 public} {\cf18 int} Offset \{ {\cf17 get}; {\cf17 set}; \}\par
00357         {\cf17 public} {\cf18 string} Name \{ {\cf17 get}; {\cf17 set}; \}\par
00358 \par
00359         {\cf17 public} Regex TheRegex => regexInit.Value;\par
00360         {\cf17 private} Lazy<Regex> regexInit => {\cf17 new} Lazy<Regex>(() =>\par
00361         \{\par
00362             {\cf19 if} (Offset == 1)\par
00363             \{\par
00364                 {\cf20 //C-Terminal}\par
00365                 StringBuilder builder = {\cf17 new} StringBuilder({\cf22 "(?<=["});\par
00366                 builder.Append(CleavageSites);\par
00367                 builder.Append({\cf22 "])"});\par
00368                 {\cf19 if} (!String.IsNullOrEmpty(CleavageInhibitors))\par
00369                 \{\par
00370                     builder.Append({\cf22 "(?=[^"});\par
00371                     builder.Append(CleavageInhibitors);\par
00372                     builder.Append({\cf22 "])"});\par
00373                 \}\par
00374                 {\cf20 // "(?<=[" + Enzyme.CleavageSites + "])(?=[^" + Enzyme.CleavageInhibitors + "])"}\par
00375                 {\cf19 return} {\cf17 new} Regex(builder.ToString());\par
00376             \}\par
00377             {\cf19 else}\par
00378             \{\par
00379                 {\cf20 //N-Terminal}\par
00380                 StringBuilder builder = {\cf17 new} StringBuilder({\cf22 "(?=["});\par
00381                 builder.Append(CleavageSites);\par
00382                 builder.Append({\cf22 "]"});\par
00383                 {\cf19 if} (!String.IsNullOrEmpty(CleavageInhibitors))\par
00384                 \{\par
00385                     builder.Append({\cf22 "[^"});\par
00386                     builder.Append(CleavageInhibitors);\par
00387                     builder.Append({\cf22 "]"});\par
00388                 \}\par
00389                 builder.Append({\cf22 ")"});\par
00390                 {\cf20 // "(?=[" + Enzyme.CleavageSites + "][^" + Enzyme.CleavageInhibitors + "])"}\par
00391                 {\cf19 return} {\cf17 new} Regex(builder.ToString());\par
00392             \}\par
00393         \});\par
00394     \}\par
00395 \par
00396     [MessagePackObject]\par
00397     {\cf17 public} {\cf17 class }DBPeptide\par
00398     \{\par
00399         [Key(0)]\par
00400         {\cf17 public} {\cf18 double} Mass \{ {\cf17 get}; {\cf17 set}; \}\par
00401         [Key(1)]\par
00402         {\cf17 public} {\cf18 int} MassInt \{ {\cf17 get}; {\cf17 set}; \}\par
00403         [Key(2)]\par
00404         {\cf17 public} {\cf18 string} Sequence \{ {\cf17 get}; {\cf17 set}; \}\par
00405         [Key(3)]\par
00406         {\cf17 public} {\cf18 bool} ProteinStartFlag \{ {\cf17 get}; {\cf17 set}; \}\par
00407         [Key(4)]\par
00408         {\cf17 public} List<DBProtRef> DbProtRefs \{ {\cf17 get}; {\cf17 set}; \}\par
00409         [Key(5)]\par
00410         {\cf17 public} {\cf18 string} SequenceOriginal \{ {\cf17 get}; {\cf17 set}; \}\par
00411         [Key(6)]\par
00412         {\cf17 public} {\cf18 int} MissedCleavages \{ {\cf17 get}; {\cf17 set}; \}\par
00413         [IgnoreMember]\par
00414         {\cf17 public} {\cf18 int} SeqHash \{ {\cf17 get}; {\cf17 set}; \}\par
00415 \par
00416         {\cf17 public} DBPeptide()\par
00417         \{ \par
00418             Sequence = {\cf22 ""}; \par
00419             DbProtRefs = {\cf17 new} List<DBProtRef>(); \par
00420             SequenceOriginal = {\cf22 ""};\par
00421         \}\par
00422 \par
00423         {\cf17 public} DBPeptide({\cf18 string} sequence, {\cf18 string} sequenceOriginal, {\cf18 int} missedCleavages, {\cf18 bool} proteinStartFlag, DBProtRef protRef)\par
00424         \{\par
00425             MissedCleavages = missedCleavages;\par
00426             Sequence = sequence;\par
00427             SequenceOriginal = sequenceOriginal;\par
00428             ProteinStartFlag = proteinStartFlag;\par
00429             SeqHash = CreateMD5();\par
00430 \par
00431             DbProtRefs = {\cf17 new} List<DBProtRef>(1) \{ protRef \};\par
00432         \}\par
00433 \par
00434         {\cf17 internal} {\cf18 void} AddToProtRefs(DBPeptide pep)\par
00435         \{\par
00436             {\cf19 if} (DbProtRefs != {\cf17 null} && DbProtRefs.Count > 0)\par
00437             \{\par
00438                 DbProtRefs = DbProtRefs.Concat(pep.DbProtRefs).Distinct().ToList();\par
00439             \}\par
00440             {\cf19 else}\par
00441             \{\par
00442                 DbProtRefs = pep.DbProtRefs;\par
00443             \}\par
00444         \}\par
00445 \par
00446         {\cf17 public} {\cf18 int} CreateMD5()\par
00447         \{\par
00448             {\cf19 return} (Sequence, MissedCleavages, ProteinStartFlag).GetHashCode();\par
00449         \}\par
00450     \}\par
00451 \par
00452     {\cf17 public} {\cf17 static} {\cf17 class }HelperMethods\par
00453     \{\par
00454         {\cf17 public} {\cf17 static} DBPeptide FindPeptideWithSameHash({\cf17 this} List<DBPeptide> peptides, DBPeptide pep)\par
00455         \{\par
00456             {\cf19 for} (var i = 0; i < peptides.Count; i++)\par
00457             \{\par
00458                 var x = peptides[i];\par
00459                 {\cf19 if} (x.SeqHash == pep.SeqHash)\par
00460                 \{\par
00461                     {\cf19 return} x;\par
00462                 \}\par
00463             \}\par
00464             {\cf19 return} {\cf17 null};\par
00465         \}\par
00466 \par
00467         {\cf17 public} {\cf17 static} {\cf18 bool} IsBetweenExcludeBounds({\cf17 this} {\cf18 double} target, {\cf18 double} start, {\cf18 double} end)\par
00468         \{\par
00469             {\cf19 return} target > start && target < end;\par
00470         \}\par
00471 \par
00472         {\cf17 public} {\cf17 static} {\cf18 bool} IsBetweenIncludeBounds({\cf17 this} {\cf18 int} target, {\cf18 int} start, {\cf18 int} end)\par
00473         \{\par
00474             {\cf19 return} target >= start && target <= end;\par
00475         \}\par
00476 \par
00477         {\cf17 public} {\cf17 static} {\cf18 void} MergeToDBDictionaries(List<DBPeptide> dbFrom, ref DigesterDB dbTo, ParallelOptions parallelOptions)\par
00478         \{\par
00479             dbTo.DbPeptidesDictMassKey = dbFrom.GroupBy(x => x.MassInt)\par
00480                                                .AsParallel()\par
00481                                                .WithDegreeOfParallelism(parallelOptions.MaxDegreeOfParallelism)\par
00482                                                .Select(g => \{\par
00483                 var theList = {\cf17 new} List<DBPeptide>();\par
00484                 {\cf19 foreach} (var pep {\cf19 in} g)\par
00485                 \{\par
00486                     var itemWithSameHash = theList.FindPeptideEqualTo(pep);\par
00487                     {\cf20 //var itemWithSameHash = theList.Find(x => DBPeptideEquals(x, pep));}\par
00488                     {\cf19 if} (itemWithSameHash != {\cf17 null})\par
00489                     \{\par
00490                         itemWithSameHash.AddToProtRefs(pep);\par
00491                     \}\par
00492                     {\cf19 else}\par
00493                     \{\par
00494                         theList.Add(pep);\par
00495                     \}\par
00496                 \}\par
00497                 {\cf19 return} (g.Key, theList);\par
00498             \}).ToDictionary(t => t.Key, t => t.theList);\par
00499         \}\par
00500 \par
00501         {\cf17 private} {\cf17 static} DBPeptide FindPeptideEqualTo({\cf17 this} List<DBPeptide> list, DBPeptide comparePep)\par
00502         \{\par
00503             {\cf19 for} (var i = 0; i < list.Count; i++)\par
00504             \{\par
00505                 var x = list[i];\par
00506                 {\cf19 if} (DBPeptideEquals(comparePep, x))\par
00507                 \{\par
00508                     {\cf19 return} x;\par
00509                 \}\par
00510             \}\par
00511             {\cf19 return} {\cf17 null};\par
00512         \}\par
00513 \par
00514         {\cf17 private} {\cf17 static} {\cf18 bool} DBPeptideEquals(DBPeptide x, DBPeptide pep)\par
00515         \{\par
00516             {\cf19 if} (x.SeqHash != pep.SeqHash)\par
00517             \{\par
00518                 {\cf19 return} {\cf17 false};\par
00519             \}\par
00520             {\cf19 if} (x.ProteinStartFlag != pep.ProteinStartFlag)\par
00521             \{\par
00522                 {\cf19 return} {\cf17 false};\par
00523             \}\par
00524             {\cf19 if} (x.MissedCleavages != pep.MissedCleavages)\par
00525             \{\par
00526                 {\cf19 return} {\cf17 false};\par
00527             \}\par
00528             {\cf19 if} (x.Sequence != pep.Sequence)\par
00529             \{\par
00530                 {\cf19 return} {\cf17 false};\par
00531             \}\par
00532             {\cf19 return} {\cf17 true};\par
00533         \}\par
00534     \}\par
00535 \par
00536     {\cf17 public} {\cf17 class }ProteinDigester\par
00537     \{\par
00538         {\cf17 private} readonly Enzyme _enzyme;\par
00539         {\cf17 private} readonly {\cf18 int} _missedCleavages;\par
00540         {\cf17 private} readonly {\cf18 bool} _useMonoisotopicMass;\par
00541         {\cf17 private} readonly {\cf18 int} _minPepLength;\par
00542         {\cf17 private} readonly {\cf18 int} _maxPepLength;\par
00543         {\cf17 private} readonly DBProtein _dbProtein;\par
00544 \par
00545         {\cf17 private} List<DBPeptide> _dbPeptides;\par
00546 \par
00547         {\cf17 struct }PeptideInfo\par
00548         \{\par
00549             {\cf17 public} {\cf18 int} Start;\par
00550             {\cf17 public} {\cf18 int} MissedCleavages;\par
00551         \};\par
00552 \par
00553         {\cf17 public} ProteinDigester(Enzyme enzyme, {\cf18 int} missedCleavages, {\cf18 bool} useMonoisotopicMass, {\cf18 int} minPepLength, {\cf18 int} maxPepLength, DBProtein dbProtein)\par
00554         \{\par
00555             _enzyme = enzyme;\par
00556             _missedCleavages = missedCleavages;\par
00557             _useMonoisotopicMass = useMonoisotopicMass;\par
00558             _minPepLength = minPepLength;\par
00559             _maxPepLength = maxPepLength;\par
00560             _dbProtein = dbProtein;\par
00561             _dbPeptides = {\cf17 new} List<DBPeptide>();\par
00562         \}\par
00563 \par
00564         {\cf17 public} List<DBPeptide> DigestProteinIntoList()\par
00565         \{\par
00566             _dbPeptides = {\cf17 new} List<DBPeptide>();\par
00567             DigestSingleProtein(_dbProtein);\par
00568             {\cf19 return} _dbPeptides;\par
00569         \}\par
00570 \par
00571         {\cf17 private} {\cf18 void} DigestSingleProtein(DBProtein protein)\par
00572         \{\par
00573 \par
00574             {\cf19 if} (_enzyme.CleavageSites == {\cf22 "X"})\par
00575             \{\par
00576                 {\cf20 //no-enzyme search}\par
00577                 DigestSingleProteinWithNoEnzyme(protein);\par
00578             \}\par
00579             {\cf19 else} {\cf19 if} (_enzyme.CleavageSites == {\cf22 ""})\par
00580             \{\par
00581                 {\cf20 //no cleavage (peptide db or top down)}\par
00582                 SaveSinglePeptide({\cf17 new} DBPeptide(protein.Sequence, protein.Sequence, 0, IsProteinStart(0, protein.Sequence[0]), protein.DbProtRef));\par
00583             \}\par
00584             {\cf19 else}\par
00585             \{\par
00586                 var peptides = SplitProtein(_enzyme, protein, _missedCleavages, 0);\par
00587                 {\cf19 foreach} (var pep {\cf19 in} peptides)\par
00588                 \{\par
00589                     SaveSinglePeptide(pep);\par
00590                 \}\par
00591 \par
00592                 {\cf19 if} (protein.Sequence.StartsWith({\cf22 "M"}, StringComparison.Ordinal) && _enzyme.CleavageSites != {\cf22 "X"} && _enzyme.CleavageSites != {\cf22 ""})\par
00593                 \{\par
00594                     var prot = {\cf17 new} DBProtein(protein.DbProtRef.ProtIdentifier, protein.DbProtRef.MappingId, protein.Sequence.Substring(1));\par
00595                     var otherPeptides = SplitProtein(_enzyme, prot, _missedCleavages, 1);\par
00596 \par
00597                     {\cf19 foreach} (var pep {\cf19 in} otherPeptides)\par
00598                     \{\par
00599                         var peptideWithSameHash = peptides.FindPeptideWithSameHash(pep);\par
00600                         {\cf19 if} (peptideWithSameHash == {\cf17 null})\par
00601                         \{\par
00602                             SaveSinglePeptide(pep);\par
00603                             {\cf19 continue};\par
00604                         \}\par
00605                         {\cf19 if} (peptideWithSameHash.MissedCleavages == pep.MissedCleavages) {\cf19 continue};\par
00606 \par
00607                         SaveSinglePeptide(pep);\par
00608                     \}\par
00609                 \}\par
00610             \}\par
00611         \}\par
00612 \par
00613         {\cf17 private} {\cf18 void} DigestSingleProteinWithNoEnzyme(DBProtein protein)\par
00614         \{\par
00615             SortedSet<int> positionsOfX = {\cf17 new} SortedSet<int>();\par
00616             SortedSet<int> positionsOfZ = {\cf17 new} SortedSet<int>();\par
00617             SortedSet<int> positionsOfB = {\cf17 new} SortedSet<int>();\par
00618             MatchCollection collX = Regex.Matches(protein.Sequence, {\cf22 "X"});\par
00619             MatchCollection collZ = Regex.Matches(protein.Sequence, {\cf22 "Z"});\par
00620             MatchCollection collB = Regex.Matches(protein.Sequence, {\cf22 "B"});\par
00621 \par
00622             {\cf19 for} ({\cf18 int} m = 0; m < collX.Count; ++m)\par
00623             \{\par
00624                 positionsOfX.Add(collX[m].Index);\par
00625             \}\par
00626 \par
00627             {\cf19 for} ({\cf18 int} m = 0; m < collZ.Count; ++m)\par
00628             \{\par
00629                 positionsOfZ.Add(collZ[m].Index);\par
00630             \}\par
00631 \par
00632             {\cf19 for} ({\cf18 int} m = 0; m < collB.Count; ++m)\par
00633             \{\par
00634                 positionsOfB.Add(collB[m].Index);\par
00635             \}\par
00636 \par
00637             {\cf19 for} ({\cf18 int} s = 0; s < protein.Sequence.Length; ++s)\par
00638             \{\par
00639                 {\cf19 for} ({\cf18 int} l = 1; l < protein.Sequence.Length - s + 1; ++l)\par
00640                 \{\par
00641                     var seqL = l - s;\par
00642                     {\cf19 if} (seqL < _minPepLength)\par
00643                         {\cf19 continue};\par
00644                     {\cf19 if} (seqL > _maxPepLength)\par
00645                         {\cf19 break};\par
00646                     {\cf19 if} (l > 150)\par
00647                         {\cf19 break};\par
00648                     SortedSet<int> xInSeq = positionsOfX.GetViewBetween(s, s + l);\par
00649                     {\cf19 if} (xInSeq.Count > 1)\par
00650                         {\cf19 break};\par
00651                     SortedSet<int> bInSeq = positionsOfB.GetViewBetween(s, s + l);\par
00652                     {\cf19 if} (bInSeq.Count > 3)\par
00653                         {\cf19 break};\par
00654                     SortedSet<int> zInSeq = positionsOfZ.GetViewBetween(s, s + l);\par
00655                     {\cf19 if} (zInSeq.Count > 3 || zInSeq.Count + bInSeq.Count > 3)\par
00656                         {\cf19 break};\par
00657                     {\cf19 if} (xInSeq.Count > 0 || bInSeq.Count > 0 || zInSeq.Count > 0)\par
00658                     \{\par
00659                         {\cf20 //handle replacement characters}\par
00660                         SaveSinglePeptide({\cf17 new} DBPeptide(protein.Sequence.Substring(s, l), protein.Sequence.Substring(s, l), 0,\par
00661                           IsProteinStart(s, protein.Sequence[0]), protein.DbProtRef));\par
00662                     \}\par
00663                     {\cf19 else}\par
00664                     \{\par
00665                         {\cf20 //save pep}\par
00666                         {\cf18 string} sseq = protein.Sequence.Substring(s, l);\par
00667                         {\cf18 double} mass = ChemicalUtils.CalculatePeptideMass(sseq, _useMonoisotopicMass);\par
00668 \par
00669                         {\cf19 if} (mass.IsBetweenExcludeBounds(200, 6000))\par
00670                         {\cf20 //if (!(mass > 200) || !(mass < 6000))}\par
00671                         {\cf20 //\{}\par
00672                         {\cf20 //  if (mass > 6000)}\par
00673                         {\cf20 //    break;}\par
00674                         {\cf20 //\}}\par
00675                         {\cf20 //else}\par
00676                         \{\par
00677                             SavePeptide({\cf17 new} DBPeptide(sseq, sseq, 0, IsProteinStart(s, protein.Sequence[0]), protein.DbProtRef));\par
00678                         \}\par
00679                     \}\par
00680                 \}\par
00681             \}\par
00682         \}\par
00683 \par
00684         {\cf17 private} {\cf18 void} SaveSinglePeptide(DBPeptide pep)\par
00685         \{\par
00686             {\cf19 if} (String.IsNullOrEmpty(pep.Sequence))\par
00687                 {\cf19 return};\par
00688             {\cf19 if} (pep.Sequence.Length < _minPepLength || pep.Sequence.Length > _maxPepLength)\par
00689                 {\cf19 return};\par
00690 \par
00691             {\cf19 if} (pep.Sequence.Contains({\cf23 'B'}) || pep.Sequence.Contains({\cf23 'Z'}) || pep.Sequence.Contains({\cf23 'X'}))\par
00692             \{\par
00693                 {\cf18 string} temp = pep.Sequence.Replace({\cf22 "X"}, {\cf22 ""});\par
00694                 {\cf19 if} (pep.Sequence.Length - temp.Length > 1)\par
00695                 \{\par
00696                     {\cf19 return};\par
00697                 \}\par
00698 \par
00699                 temp = pep.Sequence.Replace({\cf22 "B"}, {\cf22 ""});\par
00700                 temp = temp.Replace({\cf22 "Z"}, {\cf22 ""});\par
00701                 {\cf19 if} (pep.Sequence.Length - temp.Length > 3)\par
00702                 \{\par
00703                     {\cf19 return};\par
00704                 \}\par
00705 \par
00706                 List<char> replacements = {\cf17 new} List<char>();\par
00707                 {\cf19 for} ({\cf18 int} i = 0; i < pep.Sequence.Length; ++i)\par
00708                 \{\par
00709                     replacements.Add({\cf23 '#'});\par
00710                 \}\par
00711 \par
00712                 {\cf19 if} (pep.Sequence.Contains({\cf23 'X'}))\par
00713                 \{\par
00714                     GenerateCombinationsForX(pep, replacements);\par
00715                 \}\par
00716                 {\cf19 else}\par
00717                 \{\par
00718                     CalculateMass(pep, replacements);\par
00719                 \}\par
00720             \}\par
00721             {\cf19 else}\par
00722             \{\par
00723                 pep.Mass = ChemicalUtils.CalculatePeptideMass(pep.Sequence, _useMonoisotopicMass);\par
00724                 SavePeptide(pep);\par
00725             \}\par
00726         \}\par
00727 \par
00728         {\cf17 private} {\cf17 static} List<DBPeptide> SplitProtein(Enzyme enzyme, DBProtein prot, {\cf18 int} missedCleavages, {\cf18 int} offset)\par
00729         \{\par
00730             {\cf18 string}[] peptides = enzyme.TheRegex.Split(prot.Sequence);\par
00731             List<DBPeptide> peps = {\cf17 new} List<DBPeptide>(offset == 0 ? peptides.Length * 3 : 3); {\cf20 // guessing magic numbers}\par
00732             {\cf18 int} start = offset;\par
00733 \par
00734             Dictionary<string, PeptideInfo> allPeps = {\cf17 new} Dictionary<string, PeptideInfo>();\par
00735             {\cf19 for} ({\cf18 int} i = 0; i < peptides.Length; ++i)\par
00736             \{\par
00737                 {\cf19 if} (offset > 0 && i > 0)\par
00738                     {\cf19 break};\par
00739                 {\cf19 if} (!String.IsNullOrEmpty(peptides[i]))\par
00740                 \{\par
00741                     {\cf18 string} myPeptide = peptides[i];\par
00742                     {\cf19 if} (!allPeps.ContainsKey(myPeptide))\par
00743                     \{\par
00744                         {\cf20 //peps.Add(new DBPeptide(myPeptide, myPeptide, 0, IsProteinStart(0, myPeptide[0]), prot.DbProtRef));}\par
00745                         peps.Add({\cf17 new} DBPeptide(myPeptide, myPeptide, 0, IsProteinStart(myPeptide, prot.Sequence), prot.DbProtRef));\par
00746                         allPeps.Add(peptides[i], {\cf17 new} PeptideInfo\par
00747                         \{\par
00748                             Start = start,\par
00749                             MissedCleavages = 0\par
00750                         \});\par
00751                     \}\par
00752 \par
00753                     {\cf18 int} j = 1;\par
00754                     {\cf18 string} pep = peptides[i];\par
00755 \par
00756                     {\cf18 int} count = 0;\par
00757                     {\cf19 while} (count < missedCleavages)\par
00758                     \{\par
00759                         {\cf19 if} (i + j < peptides.Length)\par
00760                         \{\par
00761                             {\cf19 if} (!String.IsNullOrEmpty(peptides[i + j]))\par
00762                             \{\par
00763                                 pep += peptides[i + j];\par
00764                                 {\cf19 if} (!allPeps.ContainsKey(pep))\par
00765                                 \{\par
00766                                     {\cf20 //peps.Add(new DBPeptide(pep, pep, count + 1, IsProteinStart(0, pep[0]), prot.DbProtRef));}\par
00767                                     peps.Add({\cf17 new} DBPeptide(pep, pep, count + 1, IsProteinStart(pep, prot.Sequence), prot.DbProtRef));\par
00768                                     allPeps.Add(pep, {\cf17 new} PeptideInfo\par
00769                                     \{\par
00770                                         Start = start,\par
00771                                         MissedCleavages = count + 1\par
00772                                     \});\par
00773                                 \}\par
00774 \par
00775                                 ++count;\par
00776                             \}\par
00777 \par
00778                             ++j;\par
00779                         \}\par
00780                         {\cf19 else}\par
00781                         \{\par
00782                             {\cf19 break};\par
00783                         \}\par
00784                     \}\par
00785 \par
00786                     start += peptides[i].Length;\par
00787                 \}\par
00788             \}\par
00789 \par
00790             {\cf19 if} (enzyme.CleavageSites != {\cf22 "X"} && (enzyme.Specificity == Enzyme.CLEAVAGE_SPECIFICITY.SEMI ||\par
00791                                                 enzyme.Specificity == Enzyme.CLEAVAGE_SPECIFICITY.SEMI_C ||\par
00792                                                 enzyme.Specificity == Enzyme.CLEAVAGE_SPECIFICITY.SEMI_N))\par
00793             \{\par
00794                 {\cf19 foreach} ({\cf18 string} peptide {\cf19 in} allPeps.Keys.ToArray())\par
00795                 \{\par
00796                     PeptideInfo info = allPeps[peptide];\par
00797                     {\cf19 for} ({\cf18 int} i = 1; i < peptide.Length - 1; ++i)\par
00798                     \{\par
00799                         {\cf18 string} newFront = peptide.Substring(i);\par
00800                         {\cf18 string} newBack = peptide.Substring(0, peptide.Length - i);\par
00801                         {\cf19 if} (!allPeps.ContainsKey(newFront) && (enzyme.Specificity == Enzyme.CLEAVAGE_SPECIFICITY.SEMI ||\par
00802                                                                enzyme.Specificity == Enzyme.CLEAVAGE_SPECIFICITY.SEMI_C))\par
00803                         \{\par
00804                             {\cf20 //peps.Add(new DBPeptide(newFront, newFront, info.MissedCleavages, IsProteinStart(0, newFront[0]), prot.DbProtRef));}\par
00805                             peps.Add({\cf17 new} DBPeptide(newFront, newFront, info.MissedCleavages, IsProteinStart(newFront, prot.Sequence), prot.DbProtRef));\par
00806 \par
00807                             allPeps.Add(newFront, {\cf17 new} PeptideInfo\par
00808                             \{\par
00809                                 Start = info.Start + i,\par
00810                                 MissedCleavages = info.MissedCleavages\par
00811                             \});\par
00812                         \}\par
00813 \par
00814                         {\cf19 if} (allPeps.ContainsKey(newBack) || (enzyme.Specificity != Enzyme.CLEAVAGE_SPECIFICITY.SEMI &&\par
00815                                                              enzyme.Specificity != Enzyme.CLEAVAGE_SPECIFICITY.SEMI_N)) {\cf19 continue};\par
00816 \par
00817                         {\cf20 //peps.Add(new DBPeptide(newBack, newBack, info.MissedCleavages, IsProteinStart(0, newBack[0]), prot.DbProtRef));}\par
00818                         peps.Add({\cf17 new} DBPeptide(newBack, newBack, info.MissedCleavages, IsProteinStart(newBack, prot.Sequence), prot.DbProtRef));\par
00819                         allPeps.Add(newBack, {\cf17 new} PeptideInfo\par
00820                         \{\par
00821                             Start = info.Start,\par
00822                             MissedCleavages = info.MissedCleavages\par
00823                         \});\par
00824                     \}\par
00825                 \}\par
00826             \}\par
00827 \par
00828             {\cf19 return} peps;\par
00829         \}\par
00830 \par
00831         {\cf17 private} {\cf18 void} SavePeptide(DBPeptide pep)\par
00832         \{\par
00833             {\cf19 if} (pep.Sequence.Length < 2)\par
00834                 {\cf19 return};\par
00835             {\cf19 if} (!pep.Sequence.Length.IsBetweenIncludeBounds(_minPepLength, _maxPepLength))\par
00836                 {\cf19 return};\par
00837 \par
00838             pep.Mass = ChemicalUtils.CalculatePeptideMass(pep.Sequence, _useMonoisotopicMass);\par
00839             pep.MassInt = (int)(pep.Mass);\par
00840             pep.SeqHash = pep.CreateMD5();\par
00841             _dbPeptides.Add(pep);\par
00842         \}\par
00843 \par
00844         {\cf17 private} DBPeptide CreatePeptide({\cf18 string} sequence, {\cf18 string} origSequence, {\cf18 int} missedCleavages, {\cf18 bool} proteinStartFlag, DBProtRef protRef)\par
00845         \{\par
00846             var pep = {\cf17 new} DBPeptide(sequence, origSequence, missedCleavages, proteinStartFlag, protRef);\par
00847             {\cf19 if} (pep.Sequence.Length < 2)\par
00848                 {\cf19 return} {\cf17 null};\par
00849             {\cf19 if} (pep.Sequence.Length < _minPepLength || pep.Sequence.Length > _maxPepLength)\par
00850                 {\cf19 return} {\cf17 null};\par
00851             pep.Mass = ChemicalUtils.CalculatePeptideMass(pep.Sequence, _useMonoisotopicMass);\par
00852             pep.MassInt = (int)(pep.Mass);\par
00853             pep.SeqHash = pep.CreateMD5();\par
00854             {\cf19 return} pep;\par
00855         \}\par
00856 \par
00857         {\cf17 private} {\cf17 static} {\cf18 bool} IsProteinStart({\cf18 int} startPosition, {\cf18 char} protStarter)\par
00858         \{\par
00859             {\cf19 return} (startPosition == 0 || (startPosition == 1 && protStarter == {\cf23 'M'}));\par
00860         \}\par
00861 \par
00862         {\cf17 private} {\cf17 static} {\cf18 bool} IsProteinStart({\cf18 string} pep, {\cf18 string} prot)\par
00863         \{\par
00864             {\cf19 return} IsProteinStart(prot.IndexOf(pep), prot[0]);\par
00865         \}\par
00866 \par
00867         {\cf17 private} {\cf18 void} CalculateMass(DBPeptide info,\par
00868           List<char> replacements)\par
00869         \{\par
00870             {\cf19 if} (info.Sequence.Contains({\cf23 'B'}))\par
00871             \{\par
00872                 {\cf18 int} firstIndex = info.Sequence.IndexOf({\cf23 'B'});\par
00873                 {\cf18 string} changedPeptide = info.Sequence;\par
00874                 {\cf18 char}[] temp = {\cf17 new} {\cf18 char}[replacements.Count];\par
00875                 replacements.CopyTo(temp);\par
00876                 List<char> currentReplacements = {\cf17 new} List<char>(temp)\par
00877                 \{\par
00878                     [firstIndex] = {\cf23 'N'}\par
00879                 \};\par
00880                 changedPeptide = changedPeptide.Insert(firstIndex, {\cf22 "N"});\par
00881                 changedPeptide = changedPeptide.Remove(firstIndex + 1, 1);\par
00882                 info.Sequence = changedPeptide;\par
00883                 CalculateMass(info, currentReplacements);\par
00884                 changedPeptide = changedPeptide.Insert(firstIndex, {\cf22 "D"});\par
00885                 changedPeptide = changedPeptide.Remove(firstIndex + 1, 1);\par
00886                 currentReplacements[firstIndex] = {\cf23 'D'};\par
00887                 info.Sequence = changedPeptide;\par
00888                 CalculateMass(info, currentReplacements);\par
00889             \}\par
00890             {\cf19 else} {\cf19 if} (info.Sequence.Contains({\cf23 'Z'}))\par
00891             \{\par
00892                 {\cf18 int} firstIndex = info.Sequence.IndexOf({\cf23 'Z'});\par
00893                 {\cf18 string} changedPeptide = info.Sequence;\par
00894                 {\cf18 char}[] temp = {\cf17 new} {\cf18 char}[replacements.Count];\par
00895                 replacements.CopyTo(temp);\par
00896                 List<char> currentReplacements = {\cf17 new} List<char>(temp)\par
00897                 \{\par
00898                     [firstIndex] = {\cf23 'E'}\par
00899                 \};\par
00900                 changedPeptide = changedPeptide.Insert(firstIndex, {\cf22 "E"});\par
00901                 changedPeptide = changedPeptide.Remove(firstIndex + 1, 1);\par
00902                 info.Sequence = changedPeptide;\par
00903                 CalculateMass(info, currentReplacements);\par
00904                 changedPeptide = changedPeptide.Insert(firstIndex, {\cf22 "Q"});\par
00905                 changedPeptide = changedPeptide.Remove(firstIndex + 1, 1);\par
00906                 currentReplacements[firstIndex] = {\cf23 'Q'};\par
00907                 info.Sequence = changedPeptide;\par
00908                 CalculateMass(info, currentReplacements);\par
00909             \}\par
00910             {\cf19 else}\par
00911             \{\par
00912                 SavePeptide(info);\par
00913                 {\cf20 //FinalCalculation(info);}\par
00914             \}\par
00915         \}\par
00916 \par
00917         {\cf17 private} {\cf18 void} FinalCalculation(DBPeptide info)\par
00918         \{\par
00919             {\cf18 double} mass = ChemicalUtils.CalculatePeptideMass(info.Sequence, _useMonoisotopicMass);\par
00920             SavePeptide(info);\par
00921         \}\par
00922 \par
00923         {\cf17 private} {\cf18 void} GenerateCombinationsForX(DBPeptide info,\par
00924           List<char> replacements)\par
00925         \{\par
00926             {\cf19 foreach} ({\cf18 char} aa {\cf19 in} ChemicalUtils.AminoAcids.Keys)\par
00927             \{\par
00928                 {\cf19 if} (aa != {\cf23 '^'} && aa != {\cf23 '$'} && aa != {\cf23 'J'})\par
00929                 \{\par
00930                     {\cf18 int} firstIndex = info.Sequence.IndexOf({\cf23 'X'});\par
00931                     {\cf18 string} changedPeptide = info.Sequence;\par
00932                     changedPeptide = changedPeptide.Insert(firstIndex, aa.ToString());\par
00933                     changedPeptide = changedPeptide.Remove(firstIndex + 1, 1);\par
00934                     {\cf20 //char[] temp = new char[replacements.Count];}\par
00935                     {\cf20 //replacements.CopyTo(temp);}\par
00936 \par
00937                     List<char> currentReplacement = {\cf17 new} List<char>(replacements.ToArray())\par
00938                     \{\par
00939                         [firstIndex] = aa\par
00940                     \};\par
00941                     {\cf20 //string currentReplacement = variableAAs + aa.ToString();}\par
00942 \par
00943                     {\cf19 if} (changedPeptide.Contains({\cf23 'X'}))\par
00944                     \{\par
00945                         {\cf20 //should not occur}\par
00946                     \}\par
00947                     {\cf19 else}\par
00948                     \{\par
00949                         var newPep = {\cf17 new} DBPeptide\par
00950                         \{\par
00951                             MissedCleavages = info.MissedCleavages,\par
00952                             Sequence = changedPeptide,\par
00953                             SequenceOriginal = info.SequenceOriginal,\par
00954                             ProteinStartFlag = info.ProteinStartFlag,\par
00955                             DbProtRefs = info.DbProtRefs\par
00956                         \};\par
00957                         CalculateMass(newPep, currentReplacement);\par
00958                     \}\par
00959                 \}\par
00960             \}\par
00961         \}\par
00962     \}\par
00963 \par
00964     [MessagePackObject]\par
00965     {\cf17 public} {\cf17 class }DigesterDB\par
00966     \{\par
00967         [Key(0)]\par
00968         {\cf17 public} Dictionary<int, List<DBPeptide>> DbPeptidesDictMassKey \{ {\cf17 get}; {\cf17 set}; \}\par
00969 \par
00970         {\cf17 public} DigesterDB()\par
00971         \{\par
00972             DbPeptidesDictMassKey = {\cf17 new} Dictionary<int, List<DBPeptide>>();\par
00973         \}\par
00974     \}\par
00975 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
IonCalculator.cs\par \pard\plain 
{\tc\tcl2 \v amanda/IonCalculator.cs}
{\xe \v amanda/IonCalculator.cs}
{\bkmkstart AAAAAAAAAC}
{\bkmkend AAAAAAAAAC}
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf17 using }System.Text;\par
00002 {\cf17 using }MSAMANDA_CHEMICALUTILS;\par
00003 \par
00004 {\cf17 namespace }MSAMANDA_IONCALCULATION\par
00005 \{\par
00006     {\cf17 public} {\cf17 static} {\cf17 class }IonCalculator\par
00007     \{\par
00008         {\cf17 static} {\cf18 double} massH_MonoMass = ChemicalUtils.Chemicals[{\cf22 "H"}].MonoMass;\par
00009         {\cf17 static} {\cf18 double} massProton_MonoMass = ChemicalUtils.Chemicals[{\cf22 "p"}].MonoMass;\par
00010         {\cf17 static} {\cf18 double} massO_MonoMass = ChemicalUtils.Chemicals[{\cf22 "O"}].MonoMass;\par
00011         {\cf17 static} {\cf18 double} massC_MonoMass = ChemicalUtils.Chemicals[{\cf22 "C"}].MonoMass;\par
00012         {\cf17 static} {\cf18 double} massN_MonoMass = ChemicalUtils.Chemicals[{\cf22 "N"}].MonoMass;\par
00013 \par
00014         {\cf17 static} {\cf18 double} massH_AvgMass = ChemicalUtils.Chemicals[{\cf22 "H"}].AvgMass;\par
00015         {\cf17 static} {\cf18 double} massProton_AvgMass = ChemicalUtils.Chemicals[{\cf22 "p"}].AvgMass;\par
00016         {\cf17 static} {\cf18 double} massO_AvgMass = ChemicalUtils.Chemicals[{\cf22 "O"}].AvgMass;\par
00017         {\cf17 static} {\cf18 double} massC_AvgMass = ChemicalUtils.Chemicals[{\cf22 "C"}].AvgMass;\par
00018         {\cf17 static} {\cf18 double} massN_AvgMass = ChemicalUtils.Chemicals[{\cf22 "N"}].AvgMass;\par
00019 \par
00020         {\cf17 public} {\cf17 static} {\cf18 bool} CalculateIons(out {\cf18 double}[] outIonsNoNL, \par
00021                                          out IonWithNL[] outIonsWithNL,\par
00022                                          {\cf18 byte}[] sequence,\par
00023                                          {\cf18 double} mass,\par
00024                                          {\cf18 int} charge, \par
00025                                          Modification[] mods, \par
00026                                          {\cf18 int} maxNumberNeutralLoss, \par
00027                                          {\cf18 int} maxNumberNeutralLossModifications,\par
00028                                          {\cf18 double} lowerBound,\par
00029                                          {\cf18 double} upperBound, \par
00030                                          {\cf18 bool} mono, \par
00031                                          {\cf18 string} maxAllowedChargeState)\par
00032         \{\par
00033             var setting = {\cf17 new} InstrumentSetting() \{ UseBIon = {\cf17 true}, UseYIon = {\cf17 true} \};\par
00034 \par
00035             var AminoAcids = {\cf17 new} AminoAcid[{\cf18 byte}.MaxValue];\par
00036             {\cf19 foreach} (AminoAcid aa {\cf19 in} ChemicalUtils.AminoAcids.Values)\par
00037             \{\par
00038                 AminoAcids[(byte) aa.OneLetterCode] = aa;\par
00039             \}\par
00040 \par
00041             var MaxNrWaterLosses = 0;\par
00042             var MaxNrAmmoniaLosses = 0;\par
00043 \par
00044             outIonsNoNL = {\cf17 null};\par
00045             outIonsWithNL = {\cf17 null};\par
00046 \par
00047             {\cf18 int} numIonsExpected = sequence.Length;\par
00048             \{\par
00049                 {\cf18 int} numExpectedFactor = 0;\par
00050                 {\cf19 if} (setting.UseAIon) ++numExpectedFactor;\par
00051                 {\cf19 if} (setting.UseBIon) ++numExpectedFactor;\par
00052                 {\cf19 if} (setting.UseCIon) ++numExpectedFactor;\par
00053                 {\cf19 if} (setting.UseXIon) ++numExpectedFactor;\par
00054                 {\cf19 if} (setting.UseYIon) ++numExpectedFactor;\par
00055                 {\cf19 if} (setting.UseZIon) ++numExpectedFactor;\par
00056                 {\cf19 if} (setting.UseZPlusHIon) ++numExpectedFactor;\par
00057                 {\cf19 if} (setting.UseZPlusTwoHIon) ++numExpectedFactor;\par
00058                 {\cf20 // new ions}\par
00059                 {\cf19 if} (setting.UseAPlusHIon) ++numExpectedFactor;\par
00060                 {\cf19 if} (setting.UseBPlusHIon) ++numExpectedFactor;\par
00061                 {\cf19 if} (setting.UseCPlusHIon) ++numExpectedFactor;\par
00062                 {\cf19 if} (setting.UseXPlusHIon) ++numExpectedFactor;\par
00063                 {\cf19 if} (setting.UseYPlusHIon) ++numExpectedFactor;\par
00064                 {\cf19 if} (setting.UseAMinusHIon) ++numExpectedFactor;\par
00065                 {\cf19 if} (setting.UseBMinusHIon) ++numExpectedFactor;\par
00066                 {\cf19 if} (setting.UseCMinusHIon) ++numExpectedFactor;\par
00067                 {\cf19 if} (setting.UseXMinusHIon) ++numExpectedFactor;\par
00068                 {\cf19 if} (setting.UseYMinusHIon) ++numExpectedFactor;\par
00069                 {\cf19 if} (setting.UseZMinusHIon) ++numExpectedFactor;\par
00070                 {\cf19 if} (numExpectedFactor < 2)\par
00071                     numExpectedFactor = 2;\par
00072 \par
00073                 numIonsExpected *= numExpectedFactor;\par
00074             \}\par
00075 \par
00076             List<double> ionsNoNL = {\cf17 new} List<double>(numIonsExpected);   {\cf20 // ions without neutral Losses}\par
00077             List<IonWithNL> ionsWithNL = (setting.UseWaterLosses || setting.UseAmmoniaLosses) ? {\cf17 new} List<IonWithNL>(numIonsExpected) : {\cf17 null};   {\cf20 // ions without neutral Losses}\par
00078 \par
00079             {\cf18 double} massH = massH_MonoMass;\par
00080             {\cf18 double} massProton = massProton_MonoMass;\par
00081             {\cf18 double} massO = massO_MonoMass;\par
00082             {\cf18 double} massC = massC_MonoMass;\par
00083             {\cf18 double} massN = massN_MonoMass;\par
00084             {\cf19 if} (!mono)\par
00085             \{\par
00086                 massH = massH_AvgMass;\par
00087                 massProton = massProton_AvgMass;\par
00088                 massO = massO_AvgMass;\par
00089                 massC = massC_AvgMass;\par
00090                 massN = massN_AvgMass;\par
00091             \}\par
00092 \par
00093             {\cf19 try}\par
00094             \{\par
00095                 {\cf20 //fwd: n-terminal ions}\par
00096                 {\cf20 //rev: c-terminal ions}\par
00097                 {\cf18 int} possibleAmoniaLosses = 0;\par
00098                 {\cf18 int} possibleWaterLosses = 0;\par
00099                 {\cf18 int} possibleAmoniaLossesRev = 0;\par
00100                 {\cf18 int} possibleWaterLossesRev = 0;\par
00101                 {\cf20 //N-Term}\par
00102                 {\cf18 double} lastMassFwd = massH + massProton;\par
00103                 {\cf18 double} lastMassInternalFwd = mass - massH - massO - massH + massProton;\par
00104                 {\cf18 double} lastMassInternalRev = mass - massH - massO - massH + massProton;\par
00105 \par
00106                 {\cf20 //N-Terminal modification}\par
00107                 {\cf19 if} (mods[0] != {\cf17 null})\par
00108                 \{\par
00109                     lastMassFwd += mods[0].Mass(mono);\par
00110                 \}\par
00111                 {\cf20 //C-Term}\par
00112                 {\cf18 double} lastMassRev = massH + massO + massProton;\par
00113                 {\cf20 //C-Terminal modification}\par
00114                 {\cf19 if} (mods[mods.Length - 1] != {\cf17 null})\par
00115                 \{\par
00116                     lastMassRev += mods[mods.Length - 1].Mass(mono);\par
00117                 \}\par
00118                 {\cf20 //possible neutral losses of specific modifications }\par
00119                 List<double> fwdLosses = {\cf17 new} List<double>();\par
00120                 List<double> revLosses = {\cf17 new} List<double>();\par
00121 \par
00122 \par
00123 {\cf21                 #region ion calculation}\par
00124                 {\cf18 int} j = sequence.Length - 1;\par
00125                 {\cf19 for} ({\cf18 int} i = 0; i < sequence.Length - 1; ++i, --j)\par
00126                 \{\par
00127                     {\cf18 byte} aaFwd = sequence[i];\par
00128                     {\cf19 if} ({\cf17 null} == AminoAcids[aaFwd])\par
00129                         {\cf19 return} {\cf17 false};\par
00130                     {\cf18 byte} aaRev = sequence[j];\par
00131                     {\cf19 if} ({\cf17 null} == AminoAcids[aaRev])\par
00132                         {\cf19 return} {\cf17 false};\par
00133                     AminoAcid currentAAFwd = AminoAcids[aaFwd];\par
00134                     lastMassFwd += currentAAFwd.Mass(mono);\par
00135 \par
00136                     {\cf20 //AA is modified}\par
00137                     {\cf19 if} (mods[i + 1] != {\cf17 null})\par
00138                         lastMassFwd += mods[i + 1].Mass(mono);\par
00139 \par
00140                     {\cf20 //Modification can have neutral loss}\par
00141                     {\cf19 if} (mods[i + 1] != {\cf17 null} && mods[i + 1].NeutralLosses.Length > 0)\par
00142                     \{\par
00143                         {\cf20 //HashSet<double> currentFwd = new HashSet<double>();}\par
00144                         {\cf20 //add new neutral losses to existing losses}\par
00145                         {\cf20 //neutral losses of modifications are either fixed or not; }\par
00146                         {\cf20 //if not fixed, the unimod file contains two entries for neutral losses:}\par
00147                         {\cf20 //1. the neutral loss mass; 2. the mass 0.0, to declare neutral loss is not fixed}\par
00148                         {\cf20 //foreach (double lossMass in fwdLosses)}\par
00149                         {\cf19 for} ({\cf18 int} m = 0; m < mods[i + 1].NeutralLosses.Length; ++m)\par
00150                         \{\par
00151                             {\cf18 double} newLoss = mods[i + 1].NeutralLosses[m];\par
00152                             {\cf18 int} count = 0;\par
00153                             {\cf19 while} (newLoss > 0 && fwdLosses.Contains(newLoss) && count < maxNumberNeutralLossModifications)\par
00154                             \{\par
00155                                 newLoss += newLoss;\par
00156                                 ++count;\par
00157                             \}\par
00158                             {\cf19 if} (count < maxNumberNeutralLossModifications)\par
00159                             \{\par
00160                                 {\cf19 if} (!fwdLosses.Contains(newLoss))\par
00161                                     fwdLosses.Add(newLoss);\par
00162                             \}\par
00163                         \}\par
00164                         fwdLosses.Sort();\par
00165                     \}\par
00166                     {\cf20 //same for reverse ions}\par
00167                     AminoAcid currentAARev = AminoAcids[aaRev];\par
00168                     lastMassRev += currentAARev.Mass(mono);\par
00169 \par
00170                     {\cf19 if} (mods[j + 1] != {\cf17 null})\par
00171                     \{\par
00172                         lastMassRev += mods[j + 1].Mass(mono);\par
00173                     \}\par
00174                     {\cf19 if} (mods[j + 1] != {\cf17 null} && mods[j + 1].NeutralLosses.Length > 0)\par
00175                     \{\par
00176                         {\cf19 for} ({\cf18 int} m = 0; m < mods[j + 1].NeutralLosses.Length; ++m)\par
00177                         \{\par
00178                             {\cf18 double} newLoss = mods[j + 1].NeutralLosses[m];\par
00179                             {\cf18 int} count = 0;\par
00180                             {\cf19 while} (newLoss > 0 && revLosses.Contains(newLoss) && count < maxNumberNeutralLossModifications)\par
00181                             \{\par
00182                                 newLoss += newLoss;\par
00183                                 ++count;\par
00184                             \}\par
00185                             {\cf19 if} (count < maxNumberNeutralLossModifications)\par
00186                             \{\par
00187                                 {\cf19 if} (!revLosses.Contains(newLoss))\par
00188                                     revLosses.Add(newLoss);\par
00189                             \}\par
00190                         \}\par
00191                         revLosses.Sort();\par
00192                     \}\par
00193 \par
00194                     {\cf20 //if ion contains AA S,T,E or D water loss is possible}\par
00195                     {\cf19 if} ((aaFwd == {\cf23 'S'} || aaFwd == {\cf23 'T'} || aaFwd == {\cf23 'E'} || aaFwd == {\cf23 'D'}))\par
00196                     \{\par
00197                         {\cf19 if} (possibleWaterLosses < maxNumberNeutralLoss)\par
00198                         \{\par
00199                             ++possibleWaterLosses;\par
00200                         \}\par
00201                         ++MaxNrWaterLosses;\par
00202                     \}\par
00203                     {\cf20 //if ion contains AA N,Q,R or K ammonia loss is possible}\par
00204                     {\cf19 if} ((aaFwd == {\cf23 'N'} || aaFwd == {\cf23 'Q'} || aaFwd == {\cf23 'R'} || aaFwd == {\cf23 'K'}))\par
00205                     \{\par
00206                         {\cf19 if} (possibleAmoniaLosses < maxNumberNeutralLoss)\par
00207                         \{\par
00208                             ++possibleAmoniaLosses;\par
00209                         \}\par
00210                         ++MaxNrAmmoniaLosses;\par
00211                     \}\par
00212                     {\cf19 if} (setting.UseImmoniumIons)\par
00213                     \{\par
00214                         {\cf20 //calculate immonium ion}\par
00215                         {\cf18 double} massImmo = (double)(currentAAFwd.ImmoniumMass);\par
00216                         {\cf20 //if AA is modified, add modification}\par
00217                         {\cf19 if} (mods[i + 1] != {\cf17 null})\par
00218                         \{\par
00219                             massImmo += mods[i + 1].Mass(mono);\par
00220                         \}\par
00221                         {\cf19 if} (InRange(massImmo, lowerBound, upperBound))\par
00222                         \{\par
00223                             ionsNoNL.Add(massImmo);\par
00224                         \}\par
00225                         {\cf20 //also immonium ion for last AA}\par
00226                         {\cf19 if} (j == sequence.Length - 1)\par
00227                         \{\par
00228                             {\cf18 double} massImmoRev = currentAARev.ImmoniumMass;\par
00229                             {\cf19 if} (mods[j + 1] != {\cf17 null})\par
00230                             \{\par
00231                                 massImmoRev += mods[j + 1].Mass(mono);\par
00232                             \}\par
00233                             {\cf19 if} (InRange(massImmoRev, lowerBound, upperBound))\par
00234                             \{\par
00235                                 ionsNoNL.Add(massImmoRev);\par
00236                             \}\par
00237                         \}\par
00238                     \}\par
00239                     {\cf19 if} ((aaRev == {\cf23 'S'} || aaRev == {\cf23 'T'} || aaRev == {\cf23 'E'} || aaRev == {\cf23 'D'}) && possibleWaterLossesRev < maxNumberNeutralLoss)\par
00240                     \{\par
00241                         ++possibleWaterLossesRev;\par
00242                     \}\par
00243                     {\cf19 if} ((aaRev == {\cf23 'N'} || aaRev == {\cf23 'Q'} || aaRev == {\cf23 'R'} || aaRev == {\cf23 'K'}) && possibleAmoniaLossesRev < maxNumberNeutralLoss)\par
00244                         ++possibleAmoniaLossesRev;\par
00245 \par
00246                     {\cf19 if} (setting.UseInternalFragments)\par
00247                     \{\par
00248                         {\cf19 if} (i == 0)\par
00249                         \{\par
00250                             lastMassInternalFwd -= lastMassFwd - lastMassRev;\par
00251                             {\cf19 if} (mods[i + 1] != {\cf17 null})\par
00252                             \{\par
00253                                 lastMassInternalFwd -= mods[i + 1].Mass(mono);\par
00254                             \}\par
00255                             {\cf19 if} (mods[j + 1] != {\cf17 null})\par
00256                             \{\par
00257                                 lastMassInternalFwd -= mods[j + 1].Mass(mono);\par
00258                             \}\par
00259                             {\cf19 if} (InRange(lastMassInternalFwd, lowerBound, upperBound))\par
00260                             \{\par
00261                                 ionsNoNL.Add(lastMassInternalFwd);\par
00262                             \}\par
00263                             CalculateAllInternalCombinations(lastMassInternalFwd, i, ionsNoNL, sequence, mods, lowerBound, upperBound, mono, AminoAcids);\par
00264                         \}\par
00265                         {\cf19 else} {\cf19 if} (i > 0 && i < sequence.Length - 1)\par
00266                         \{\par
00267                             lastMassInternalFwd -= currentAAFwd.Mass(mono);\par
00268                             {\cf19 if} (mods[i + 1] != {\cf17 null})\par
00269                             \{\par
00270                                 lastMassInternalFwd -= mods[i + 1].Mass(mono);\par
00271                             \}\par
00272                             {\cf19 if} (InRange(lastMassInternalFwd, lowerBound, upperBound))\par
00273                             \{\par
00274                                 ionsNoNL.Add(lastMassInternalFwd);\par
00275                             \}\par
00276                             CalculateAllInternalCombinations(lastMassInternalFwd, i, ionsNoNL, sequence, mods, lowerBound, upperBound, mono, AminoAcids);\par
00277                         \}\par
00278                     \}\par
00279 \par
00280                     {\cf19 if} (setting.UseAIon)\par
00281                     \{\par
00282                         {\cf20 //a ion         }\par
00283                         {\cf18 double} aIon = lastMassFwd - massC - massH - massO;\par
00284                         CalculateIon(charge, ionsNoNL, ionsWithNL, possibleAmoniaLosses, possibleWaterLosses, massO, massH, massC,\par
00285                          massN, massProton, fwdLosses, setting, aIon, lowerBound, upperBound, maxAllowedChargeState);\par
00286                     \}\par
00287 \par
00288                     {\cf19 if} (setting.UseBIon)\par
00289                     \{\par
00290                         {\cf20 //b ion}\par
00291                         {\cf19 if} (i > 0)\par
00292                         \{\par
00293                             {\cf18 double} bIon = lastMassFwd - massH;\par
00294                             CalculateIon(charge, ionsNoNL, ionsWithNL, possibleAmoniaLosses, possibleWaterLosses, massO, massH, massC,\par
00295                              massN, massProton, fwdLosses, setting, bIon, lowerBound, upperBound, maxAllowedChargeState);\par
00296                         \}\par
00297                     \}\par
00298 \par
00299                     {\cf19 if} (setting.UseCIon)\par
00300                     \{\par
00301                         {\cf20 //c}\par
00302                         {\cf18 double} cIon = lastMassFwd + massN + massH * 2;\par
00303                         CalculateIon(charge, ionsNoNL, ionsWithNL, possibleAmoniaLosses, possibleWaterLosses, massO, massH, massC,\par
00304                          massN, massProton, fwdLosses, setting, cIon, lowerBound, upperBound, maxAllowedChargeState);\par
00305                     \}\par
00306 \par
00307                     {\cf19 if} (setting.UseXIon)\par
00308                     \{\par
00309                         {\cf20 //x}\par
00310                         {\cf18 double} xIon = lastMassRev + massC + massO - massH;\par
00311                         CalculateIon(charge, ionsNoNL, ionsWithNL, possibleAmoniaLossesRev, possibleWaterLossesRev, massO, massH, massC,\par
00312                           massN, massProton, revLosses, setting, xIon, lowerBound, upperBound, maxAllowedChargeState);\par
00313                     \}\par
00314 \par
00315                     {\cf19 if} (setting.UseYIon)\par
00316                     \{\par
00317                         {\cf20 //y}\par
00318                         {\cf18 double} yIon = lastMassRev + massH;\par
00319                         CalculateIon(charge, ionsNoNL, ionsWithNL, possibleAmoniaLossesRev, possibleWaterLossesRev, massO, massH, massC,\par
00320                           massN, massProton, revLosses, setting, yIon, lowerBound, upperBound, maxAllowedChargeState);\par
00321                     \}\par
00322 \par
00323                     {\cf19 if} (setting.UseZIon)\par
00324                     \{\par
00325                         {\cf20 //z}\par
00326                         {\cf18 double} zIon = lastMassRev - massN - massH * 2;\par
00327                         CalculateIon(charge, ionsNoNL, ionsWithNL, possibleAmoniaLossesRev, possibleWaterLossesRev, massO, massH, massC,\par
00328                           massN, massProton, revLosses, setting, zIon, lowerBound, upperBound, maxAllowedChargeState);\par
00329                     \}\par
00330                     {\cf19 if} (setting.UseZPlusHIon)\par
00331                     \{\par
00332                         {\cf20 //z + 1}\par
00333                         {\cf18 double} zPlusHIon = lastMassRev - massN - massH;\par
00334                         CalculateIon(charge, ionsNoNL, ionsWithNL, possibleAmoniaLossesRev, possibleWaterLossesRev, massO, massH, massC,\par
00335                           massN, massProton, revLosses, setting, zPlusHIon, lowerBound, upperBound, maxAllowedChargeState);\par
00336                     \}\par
00337                     {\cf19 if} (setting.UseZPlusTwoHIon)\par
00338                     \{\par
00339                         {\cf20 //z + 2}\par
00340                         {\cf18 double} zPlusTwoHIon = lastMassRev - massN;\par
00341                         CalculateIon(charge, ionsNoNL, ionsWithNL, possibleAmoniaLossesRev, possibleWaterLossesRev, massO, massH, massC,\par
00342                           massN, massProton, revLosses, setting, zPlusTwoHIon, lowerBound, upperBound, maxAllowedChargeState);\par
00343                     \}\par
00344                     {\cf20 // new ions}\par
00345                     {\cf19 if} (setting.UseAPlusHIon)\par
00346                     \{\par
00347                         {\cf20 //a + 1}\par
00348                         {\cf18 double} aIon = lastMassFwd - massC - massO;\par
00349                         CalculateIon(charge, ionsNoNL, ionsWithNL, possibleAmoniaLosses, possibleWaterLosses, massO,\par
00350                             massH, massC,\par
00351                             massN, massProton, fwdLosses, setting, aIon, lowerBound, upperBound, maxAllowedChargeState);\par
00352                     \}\par
00353                     {\cf19 if} (setting.UseAMinusHIon)\par
00354                     \{\par
00355                         {\cf20 //a - 1}\par
00356                         {\cf18 double} aIon = lastMassFwd - massC - massO - 2 * massH;\par
00357                         CalculateIon(charge, ionsNoNL, ionsWithNL, possibleAmoniaLosses, possibleWaterLosses, massO,\par
00358                             massH, massC,\par
00359                             massN, massProton, fwdLosses, setting, aIon, lowerBound, upperBound, maxAllowedChargeState);\par
00360                     \}\par
00361                     {\cf19 if} (setting.UseBPlusHIon)\par
00362                     \{\par
00363                         {\cf20 //b + 1}\par
00364                         {\cf19 if} (i > 0)\par
00365                         \{\par
00366                             {\cf18 double} bIon = lastMassFwd;\par
00367                             CalculateIon(charge, ionsNoNL, ionsWithNL, possibleAmoniaLosses, possibleWaterLosses, massO,\par
00368                                 massH, massC,\par
00369                                 massN, massProton, fwdLosses, setting, bIon, lowerBound, upperBound, maxAllowedChargeState);\par
00370                         \}\par
00371                     \}\par
00372                     {\cf19 if} (setting.UseBMinusHIon)\par
00373                     \{\par
00374                         {\cf20 //b - 1}\par
00375                         {\cf19 if} (i > 0)\par
00376                         \{\par
00377                             {\cf18 double} bIon = lastMassFwd - 2 * massH;\par
00378                             CalculateIon(charge, ionsNoNL, ionsWithNL, possibleAmoniaLosses, possibleWaterLosses, massO,\par
00379                                 massH, massC,\par
00380                                 massN, massProton, fwdLosses, setting, bIon, lowerBound, upperBound, maxAllowedChargeState);\par
00381                         \}\par
00382                     \}\par
00383                     {\cf19 if} (setting.UseCPlusHIon)\par
00384                     \{\par
00385                         {\cf20 //c +1}\par
00386                         {\cf18 double} cIon = lastMassFwd + massN + 3 * massH;\par
00387                         CalculateIon(charge, ionsNoNL, ionsWithNL, possibleAmoniaLosses, possibleWaterLosses, massO,\par
00388                             massH, massC,\par
00389                             massN, massProton, fwdLosses, setting, cIon, lowerBound, upperBound, maxAllowedChargeState);\par
00390                     \}\par
00391                     {\cf19 if} (setting.UseCMinusHIon)\par
00392                     \{\par
00393                         {\cf20 //c -1}\par
00394                         {\cf18 double} cIon = lastMassFwd + massN + massH;\par
00395                         CalculateIon(charge, ionsNoNL, ionsWithNL, possibleAmoniaLosses, possibleWaterLosses, massO,\par
00396                             massH, massC,\par
00397                             massN, massProton, fwdLosses, setting, cIon, lowerBound, upperBound, maxAllowedChargeState);\par
00398                     \}\par
00399                     {\cf19 if} (setting.UseXPlusHIon)\par
00400                     \{\par
00401                         {\cf20 //x +1}\par
00402                         {\cf18 double} xIon = lastMassRev + massC + massO;\par
00403                         CalculateIon(charge, ionsNoNL, ionsWithNL, possibleAmoniaLossesRev, possibleWaterLossesRev,\par
00404                             massO, massH, massC,\par
00405                             massN, massProton, revLosses, setting, xIon, lowerBound, upperBound, maxAllowedChargeState);\par
00406                     \}\par
00407                     {\cf19 if} (setting.UseXMinusHIon)\par
00408                     \{\par
00409                         {\cf20 //x -1}\par
00410                         {\cf18 double} xIon = lastMassRev + massC + massO - 2 * massH;\par
00411                         CalculateIon(charge, ionsNoNL, ionsWithNL, possibleAmoniaLossesRev, possibleWaterLossesRev,\par
00412                             massO, massH, massC,\par
00413                             massN, massProton, revLosses, setting, xIon, lowerBound, upperBound, maxAllowedChargeState);\par
00414                     \}\par
00415 \par
00416                     {\cf19 if} (setting.UseYPlusHIon)\par
00417                     \{\par
00418                         {\cf20 //y +1 }\par
00419                         {\cf18 double} yIon = lastMassRev + 2 * massH;\par
00420                         CalculateIon(charge, ionsNoNL, ionsWithNL, possibleAmoniaLossesRev, possibleWaterLossesRev,\par
00421                             massO, massH, massC,\par
00422                             massN, massProton, revLosses, setting, yIon, lowerBound, upperBound, maxAllowedChargeState);\par
00423                     \}\par
00424                     {\cf19 if} (setting.UseYMinusHIon)\par
00425                     \{\par
00426                         {\cf20 //y - 1 }\par
00427                         {\cf18 double} yIon = lastMassRev;\par
00428                         CalculateIon(charge, ionsNoNL, ionsWithNL, possibleAmoniaLossesRev, possibleWaterLossesRev,\par
00429                             massO, massH, massC,\par
00430                             massN, massProton, revLosses, setting, yIon, lowerBound, upperBound, maxAllowedChargeState);\par
00431                     \}\par
00432 \par
00433                     {\cf19 if} (setting.UseZMinusHIon)\par
00434                     \{\par
00435                         {\cf20 //z - 1}\par
00436                         {\cf18 double} zIon = lastMassRev - massN - massH * 3;\par
00437                         CalculateIon(charge, ionsNoNL, ionsWithNL, possibleAmoniaLossesRev, possibleWaterLossesRev,\par
00438                             massO, massH, massC,\par
00439                             massN, massProton, revLosses, setting, zIon, lowerBound, upperBound, maxAllowedChargeState);\par
00440                     \}\par
00441 \par
00442                 \}\par
00443 \par
00444 {\cf21                 #endregion}\par
00445                 {\cf18 char} lastAA = (char)sequence[sequence.Length - 1];\par
00446                 {\cf19 if} ((lastAA == {\cf23 'S'} || lastAA == {\cf23 'T'} || lastAA == {\cf23 'E'} || lastAA == {\cf23 'D'}))\par
00447                 \{\par
00448                     ++MaxNrWaterLosses;\par
00449                 \}\par
00450                 {\cf19 if} ((lastAA == {\cf23 'N'} || lastAA == {\cf23 'Q'} || lastAA == {\cf23 'R'} || lastAA == {\cf23 'K'}))\par
00451                     ++MaxNrAmmoniaLosses;\par
00452 \par
00453                 {\cf19 return} GetUniqueIonsSorted(out outIonsNoNL, out outIonsWithNL, ionsNoNL, ionsWithNL);\par
00454 \par
00455             \}\par
00456             {\cf19 catch} (Exception e)\par
00457             \{\par
00458                 {\cf19 throw} {\cf17 new} Exception({\cf22 "Error in calculating ions for peptide "} + Encoding.ASCII.GetString(sequence));\par
00459             \}\par
00460 \par
00461             {\cf19 return} {\cf17 false};\par
00462         \}\par
00463 \par
00464         {\cf17 static} {\cf18 bool} InRange({\cf18 double} v, {\cf18 double} min, {\cf18 double} max)\par
00465         \{\par
00466             {\cf19 return} ((v >= min) && (v <= max));\par
00467         \}\par
00468 \par
00469         {\cf17 static} {\cf18 bool} GetUniqueIonsSorted(out {\cf18 double}[] outIonsNoNL, out IonWithNL[] outIonsWithNL, List<double> ionsNoNL, List<IonWithNL> ionsWithNL)\par
00470         \{\par
00471             outIonsNoNL = {\cf17 null};\par
00472             outIonsWithNL = {\cf17 null};\par
00473 \par
00474             {\cf19 if} (ionsNoNL.Count > 0)\par
00475             \{\par
00476                 {\cf18 double}[] aIonsNoNL = {\cf17 new} {\cf18 double}[ionsNoNL.Count];\par
00477                 {\cf19 for} ({\cf18 int} i = 0; i < aIonsNoNL.Length; ++i)\par
00478                 \{\par
00479                     aIonsNoNL[i] = IonMassStabilizer.Stabilize(ionsNoNL[i]);\par
00480                 \}\par
00481                 Array.Sort(aIonsNoNL);\par
00482                 {\cf20 //Removing duplicates from array}\par
00483                 {\cf18 int} k1 = 0, k2 = 1;\par
00484                 {\cf19 for} (; k2 < aIonsNoNL.Length; ++k2)\par
00485                 \{\par
00486                     {\cf19 if} (aIonsNoNL[k1] < aIonsNoNL[k2])\par
00487                     \{\par
00488                         ++k1;\par
00489                     \}\par
00490                     {\cf19 else}\par
00491                     \{\par
00492                         ++k2;\par
00493                         {\cf19 break};\par
00494                     \}\par
00495                 \}\par
00496 \par
00497                 {\cf19 for} (; k2 < aIonsNoNL.Length; ++k2)\par
00498                 \{\par
00499                     {\cf19 if} (aIonsNoNL[k1] < aIonsNoNL[k2])\par
00500                     \{\par
00501                         ++k1;\par
00502                         aIonsNoNL[k1] = aIonsNoNL[k2];\par
00503                     \}\par
00504                 \}\par
00505 \par
00506                 Array.Resize(ref aIonsNoNL, ++k1);\par
00507                 outIonsNoNL = aIonsNoNL;\par
00508             \}\par
00509 \par
00510             {\cf19 if} ({\cf17 null} != ionsWithNL && ionsWithNL.Count > 0)\par
00511             \{\par
00512                 IonWithNL[] aIonsWithNL = ionsWithNL.ToArray();\par
00513                 FastSort(aIonsWithNL);\par
00514                 \{\par
00515                     {\cf20 //Merging duplicates from array}\par
00516                     {\cf18 int} k1 = 0, k2 = 1;\par
00517                     {\cf19 for} (; k2 < aIonsWithNL.Length; ++k2)\par
00518                     \{\par
00519                         {\cf19 if} (aIonsWithNL[k1].Mz < aIonsWithNL[k2].Mz)\par
00520                         \{\par
00521                             ++k1;\par
00522                         \}\par
00523                         {\cf19 else}\par
00524                         \{\par
00525                             aIonsWithNL[k1].AddRange(aIonsWithNL[k2]);\par
00526                             ++k2;\par
00527                             {\cf19 break};\par
00528                         \}\par
00529                     \}\par
00530 \par
00531                     {\cf19 for} (; k2 < aIonsWithNL.Length; ++k2)\par
00532                     \{\par
00533                         {\cf19 if} (aIonsWithNL[k1].Mz < aIonsWithNL[k2].Mz)\par
00534                         \{\par
00535                             ++k1;\par
00536                             aIonsWithNL[k1] = aIonsWithNL[k2];\par
00537                         \}\par
00538                         {\cf19 else}\par
00539                         \{\par
00540                             aIonsWithNL[k1].AddRange(aIonsWithNL[k2]);\par
00541                         \}\par
00542                     \}\par
00543 \par
00544                     Array.Resize(ref aIonsWithNL, ++k1);\par
00545                     outIonsWithNL = aIonsWithNL;\par
00546                 \}\par
00547             \}\par
00548 \par
00549             {\cf19 if} ({\cf17 null} != outIonsNoNL || {\cf17 null} != outIonsWithNL)\par
00550             \{\par
00551                 {\cf19 if} ({\cf17 null} == outIonsNoNL)\par
00552                 \{\par
00553                     outIonsNoNL = Array.Empty<{\cf18 double}>();\par
00554                 \}\par
00555                 {\cf19 return} {\cf17 true};\par
00556             \}\par
00557             {\cf19 return} {\cf17 false};\par
00558         \}\par
00559 \par
00560         {\cf17 private} {\cf17 static} {\cf18 void} doQuicksort(IonWithNL[] elements, {\cf18 int} left, {\cf18 int} right)\par
00561         \{\par
00562             {\cf18 int} i = left, j = right;\par
00563             {\cf20 //middle pivot; Should avoid n^2 worst case for nearly sorted array}\par
00564             IonWithNL pivot = elements[left + (right - left) / 2];\par
00565 \par
00566             {\cf19 while} (i <= j)\par
00567             \{\par
00568                 {\cf19 while} (elements[i].Mz < pivot.Mz)\par
00569                 \{\par
00570                     i++;\par
00571                 \}\par
00572 \par
00573                 {\cf19 while} (elements[j].Mz > pivot.Mz)\par
00574                 \{\par
00575                     j--;\par
00576                 \}\par
00577 \par
00578                 {\cf19 if} (i <= j)\par
00579                 \{\par
00580                     {\cf20 // Swap}\par
00581                     {\cf20 //IonWithNL tmp = elements[i];}\par
00582                     {\cf20 //elements[i] = elements[j];}\par
00583                     {\cf20 //elements[j] = tmp;}\par
00584 \par
00585                     (elements[i], elements[j]) = (elements[j], elements[i]);\par
00586 \par
00587                     i++;\par
00588                     j--;\par
00589                 \}\par
00590             \}\par
00591 \par
00592             {\cf20 // Recursive calls}\par
00593             {\cf19 if} (left < j)\par
00594             \{\par
00595                 doQuicksort(elements, left, j);\par
00596             \}\par
00597 \par
00598             {\cf19 if} (i < right)\par
00599             \{\par
00600                 doQuicksort(elements, i, right);\par
00601             \}\par
00602         \}\par
00603 \par
00604         {\cf17 public} {\cf17 static} {\cf18 void} FastSort(IonWithNL[] ions)\par
00605         \{\par
00606             {\cf19 if} (ions.Length > 1)\par
00607             \{\par
00608                 doQuicksort(ions, 0, ions.Length - 1);\par
00609             \}\par
00610         \}\par
00611 \par
00612         {\cf17 public} {\cf17 static} {\cf18 void} CalculateAllInternalCombinations({\cf18 double} lastMassInternal, \par
00613                                                             {\cf18 int} i,\par
00614                                                             List<double> ionsNoNL,\par
00615                                                             {\cf18 byte}[] seq, \par
00616                                                             Modification[] mods,\par
00617                                                             {\cf18 double} lowerBound, \par
00618                                                             {\cf18 double} upperBound, \par
00619                                                             {\cf18 bool} mono,\par
00620                                                             AminoAcid[] aminoAcids)\par
00621         \{\par
00622             {\cf18 double} currentMass = lastMassInternal;\par
00623             {\cf19 for} ({\cf18 int} k = seq.Length - 2; k > i + 2; --k)\par
00624             \{\par
00625                 currentMass -= aminoAcids[(char) seq[k]].Mass(mono);\par
00626 \par
00627                 {\cf19 if} (mods[k + 1] != {\cf17 null})\par
00628                 \{\par
00629                     currentMass -= mods[k + 1].Mass(mono);\par
00630                 \}\par
00631                 {\cf19 if} (InRange(currentMass, lowerBound, upperBound))\par
00632                 \{\par
00633                     ionsNoNL.Add(currentMass);\par
00634                 \}\par
00635             \}\par
00636         \}\par
00637 \par
00638         {\cf17 public} {\cf17 static} {\cf18 void} CalculateIon({\cf18 int} charge, List<double> ionsNoNL, List<IonWithNL> ionsWithNL, {\cf18 int} possibleAmoniaLosses,\par
00639                                         {\cf18 int} possibleWaterLosses, {\cf18 double} massO, {\cf18 double} massH, {\cf18 double} massC, {\cf18 double} massN, {\cf18 double} massProton,\par
00640                                         List<double> losses, InstrumentSetting setting, {\cf18 double} ion,\par
00641                                         {\cf18 double} lowerBound, {\cf18 double} upperBound, {\cf18 string} maxAllowedChargeState)\par
00642         \{\par
00643             {\cf20 //add possible neutral losses of modifications}\par
00644             {\cf19 for} ({\cf18 int} i = 0; i < losses.Count; ++i)\par
00645             \{\par
00646                 {\cf18 double} newMass = ion - losses[i];\par
00647                 {\cf19 if} (InRange(newMass, lowerBound, upperBound))\par
00648                 \{\par
00649                     {\cf20 //add water or ammonia losses}\par
00650                     {\cf19 if} ((setting.UseWaterLosses && possibleWaterLosses > 0) || (setting.UseAmmoniaLosses && possibleAmoniaLosses > 0))\par
00651                     \{\par
00652                         IonWithNL ionWithNL = {\cf17 new} IonWithNL(newMass);\par
00653                         ionsWithNL.Add(ionWithNL);\par
00654                         CalculatePossibleNeutralLosses(newMass, possibleWaterLosses, possibleAmoniaLosses,\par
00655                           1, setting.UseWaterLosses, setting.UseAmmoniaLosses, massO, massH, massC,\par
00656                           massN, ionWithNL, lowerBound, upperBound);\par
00657                     \}\par
00658                     {\cf19 else}\par
00659                     \{\par
00660                         ionsNoNL.Add(newMass);\par
00661                     \}\par
00662                 \}\par
00663                 {\cf19 if} (charge > 2)\par
00664                 \{\par
00665                     CalculateHigherChargedIons(charge, ionsNoNL, ionsWithNL, possibleAmoniaLosses, possibleWaterLosses, massO, massH, massC, massN, massProton, setting, newMass, lowerBound, upperBound, maxAllowedChargeState);\par
00666                 \}\par
00667             \}\par
00668 \par
00669             {\cf19 if} (losses.Count == 0)\par
00670             \{\par
00671                 {\cf19 if} (InRange(ion, lowerBound, upperBound))\par
00672                 \{\par
00673                     {\cf20 //add water or ammonia losses}\par
00674                     {\cf19 if} ((setting.UseWaterLosses && possibleWaterLosses > 0) || (setting.UseAmmoniaLosses && possibleAmoniaLosses > 0))\par
00675                     \{\par
00676                         IonWithNL ionWithNL = {\cf17 new} IonWithNL(ion);\par
00677                         ionsWithNL.Add(ionWithNL);\par
00678                         CalculatePossibleNeutralLosses(ion, possibleWaterLosses, possibleAmoniaLosses,\par
00679                           1, setting.UseWaterLosses, setting.UseAmmoniaLosses, massO, massH, massC,\par
00680                           massN, ionWithNL, lowerBound, upperBound);\par
00681                     \}\par
00682                     {\cf19 else}\par
00683                     \{\par
00684                         ionsNoNL.Add(ion);\par
00685                     \}\par
00686                 \}\par
00687                 {\cf19 if} (charge > 2)\par
00688                 \{\par
00689                     CalculateHigherChargedIons(charge, ionsNoNL, ionsWithNL, possibleAmoniaLosses, possibleWaterLosses, massO, massH, massC, massN, massProton, setting, ion, lowerBound, upperBound, maxAllowedChargeState);\par
00690                 \}\par
00691             \}\par
00692         \}\par
00693 \par
00694         {\cf17 public} {\cf17 static} {\cf18 void} CalculateHigherChargedIons({\cf18 int} charge, List<double> ionsNoNL, List<IonWithNL> ionsWithNL, {\cf18 int} possibleAmoniaLosses,\par
00695                                                       {\cf18 int} possibleWaterLosses, {\cf18 double} massO, {\cf18 double} massH, {\cf18 double} massC, {\cf18 double} massN, {\cf18 double} massProton,\par
00696                                                       InstrumentSetting setting, {\cf18 double} newMass, {\cf18 double} lowerBound, {\cf18 double} upperBound, {\cf18 string} maxAllowedChargeState)\par
00697         \{\par
00698             {\cf18 string} allowedChargeStates = {\cf22 "+2"};\par
00699             {\cf19 switch} (maxAllowedChargeState)\par
00700             \{\par
00701                 {\cf19 case} {\cf22 "+2"}:\par
00702                     AddHigherChargedIons(ionsNoNL, ionsWithNL, possibleAmoniaLosses, possibleWaterLosses,\par
00703                       massO, massH, massC, massN, massProton, setting.UseWaterLosses, setting.UseAmmoniaLosses,\par
00704                       newMass, 1, lowerBound, upperBound);\par
00705                     {\cf19 break};\par
00706                 {\cf19 case} {\cf22 "+3"}:\par
00707                     {\cf19 for} ({\cf18 int} i = 1; i < charge - 1 && i < 3; ++i)\par
00708                     \{\par
00709                         AddHigherChargedIons(ionsNoNL, ionsWithNL, possibleAmoniaLosses, possibleWaterLosses,\par
00710                           massO, massH, massC, massN, massProton, setting.UseWaterLosses, setting.UseAmmoniaLosses,\par
00711                           newMass, i, lowerBound, upperBound);\par
00712                     \}\par
00713                     {\cf19 break};\par
00714                 {\cf19 case} {\cf22 "+4"}:\par
00715                     {\cf19 for} ({\cf18 int} i = 1; i < charge - 1 && i < 4; ++i)\par
00716                     \{\par
00717                         AddHigherChargedIons(ionsNoNL, ionsWithNL, possibleAmoniaLosses, possibleWaterLosses,\par
00718                           massO, massH, massC, massN, massProton, setting.UseWaterLosses, setting.UseAmmoniaLosses,\par
00719                           newMass, i, lowerBound, upperBound);\par
00720                     \}\par
00721                     {\cf19 break};\par
00722                 {\cf19 case} {\cf22 "Precursor - 1"}:\par
00723                     {\cf19 for} ({\cf18 int} i = 1; i < charge - 1; ++i)\par
00724                     \{\par
00725                         AddHigherChargedIons(ionsNoNL, ionsWithNL, possibleAmoniaLosses, possibleWaterLosses,\par
00726                           massO, massH, massC, massN, massProton, setting.UseWaterLosses, setting.UseAmmoniaLosses,\par
00727                           newMass, i, lowerBound, upperBound);\par
00728                     \}\par
00729                     {\cf19 break};\par
00730             \}\par
00731         \}\par
00732 \par
00733         {\cf17 public} {\cf17 static} {\cf18 void} AddHigherChargedIons(List<double> ionsNoNL, List<IonWithNL> ionsWithNL, {\cf18 int} possibleAmoniaLosses,\par
00734                                                 {\cf18 int} possibleWaterLosses, {\cf18 double} massO, {\cf18 double} massH, {\cf18 double} massC, {\cf18 double} massN,\par
00735                                                 {\cf18 double} massProton, {\cf18 bool} water, {\cf18 bool} ammonia, {\cf18 double} ion, {\cf18 int} currentCharge,\par
00736                                                 {\cf18 double} lowerBound, {\cf18 double} upperBound)\par
00737         \{\par
00738             {\cf18 double} chargedIon = ion + currentCharge * massProton;\par
00739             ++currentCharge;\par
00740 \par
00741             {\cf18 double} myMass = chargedIon / currentCharge;\par
00742             {\cf19 if} (InRange(myMass, lowerBound, upperBound))\par
00743             \{\par
00744                 {\cf19 if} ((water && possibleWaterLosses > 0) || (ammonia && possibleAmoniaLosses > 0))\par
00745                 \{\par
00746                     IonWithNL ionWithNL = {\cf17 new} IonWithNL(myMass);\par
00747                     ionsWithNL.Add(ionWithNL);\par
00748                     CalculatePossibleNeutralLosses(chargedIon, possibleWaterLosses, possibleAmoniaLosses,\par
00749                       currentCharge, water, ammonia, massO, massH,\par
00750                       massC, massN, ionWithNL, lowerBound, upperBound);\par
00751                 \}\par
00752                 {\cf19 else}\par
00753                 \{\par
00754                     ionsNoNL.Add(myMass);\par
00755                 \}\par
00756             \}\par
00757         \}\par
00758 \par
00759         {\cf17 public} {\cf17 static} {\cf18 void} CalculatePossibleNeutralLosses({\cf18 double} ionMass, {\cf18 int} possibleWaterLosses,\par
00760                                                           {\cf18 int} possibleAmoniaLosses, {\cf18 int} charge, {\cf18 bool} water, {\cf18 bool} ammonia, {\cf18 double} massO, {\cf18 double} massH,\par
00761                                                           {\cf18 double} massC, {\cf18 double} massN, IonWithNL ionWithNL,\par
00762                                                           {\cf18 double} lowerBound, {\cf18 double} upperBound)\par
00763         \{\par
00764             {\cf20 //handle neutral losses}\par
00765 \par
00766             {\cf18 double} massWaterLoss = massH * 2 + massO;\par
00767             {\cf18 double} massAmoniaLoss = massH * 3 + massN;\par
00768 \par
00769             {\cf18 int} currentWaterLoss = 0;\par
00770             {\cf19 while} (water && currentWaterLoss < possibleWaterLosses)\par
00771             \{\par
00772                 ++currentWaterLoss;\par
00773                 {\cf18 double} chargedIon = ionMass - currentWaterLoss * massWaterLoss;\par
00774                 {\cf18 double} myMass = IonMassStabilizer.Stabilize(chargedIon / charge);\par
00775                 {\cf20 //if(InRange( myMass, lowerBound, upperBound ))}\par
00776                 ionWithNL.Add(myMass);\par
00777             \}\par
00778 \par
00779             {\cf18 int} currentAmoniaLoss = 0;\par
00780             {\cf19 while} (ammonia && currentAmoniaLoss < possibleAmoniaLosses)\par
00781             \{\par
00782                 ++currentAmoniaLoss;\par
00783                 {\cf18 double} chargedIon = ionMass - currentAmoniaLoss * massAmoniaLoss;\par
00784                 {\cf18 double} myMass = IonMassStabilizer.Stabilize(chargedIon / charge);\par
00785                 {\cf20 //if(InRange( myMass, lowerBound, upperBound ))}\par
00786                 ionWithNL.Add(myMass);\par
00787             \}\par
00788         \}\par
00789     \}\par
00790 \par
00791     {\cf17 public} {\cf17 class }IonWithNL : List<double>\par
00792     \{\par
00793         {\cf17 public} {\cf18 double} Mz \{ {\cf17 get}; {\cf17 set}; \}\par
00794 \par
00795 \par
00796         {\cf17 public} IonWithNL({\cf18 double} baseMZ)\par
00797           : base(2)\par
00798         \{\par
00799             Mz = IonMassStabilizer.Stabilize(baseMZ);\par
00800         \}\par
00801     \}\par
00802 \par
00803     {\cf17 internal} {\cf17 static} {\cf17 class }IonMassStabilizer\par
00804     \{\par
00805         {\cf17 const} {\cf18 int} SignificantBitsStabilizer = 47; {\cf20 // Approximately 14 decimal significant digits}\par
00806 \par
00807         {\cf17 const} ulong RoundingAdditionStabilizer = unchecked(1uL << (52 - SignificantBitsStabilizer - 1));\par
00808         {\cf17 const} ulong ClearBitsStabilizerMask = unchecked(0xFFFFFFFFFFFFFFFFuL << (52 - SignificantBitsStabilizer));\par
00809 \par
00810         {\cf20 /*}\par
00811 {\cf20         Implements super-fast base2 nearest-value rounding of double precision values}\par
00812 {\cf20         to specified number of significant 2-base digits }\par
00813 {\cf20         Utilizes specificity of IEEE 754 double-precision format}\par
00814 {\cf20         Works correctly in all cases except double.Max, NaN, +/-Inf etc in input}\par
00815 {\cf20         Specially tested correctness when 52bit mantissa is all 1 (0xFFFFFFFFFFFFF)}\par
00816 {\cf20         By benchmarks works 7-15 times faster than Math.Round()}\par
00817 {\cf20         */}\par
00818         {\cf17 static} {\cf17 internal} {\cf18 double} Stabilize({\cf18 double} value)\par
00819         \{\par
00820 {\cf21             #if !DISABLE_FP_STABILIZER}\par
00821             unchecked\par
00822             \{\par
00823                 ulong im = (RoundingAdditionStabilizer + (ulong)BitConverter.DoubleToInt64Bits(value)) & ClearBitsStabilizerMask;\par
00824                 {\cf19 return} BitConverter.Int64BitsToDouble(({\cf18 long})im);\par
00825             \}\par
00826 {\cf21             #else}\par
00827                 {\cf19 return} value;\par
00828 {\cf21             #endif}\par
00829         \}\par
00830     \}\par
00831 \par
00832     {\cf17 public} {\cf17 class }Modification\par
00833     \{\par
00834         {\cf17 public} readonly {\cf18 string} Title; {\cf20 //\{ get; private set; \}}\par
00835         {\cf17 public} readonly {\cf18 string} FullName; {\cf20 // \{ get; private set; \}}\par
00836         {\cf17 private} readonly {\cf18 double} MonoMass; {\cf20 // \{ get; private set; \}}\par
00837         {\cf17 private} readonly {\cf18 double} AvgMass; {\cf20 // \{ get; private set; \}}\par
00838         {\cf17 public} readonly {\cf18 char} AA; {\cf20 // \{ get; private set; \}}\par
00839         {\cf17 public} {\cf18 double}[] NeutralLosses \{ {\cf17 get}; {\cf17 set}; \}\par
00840         {\cf17 public} {\cf18 bool} NTerminal \{ {\cf17 get}; {\cf17 set}; \}\par
00841         {\cf17 public} {\cf18 bool} CTerminal \{ {\cf17 get}; {\cf17 set}; \}\par
00842         {\cf17 public} {\cf18 bool} ProteinTerminus \{ {\cf17 get}; {\cf17 set}; \}\par
00843         {\cf17 public} {\cf18 int} MaxOccurrence \{ {\cf17 get}; {\cf17 set}; \}\par
00844 \par
00845         {\cf17 public} {\cf18 int} ID \{ {\cf17 get}; {\cf17 set}; \}\par
00846 \par
00847         {\cf17 public} {\cf18 double} Mass({\cf18 bool} mono)\par
00848         \{\par
00849             {\cf19 return} mono ? MonoMass : AvgMass;\par
00850         \}\par
00851 \par
00852         {\cf17 public} {\cf18 bool} Fixed \{ {\cf17 get}; {\cf17 set}; \}\par
00853         {\cf17 public} {\cf18 bool} SemiFixed \{ {\cf17 get}; {\cf17 set}; \}\par
00854 \par
00855         {\cf17 public} Modification({\cf18 string} title, {\cf18 string} name, {\cf18 double} mono, {\cf18 double} avg, {\cf18 char} aa, {\cf18 bool} fix, {\cf18 double}[] neutralLosses,\par
00856             {\cf18 bool} nTerminal, {\cf18 bool} cTerminal, {\cf18 int} {\cf18 id}, {\cf18 bool} protein, {\cf18 int} maxOccurrence, {\cf18 bool} semiFixed = {\cf17 false})\par
00857         \{\par
00858             Title = title;\par
00859             FullName = name;\par
00860             MonoMass = mono;\par
00861             AvgMass = avg;\par
00862             AA = aa;\par
00863             Fixed = fix;\par
00864             SemiFixed = semiFixed;\par
00865             NeutralLosses = neutralLosses;\par
00866             NTerminal = nTerminal;\par
00867             CTerminal = cTerminal;\par
00868             ID = id;\par
00869             ProteinTerminus = protein;\par
00870             MaxOccurrence = maxOccurrence;\par
00871         \}\par
00872 \par
00873         {\cf17 public} Modification(Modification m)\par
00874         \{\par
00875             Title = m.Title;\par
00876             FullName = m.FullName;\par
00877             MonoMass = m.MonoMass;\par
00878             AvgMass = m.AvgMass;\par
00879             AA = m.AA;\par
00880             Fixed = m.Fixed;\par
00881             SemiFixed = m.SemiFixed;\par
00882             NeutralLosses = m.NeutralLosses;\par
00883             NTerminal = m.NTerminal;\par
00884             CTerminal = m.CTerminal;\par
00885             ID = m.ID;\par
00886             ProteinTerminus = m.ProteinTerminus;\par
00887             MaxOccurrence = m.MaxOccurrence;\par
00888         \}\par
00889 \par
00890         {\cf17 public} Modification(Modification m, {\cf18 bool} fix, {\cf18 bool} nTerminal, {\cf18 bool} cTerminal, {\cf18 bool} protein, {\cf18 int} maxOccurrence)\par
00891         \{\par
00892             Title = m.Title;\par
00893             FullName = m.FullName;\par
00894             MonoMass = m.MonoMass;\par
00895             AvgMass = m.AvgMass;\par
00896             AA = m.AA;\par
00897             Fixed = fix;\par
00898             SemiFixed = m.SemiFixed;\par
00899             NeutralLosses = m.NeutralLosses;\par
00900             NTerminal = nTerminal;\par
00901             CTerminal = cTerminal;\par
00902             ID = m.ID;\par
00903             ProteinTerminus = protein;\par
00904             MaxOccurrence = maxOccurrence;\par
00905         \}\par
00906 \par
00907         {\cf17 public} {\cf17 override} {\cf18 string} ToString()\par
00908         \{\par
00909             {\cf18 string} name = Title + {\cf22 "("};\par
00910             {\cf19 if} (CTerminal)\par
00911             \{\par
00912                 name += {\cf22 "C-Term)"};\par
00913             \}\par
00914             {\cf19 else} {\cf19 if} (NTerminal)\par
00915             \{\par
00916                 name += {\cf22 "N-Term)"};\par
00917             \}\par
00918             {\cf19 else}\par
00919             \{\par
00920                 name += AA + {\cf22 ")"};\par
00921             \}\par
00922             {\cf19 return} name;\par
00923         \}\par
00924 \par
00925 {\cf21         #region oldstuff}\par
00926         {\cf17 public} {\cf17 static} {\cf18 string} GetSaveString(Modification modif)\par
00927         \{\par
00928             StringBuilder builder = {\cf17 new} StringBuilder();\par
00929             builder.Append(modif.Title).Append({\cf22 "\'B0"});\par
00930             builder.Append(modif.FullName).Append({\cf22 "\'B0"});\par
00931             builder.Append(modif.MonoMass).Append({\cf22 "\'B0"});\par
00932             builder.Append(modif.AvgMass).Append({\cf22 "\'B0"});\par
00933             builder.Append(modif.AA).Append({\cf22 "\'B0"});\par
00934             builder.Append(modif.Fixed).Append({\cf22 "\'B0"});\par
00935             {\cf19 foreach} ({\cf18 double} nl {\cf19 in} modif.NeutralLosses)\par
00936             \{\par
00937                 builder.Append(nl).Append({\cf22 ":"});\par
00938             \}\par
00939             builder.Append({\cf22 "\'B0"});\par
00940             builder.Append(modif.NTerminal).Append({\cf22 "\'B0"});\par
00941             builder.Append(modif.CTerminal).Append({\cf22 "\'B0"});\par
00942             builder.Append(modif.ID).Append({\cf22 "\'B0"});\par
00943             builder.Append(modif.ProteinTerminus);\par
00944             {\cf19 return} builder.ToString();\par
00945         \}\par
00946 \par
00947         {\cf20 //public static Modification GetModifOfSaveString(string savedModif) \{}\par
00948         {\cf20 //  string[] parts = savedModif.Split('\'B0');}\par
00949         {\cf20 //  double monoMass = double.Parse(parts[2]);}\par
00950         {\cf20 //  double avgMass = double.Parse(parts[3]);}\par
00951         {\cf20 //  bool fixedModif = bool.Parse(parts[5]);}\par
00952         {\cf20 //  string[] nls = parts[6].Split(new char[] \{':'\}, StringSplitOptions.RemoveEmptyEntries);}\par
00953         {\cf20 //  double[] neutralLosses = new double[nls.Length];}\par
00954         {\cf20 //  for (int i = 0; i < nls.Length; ++i) \{}\par
00955         {\cf20 //    double elem = double.Parse(nls[i]);}\par
00956         {\cf20 //    neutralLosses[i] = elem;}\par
00957         {\cf20 //  \}}\par
00958         {\cf20 //  bool nterm = bool.Parse(parts[7]);}\par
00959         {\cf20 //  bool cterm = bool.Parse(parts[8]);}\par
00960         {\cf20 //  int id = Int32.Parse(parts[9]);}\par
00961         {\cf20 //  bool protein = bool.Parse(parts[10]);}\par
00962         {\cf20 //  Modification m = new Modification(parts[0], parts[1], monoMass, avgMass, char.Parse(parts[4]), fixedModif, neutralLosses, nterm, cterm, id, protein);}\par
00963         {\cf20 //  return m;}\par
00964         {\cf20 //\}}\par
00965 {\cf21         #endregion}\par
00966     \}\par
00967 \par
00968     {\cf17 public} {\cf17 class }InstrumentSetting\par
00969     \{\par
00970         {\cf17 public} InstrumentSetting()\par
00971         \{\par
00972             Name = {\cf22 ""};\par
00973             UseAIon = {\cf17 false};\par
00974             UseAmmoniaLosses = {\cf17 false};\par
00975             UseBIon = {\cf17 false};\par
00976             UseCIon = {\cf17 false};\par
00977             UseImmoniumIons = {\cf17 false};\par
00978             UseWaterLosses = {\cf17 false};\par
00979             UseXIon = {\cf17 false};\par
00980             UseYIon = {\cf17 false};\par
00981             UseZIon = {\cf17 false};\par
00982             UseZPlusHIon = {\cf17 false};\par
00983             UseZPlusTwoHIon = {\cf17 false};\par
00984             UseInternalFragments = {\cf17 false};\par
00985             {\cf20 // new Ions}\par
00986             UseAMinusHIon = {\cf17 false};\par
00987             UseBPlusHIon = {\cf17 false};\par
00988             UseBMinusHIon = {\cf17 false};\par
00989             UseCPlusHIon = {\cf17 false};\par
00990             UseCMinusHIon = {\cf17 false};\par
00991             UseXPlusHIon = {\cf17 false};\par
00992             UseXMinusHIon = {\cf17 false};\par
00993             UseYPlusHIon = {\cf17 false};\par
00994             UseYMinusHIon = {\cf17 false};\par
00995             UseZMinusHIon = {\cf17 false};\par
00996         \}\par
00997 \par
00998         {\cf17 public} InstrumentSetting Clone()\par
00999         \{\par
01000             InstrumentSetting instr = {\cf17 new} InstrumentSetting\par
01001             \{\par
01002                 Name = this.Name,\par
01003                 UseAIon = this.UseAIon,\par
01004                 UseAmmoniaLosses = this.UseAmmoniaLosses,\par
01005                 UseBIon = this.UseBIon,\par
01006                 UseCIon = this.UseCIon,\par
01007                 UseImmoniumIons = this.UseImmoniumIons,\par
01008                 UseWaterLosses = this.UseWaterLosses,\par
01009                 UseXIon = this.UseXIon,\par
01010                 UseYIon = this.UseYIon,\par
01011                 UseZIon = this.UseZIon,\par
01012                 UseZPlusHIon = this.UseZPlusHIon,\par
01013                 UseZPlusTwoHIon = this.UseZPlusTwoHIon,\par
01014                 UseInternalFragments = this.UseInternalFragments,\par
01015                 {\cf20 // new ions}\par
01016                 UseAPlusHIon = UseAPlusHIon,\par
01017                 UseAMinusHIon = UseAMinusHIon,\par
01018                 UseBPlusHIon = UseBPlusHIon,\par
01019                 UseBMinusHIon = UseBMinusHIon,\par
01020                 UseCPlusHIon = UseCPlusHIon,\par
01021                 UseCMinusHIon = UseCMinusHIon,\par
01022                 UseXPlusHIon = UseXPlusHIon,\par
01023                 UseXMinusHIon = UseXMinusHIon,\par
01024                 UseYPlusHIon = UseYPlusHIon,\par
01025                 UseYMinusHIon = UseYMinusHIon,\par
01026                 UseZMinusHIon = UseZMinusHIon\par
01027             \};\par
01028             {\cf19 return} instr;\par
01029         \}\par
01030 \par
01031         {\cf17 public} {\cf18 string} Name \{ {\cf17 get}; {\cf17 set}; \}\par
01032         {\cf17 public} {\cf18 bool} UseAIon \{ {\cf17 get}; {\cf17 set}; \}\par
01033         {\cf17 public} {\cf18 bool} UseBIon \{ {\cf17 get}; {\cf17 set}; \}\par
01034         {\cf17 public} {\cf18 bool} UseYIon \{ {\cf17 get}; {\cf17 set}; \}\par
01035         {\cf17 public} {\cf18 bool} UseWaterLosses \{ {\cf17 get}; {\cf17 set}; \}\par
01036         {\cf17 public} {\cf18 bool} UseAmmoniaLosses \{ {\cf17 get}; {\cf17 set}; \}\par
01037         {\cf17 public} {\cf18 bool} UseImmoniumIons \{ {\cf17 get}; {\cf17 set}; \}\par
01038         {\cf17 public} {\cf18 bool} UseZIon \{ {\cf17 get}; {\cf17 set}; \}\par
01039         {\cf17 public} {\cf18 bool} UseZPlusHIon \{ {\cf17 get}; {\cf17 set}; \}\par
01040         {\cf17 public} {\cf18 bool} UseZPlusTwoHIon \{ {\cf17 get}; {\cf17 set}; \}\par
01041         {\cf17 public} {\cf18 bool} UseXIon \{ {\cf17 get}; {\cf17 set}; \}\par
01042         {\cf17 public} {\cf18 bool} UseCIon \{ {\cf17 get}; {\cf17 set}; \}\par
01043         {\cf17 public} {\cf18 bool} UseInternalFragments \{ {\cf17 get}; {\cf17 set}; \}\par
01044 \par
01045         {\cf20 // new Ions}\par
01046         {\cf17 public} {\cf18 bool} UseAPlusHIon \{ {\cf17 get}; {\cf17 set}; \}\par
01047         {\cf17 public} {\cf18 bool} UseAMinusHIon \{ {\cf17 get}; {\cf17 set}; \}\par
01048         {\cf17 public} {\cf18 bool} UseBPlusHIon \{ {\cf17 get}; {\cf17 set}; \}\par
01049         {\cf17 public} {\cf18 bool} UseBMinusHIon \{ {\cf17 get}; {\cf17 set}; \}\par
01050         {\cf17 public} {\cf18 bool} UseCPlusHIon \{ {\cf17 get}; {\cf17 set}; \}\par
01051         {\cf17 public} {\cf18 bool} UseCMinusHIon \{ {\cf17 get}; {\cf17 set}; \}\par
01052         {\cf17 public} {\cf18 bool} UseXPlusHIon \{ {\cf17 get}; {\cf17 set}; \}\par
01053         {\cf17 public} {\cf18 bool} UseXMinusHIon \{ {\cf17 get}; {\cf17 set}; \}\par
01054         {\cf17 public} {\cf18 bool} UseYPlusHIon \{ {\cf17 get}; {\cf17 set}; \}\par
01055         {\cf17 public} {\cf18 bool} UseYMinusHIon \{ {\cf17 get}; {\cf17 set}; \}\par
01056         {\cf17 public} {\cf18 bool} UseZMinusHIon \{ {\cf17 get}; {\cf17 set}; \}\par
01057 \par
01058     \}\par
01059 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MGFParser.cs\par \pard\plain 
{\tc\tcl2 \v amanda/MGFParser.cs}
{\xe \v amanda/MGFParser.cs}
{\bkmkstart AAAAAAAAAD}
{\bkmkend AAAAAAAAAD}
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf17 using }System.Globalization;\par
00002 {\cf17 using }System.Text.RegularExpressions;\par
00003 \par
00004 {\cf17 namespace }MSAMANDA_MGFPARSER\par
00005 \{\par
00006     {\cf17 public} {\cf17 class }AMassCentroid\par
00007     \{\par
00008         {\cf17 public} {\cf18 double} Position \{ {\cf17 get}; {\cf17 set}; \}\par
00009         {\cf17 public} {\cf18 double} Intensity \{ {\cf17 get}; {\cf17 set}; \}\par
00010         {\cf17 public} {\cf18 int} Charge \{ {\cf17 get}; {\cf17 set}; \}\par
00011 \par
00012         {\cf17 public} AMassCentroid Clone()\par
00013         \{\par
00014             {\cf19 return} {\cf17 new} AMassCentroid() \{ Position = this.Position, Intensity = this.Intensity, Charge = this.Charge \};\par
00015         \}\par
00016 \par
00017         {\cf17 public} AMassCentroid Clone({\cf18 int} charge)\par
00018         \{\par
00019             {\cf19 return} {\cf17 new} AMassCentroid() \{ Position = this.Position, Intensity = this.Intensity, Charge = charge \};\par
00020         \}\par
00021     \}\par
00022 \par
00023     {\cf17 public} {\cf17 class }Precursor\par
00024     \{\par
00025         {\cf17 public} {\cf18 double} MOverZ \{ {\cf17 get}; {\cf17 private} {\cf17 set}; \}\par
00026         {\cf17 public} {\cf18 double} UnChargedMass \{ {\cf17 get}; {\cf17 private} {\cf17 set}; \}\par
00027         {\cf17 public} {\cf18 double} Intensity \{ {\cf17 get}; {\cf17 set}; \}\par
00028         {\cf17 public} {\cf18 int} Charge \{ {\cf17 get}; {\cf17 private} {\cf17 set}; \}\par
00029         {\cf17 public} {\cf18 int} Rank \{ {\cf17 get}; {\cf17 set}; \}\par
00030 \par
00031         {\cf17 public} {\cf18 void} SetMassCharge({\cf18 double} mz, {\cf18 int} charge, {\cf18 bool} mono)\par
00032         \{\par
00033             MOverZ = mz;\par
00034             Charge = charge;\par
00035             UnChargedMass = MSAMANDA_CHEMICALUTILS.ChemicalUtils.CalculateUnchargedMass(MOverZ, Charge, mono);\par
00036         \}\par
00037     \}\par
00038 \par
00039     {\cf17 public} {\cf17 class }Spectrum\par
00040     \{\par
00041         {\cf17 public} {\cf18 int} ScanNumber \{ {\cf17 get}; {\cf17 set}; \}\par
00042         {\cf17 public} {\cf18 int} SpectrumId \{ {\cf17 get}; {\cf17 set}; \}\par
00043         {\cf17 public} {\cf18 double} RT \{ {\cf17 get}; {\cf17 set}; \}\par
00044         {\cf17 public} List<AMassCentroid> FragmentsPeaks \{ {\cf17 get}; {\cf17 set}; \}\par
00045         {\cf17 public} Dictionary<int, double> ImmunePeaks \{ {\cf17 get}; {\cf17 set}; \}\par
00046         {\cf17 public} SortedSet<double> ImmuneMasses \{ {\cf17 get}; {\cf17 set}; \}\par
00047         {\cf17 public} Precursor Precursor \{ {\cf17 get}; {\cf17 set}; \}\par
00048 \par
00049         {\cf17 public} Spectrum()\par
00050         \{\par
00051             ScanNumber = 0;\par
00052             RT = 0.0;\par
00053             SpectrumId = 0;\par
00054             Precursor = {\cf17 new} Precursor();\par
00055         \}\par
00056     \}\par
00057 \par
00058     {\cf17 public} {\cf17 static} {\cf17 class }MGFParser\par
00059     \{\par
00060         {\cf17 public} {\cf17 static} List<Spectrum> ParseNextSpectra({\cf18 string} filename)\par
00061         \{\par
00062             List<Spectrum> spectra = {\cf17 new} List<Spectrum>();\par
00063             {\cf18 int} nrOfReadSpectra = 0;\par
00064             {\cf18 int} nrOfSpectra = 0;\par
00065             {\cf18 double} mOverZ = 0.0;\par
00066             {\cf18 int} charge = 0;\par
00067             Dictionary<int, double> peaks = {\cf17 new} Dictionary<int, double>();\par
00068             Spectrum currentSpectrum = {\cf17 null};\par
00069             {\cf18 bool} isCorrect = {\cf17 true};\par
00070             {\cf18 string} lastScannumber = {\cf18 string}.Empty;\par
00071             {\cf18 string} title = {\cf22 ""};\par
00072             {\cf18 int} _scanId = 0;\par
00073             var SpectTitleMap = {\cf17 new} Dictionary<int, string>();\par
00074 \par
00075             {\cf19 try}\par
00076             \{\par
00077                 {\cf17 using} (StreamReader sr = {\cf17 new} StreamReader(filename))\par
00078                 \{\par
00079                     {\cf19 while} (!sr.EndOfStream)\par
00080                     \{\par
00081                         var line = sr.ReadLine();\par
00082 \par
00083                         {\cf19 if} (line == {\cf17 null}) {\cf19 continue};\par
00084 \par
00085                         {\cf20 // error in parsing spectrum, search for next one}\par
00086                         {\cf19 if} (!isCorrect && (!line.ToUpper().StartsWith({\cf22 "BEGIN IONS"}, StringComparison.Ordinal)))\par
00087                         \{\par
00088                             {\cf19 continue};\par
00089                         \}\par
00090 \par
00091                         {\cf19 if} (line.ToUpper().StartsWith({\cf22 "BEGIN IONS"}, StringComparison.Ordinal))\par
00092                         \{\par
00093                             {\cf19 if} (currentSpectrum != {\cf17 null} && isCorrect)\par
00094                             \{\par
00095                                 Console.WriteLine(\par
00096                                     {\cf22 "  Skipping spectrum with scannumber '"} + currentSpectrum.ScanNumber +\par
00097                                     {\cf22 "'. No end ions found."}\par
00098                                     );\par
00099                             \}\par
00100 \par
00101                             ++nrOfSpectra;\par
00102                             isCorrect = {\cf17 true};\par
00103                             peaks = {\cf17 new} Dictionary<int, double>();\par
00104                             mOverZ = 0.0;\par
00105                             charge = 0;\par
00106                             currentSpectrum = {\cf17 new} Spectrum\par
00107                             \{\par
00108                                 FragmentsPeaks = {\cf17 new} List<AMassCentroid>(),\par
00109                                 ImmuneMasses = {\cf17 new} SortedSet<double>(),\par
00110                                 ImmunePeaks = {\cf17 new} Dictionary<int, double>(),\par
00111                                 SpectrumId = _scanId\par
00112                             \};\par
00113                         \}\par
00114                         {\cf19 else} {\cf19 if} (LineCanBeIgnored(line)) \{ \}\par
00115                         {\cf19 else}\par
00116                         \{\par
00117                             {\cf19 if} (currentSpectrum == {\cf17 null})\par
00118                             \{\par
00119                                 isCorrect = {\cf17 false};\par
00120                                 Console.WriteLine(\par
00121                                     {\cf22 "  Skipping spectrum after scannumber '"} + lastScannumber + {\cf22 "'. No begin ions found."}\par
00122                                     );\par
00123                                 {\cf19 continue};\par
00124                             \}\par
00125 \par
00126                             {\cf19 if} (line.ToUpper().StartsWith({\cf22 "TITLE"}, StringComparison.Ordinal))\par
00127                             \{\par
00128                                 {\cf18 int} inx = line.IndexOf({\cf22 "="});\par
00129                                 title = line.Substring(inx + 1);\par
00130                                 {\cf19 if} (line.ToUpper().Contains({\cf22 "SCAN"}, StringComparison.Ordinal))\par
00131                                 \{\par
00132                                     Match s = Regex.Match(line.ToUpper(), {\cf22 @"SCAN.?[:=\\s]\\s?([0-9]+)"});\par
00133                                     {\cf19 if} (s.Success)\par
00134                                         currentSpectrum.ScanNumber = Int32.Parse(s.Groups[1].Value);\par
00135                                 \}\par
00136                                 {\cf19 else} {\cf19 if} (line.ToUpper().Contains({\cf22 "INDEX"}, StringComparison.Ordinal))\par
00137                                 \{\par
00138                                     Match s = Regex.Match(line.ToUpper(), {\cf22 @"INDEX.?[:=\\s]\\s?([0-9]+)"});\par
00139                                     {\cf19 if} (s.Success)\par
00140                                         currentSpectrum.ScanNumber = Int32.Parse(s.Groups[1].Value);\par
00141                                 \}\par
00142                             \}\par
00143                             {\cf19 else} {\cf19 if} (line.ToUpper().StartsWith({\cf22 "PEPMASS"}, StringComparison.Ordinal))\par
00144                             \{\par
00145                                 mOverZ = ParseMOverZ(line);\par
00146                             \}\par
00147                             {\cf19 else} {\cf19 if} (line.ToUpper().StartsWith({\cf22 "CHARGE"}, StringComparison.Ordinal))\par
00148                             \{\par
00149                                 charge = ParseCharge(line);\par
00150                             \}\par
00151                             {\cf19 else} {\cf19 if} (line.ToUpper().StartsWith({\cf22 "RTINSECONDS"}, StringComparison.Ordinal))\par
00152                             \{\par
00153                                 currentSpectrum.RT = ParseRt(line);\par
00154                             \}\par
00155                             {\cf19 else} {\cf19 if} (line.ToUpper().StartsWith({\cf22 "SCANS"}, StringComparison.Ordinal))\par
00156                             \{\par
00157                                 currentSpectrum.ScanNumber = ParseScanNumber(line);\par
00158                             \}\par
00159                             {\cf19 else} {\cf19 if} (line.ToUpper().StartsWith({\cf22 "END IONS"}, StringComparison.Ordinal))\par
00160                             \{\par
00161                                 {\cf19 if} (currentSpectrum.ScanNumber == 0)\par
00162                                 \{\par
00163                                     {\cf19 if} ({\cf18 string}.IsNullOrEmpty(title))\par
00164                                     \{\par
00165                                         Console.WriteLine(\par
00166                                             {\cf22 "  Skipping spectrum after scannumber '"} +\par
00167                                             lastScannumber + {\cf22 "'. No title or scan number found."}\par
00168                                             );\par
00169                                         isCorrect = {\cf17 false};\par
00170                                         {\cf19 continue};\par
00171                                     \}\par
00172 \par
00173                                     {\cf18 string}[] titleArr = title.Split({\cf23 '.'});\par
00174                                     {\cf19 if} (titleArr.Length > 3)\par
00175                                         currentSpectrum.ScanNumber =\par
00176                                             Int32.Parse(titleArr[titleArr.Length - 3]); {\cf20 // vorvorletztes item; => firstScan}\par
00177                                 \}\par
00178 \par
00179                                 {\cf19 if} (currentSpectrum.FragmentsPeaks.Count == 0 || mOverZ == 0)\par
00180                                 \{\par
00181                                     {\cf18 string} text = title;\par
00182                                     {\cf19 if} (currentSpectrum.ScanNumber != 0)\par
00183                                         text = currentSpectrum.ScanNumber.ToString();\par
00184 \par
00185                                     {\cf19 if} (mOverZ == 0)\par
00186                                     \{\par
00187                                         Console.WriteLine(\par
00188                                             {\cf22 "  Skipping spectrum with scannumber '"} + text + {\cf22 "'. No mass value found."}\par
00189                                             );\par
00190                                     \}\par
00191                                     {\cf19 else}\par
00192                                     \{\par
00193                                         Console.WriteLine(\par
00194                                             {\cf22 "  Skipping spectrum with scannumber '"} + text + {\cf22 "'. No peaks found."}\par
00195                                             );\par
00196                                     \}\par
00197 \par
00198                                     isCorrect = {\cf17 false};\par
00199                                     {\cf19 continue};\par
00200                                 \}\par
00201 \par
00202                                 {\cf20 // masses and peaks not needed, new calculation from fragmentpeaks}\par
00203                                 {\cf20 // masses and peaks are overwritten in Spectrum.PrepareForSearch()}\par
00204 \par
00205                                 {\cf19 if} (charge == 0)\par
00206                                 \{\par
00207                                     {\cf19 foreach} ({\cf18 int} consideredCharge {\cf19 in} {\cf17 new} List<int>() \{ 2, 3, 4, 5, 6 \})\par
00208                                     \{\par
00209                                         var s = GenerateSpectrum(currentSpectrum.FragmentsPeaks,\par
00210                                             currentSpectrum.ScanNumber, _scanId, currentSpectrum.RT, mOverZ,\par
00211                                             consideredCharge);\par
00212                                         spectra.Add(s);\par
00213                                         _scanId++;\par
00214                                     \}\par
00215                                 \}\par
00216                                 {\cf19 else}\par
00217                                 \{\par
00218                                     currentSpectrum.Precursor.SetMassCharge(mOverZ, charge, {\cf17 true});\par
00219                                     spectra.Add(currentSpectrum);\par
00220                                     SpectTitleMap.Add(_scanId, title.Trim());\par
00221                                     _scanId++;\par
00222                                 \}\par
00223 \par
00224 \par
00225                                 ++nrOfReadSpectra;\par
00226                                 lastScannumber = currentSpectrum.ScanNumber.ToString();\par
00227                                 title = {\cf18 string}.Empty;\par
00228                                 peaks = {\cf17 new} Dictionary<int, double>();\par
00229                                 mOverZ = 0.0;\par
00230                                 charge = 0;\par
00231                                 currentSpectrum = {\cf17 null};\par
00232                             \}\par
00233                             {\cf20 // fragments}\par
00234                             {\cf19 else}\par
00235                             \{\par
00236                                 {\cf18 string}[] parts = line.Split({\cf17 new}[] \{ {\cf23 ' '} \}, StringSplitOptions.RemoveEmptyEntries);\par
00237                                 {\cf19 if} (parts.Length == 1)\par
00238                                 \{\par
00239                                     parts = line.Split({\cf17 new}[] \{ {\cf23 '\\t'} \}, StringSplitOptions.RemoveEmptyEntries);\par
00240                                 \}\par
00241 \par
00242                                 {\cf19 if} (parts.Length == 2 || parts.Length == 3)\par
00243                                 \{\par
00244                                     {\cf18 double} mass;\par
00245                                     {\cf18 double} intensity;\par
00246 \par
00247                                     {\cf19 try}\par
00248                                     \{\par
00249                                         mass = ParseMass(parts[0], line);\par
00250                                     \}\par
00251                                     {\cf19 catch} (Exception e)\par
00252                                     \{\par
00253                                         Console.WriteLine(\par
00254                                             {\cf22 "  Skipping spectrum with scannumber '"} +\par
00255                                             currentSpectrum.ScanNumber + {\cf22 "'. Error in parsing mass of peak."});\par
00256                                         Console.WriteLine(e.ToString());\par
00257                                         isCorrect = {\cf17 false};\par
00258                                         {\cf19 continue};\par
00259                                     \}\par
00260 \par
00261                                     {\cf19 try}\par
00262                                     \{\par
00263                                         intensity = ParseIntensity(parts[1], line);\par
00264                                     \}\par
00265                                     {\cf19 catch} (Exception e)\par
00266                                     \{\par
00267                                         Console.WriteLine(\par
00268                                             {\cf22 "  Skipping spectrum with scannumber '"} +\par
00269                                             currentSpectrum.ScanNumber + {\cf22 "'. Error in parsing intensity of peak."});\par
00270                                         Console.WriteLine(e.ToString());\par
00271                                         isCorrect = {\cf17 false};\par
00272                                         {\cf19 continue};\par
00273                                     \}\par
00274 \par
00275                                     {\cf18 int} key = MSAMANDA_CHEMICALUTILS.ChemicalUtils.GetMassIndex(mass);\par
00276                                     {\cf19 if} (peaks.ContainsKey(key))\par
00277                                     \{\par
00278                                         {\cf19 if} (peaks[key] < intensity)\par
00279                                             peaks[key] = intensity;\par
00280                                     \}\par
00281                                     {\cf19 else}\par
00282                                     \{\par
00283                                         peaks.Add(key, intensity);\par
00284                                     \}\par
00285 \par
00286                                     currentSpectrum.FragmentsPeaks.Add(\par
00287                                         GenerateFragmentPeak(mass, peaks[key], charge));\par
00288                                 \}\par
00289                                 {\cf19 else}\par
00290                                 \{\par
00291                                     Console.WriteLine(\par
00292                                         {\cf22 "  Skipping spectrum with scannumber '"} +\par
00293                                         currentSpectrum.ScanNumber + {\cf22 "'. Error in parsing peak."});\par
00294                                     isCorrect = {\cf17 false};\par
00295                                 \}\par
00296                             \}\par
00297                         \}\par
00298                     \}\par
00299                 \}\par
00300             \}\par
00301             {\cf19 catch} (Exception ex)\par
00302             \{\par
00303                 Console.WriteLine({\cf22 "Error parsing mgf file at or after spectrum '"} + title + {\cf22 "'."});\par
00304                 Console.WriteLine(ex.ToString());\par
00305                 spectra.Clear();\par
00306                 {\cf19 throw};\par
00307             \}\par
00308 \par
00309             {\cf19 return} spectra;\par
00310         \}\par
00311 \par
00312         {\cf17 private} {\cf17 static} Spectrum GenerateSpectrum(List<AMassCentroid> fragmentsPeaks, {\cf18 int} numb, {\cf18 int} scanId, {\cf18 double} rt, {\cf18 double} mOverZ, {\cf18 int} charge)\par
00313         \{\par
00314             Spectrum s = {\cf17 new} Spectrum\par
00315             \{\par
00316                 FragmentsPeaks = fragmentsPeaks,\par
00317                 ScanNumber = numb,\par
00318                 SpectrumId = scanId,\par
00319                 RT = rt,\par
00320                 ImmuneMasses = {\cf17 new} SortedSet<double>(),\par
00321                 ImmunePeaks = {\cf17 new} Dictionary<int, double>()\par
00322             \};\par
00323             s.Precursor.SetMassCharge(mOverZ, charge, {\cf17 true});\par
00324             {\cf19 return} s;\par
00325         \}\par
00326 \par
00327         {\cf17 public} {\cf17 static} AMassCentroid GenerateFragmentPeak({\cf18 double} position, {\cf18 double} intensity, {\cf18 int} charge)\par
00328         \{\par
00329             AMassCentroid amass = {\cf17 new} AMassCentroid\par
00330             \{\par
00331                 Position = position,\par
00332                 Intensity = intensity,\par
00333                 Charge = (short)charge\par
00334             \};\par
00335 \par
00336             {\cf19 return} amass;\par
00337         \}\par
00338 \par
00339         {\cf17 private} {\cf17 static} {\cf18 double} ParseIntensity({\cf18 string} replace, {\cf18 string} line)\par
00340         \{\par
00341             {\cf18 string} ReplaceDecimalSeperator({\cf18 string} toReplace)\par
00342             \{\par
00343                 {\cf19 return} toReplace.Replace({\cf22 ","}, NumberFormatInfo.CurrentInfo.NumberDecimalSeparator, StringComparison.Ordinal)\par
00344                     .Replace({\cf22 "."}, NumberFormatInfo.CurrentInfo.NumberDecimalSeparator, StringComparison.Ordinal);\par
00345             \}\par
00346 \par
00347             {\cf18 string} i = ReplaceDecimalSeperator(replace);\par
00348             {\cf18 double} intensity = Double.Parse(i);\par
00349             {\cf19 return} intensity;\par
00350         \}\par
00351 \par
00352         {\cf17 private} {\cf17 static} {\cf18 double} ParseMass({\cf18 string} replace, {\cf18 string} line)\par
00353         \{\par
00354             {\cf18 string} ReplaceDecimalSeperator({\cf18 string} toReplace)\par
00355             \{\par
00356                 {\cf19 return} toReplace.Replace({\cf22 ","}, NumberFormatInfo.CurrentInfo.NumberDecimalSeparator, StringComparison.Ordinal)\par
00357                     .Replace({\cf22 "."}, NumberFormatInfo.CurrentInfo.NumberDecimalSeparator, StringComparison.Ordinal);\par
00358             \}\par
00359 \par
00360             {\cf18 string} m = ReplaceDecimalSeperator(replace);\par
00361             {\cf18 double} mass = Double.Parse(m);\par
00362             {\cf19 return} mass;\par
00363         \}\par
00364 \par
00365         {\cf17 private} {\cf17 static} {\cf18 int} ParseCharge({\cf18 string} line)\par
00366         \{\par
00367             {\cf18 int} inx = line.IndexOf({\cf22 "+"}, StringComparison.Ordinal);\par
00368             {\cf18 string} m = line.Substring(7);\par
00369             {\cf19 if} (inx != -1)\par
00370                 m = line.Substring(7, inx - 7);\par
00371             {\cf19 if} (!String.IsNullOrEmpty(m))\par
00372             \{\par
00373                 {\cf19 return} Int32.Parse(m);\par
00374             \}\par
00375 \par
00376             {\cf19 return} 0;\par
00377         \}\par
00378 \par
00379         {\cf17 private} {\cf17 static} {\cf18 double} ParseRt({\cf18 string} line)\par
00380         \{\par
00381             {\cf18 string} ReplaceDecimalSeperator({\cf18 string} toReplace)\par
00382             \{\par
00383                 {\cf19 return} toReplace.Replace({\cf22 ","}, NumberFormatInfo.CurrentInfo.NumberDecimalSeparator, StringComparison.Ordinal)\par
00384                     .Replace({\cf22 "."}, NumberFormatInfo.CurrentInfo.NumberDecimalSeparator, StringComparison.Ordinal);\par
00385             \}\par
00386 \par
00387             {\cf18 int} inx = line.IndexOf({\cf22 "="}, StringComparison.Ordinal);\par
00388             {\cf18 string} m = line.Substring(inx + 1);\par
00389             m = ReplaceDecimalSeperator(m);\par
00390 \par
00391             {\cf18 bool} ok = Double.TryParse(m, out var rt);\par
00392             {\cf19 if} (!ok) {\cf19 throw} {\cf17 new} Exception({\cf22 "Error in parsing: "} + line);\par
00393 \par
00394             {\cf19 return} rt;\par
00395         \}\par
00396 \par
00397         {\cf17 private} {\cf17 static} {\cf18 int} ParseScanNumber({\cf18 string} line)\par
00398         \{\par
00399             {\cf18 int} inx = line.IndexOf({\cf22 "="}, StringComparison.Ordinal);\par
00400             {\cf18 string} m = line.Substring(inx + 1);\par
00401             {\cf19 if} (m.Contains({\cf22 "MSMS:"}, StringComparison.Ordinal))\par
00402             \{\par
00403                 {\cf18 int} idxMSMS = m.IndexOf({\cf22 "MSMS:"}, StringComparison.Ordinal);\par
00404                 m = m.Substring(idxMSMS + 5);\par
00405             \}\par
00406 \par
00407             {\cf19 return} Int32.Parse(m.Trim());\par
00408         \}\par
00409 \par
00410         {\cf17 private} {\cf17 static} {\cf18 double} ParseMOverZ({\cf18 string} line)\par
00411         \{\par
00412             {\cf18 string} ReplaceDecimalSeperator({\cf18 string} toReplace)\par
00413             \{\par
00414                 {\cf19 return} toReplace.Replace({\cf22 ","}, NumberFormatInfo.CurrentInfo.NumberDecimalSeparator, StringComparison.Ordinal)\par
00415                     .Replace({\cf22 "."}, NumberFormatInfo.CurrentInfo.NumberDecimalSeparator, StringComparison.Ordinal);\par
00416             \}\par
00417 \par
00418             {\cf18 double} GetDoubleFromString({\cf18 string} p)\par
00419             \{\par
00420                 {\cf19 if} ({\cf18 string}.IsNullOrEmpty(p)) {\cf19 return} -1;\par
00421 \par
00422                 {\cf19 try}\par
00423                 \{\par
00424                     {\cf19 return} p.Contains({\cf22 "."}, StringComparison.Ordinal)\par
00425                         ? {\cf18 double}.Parse(p, CultureInfo.InvariantCulture)\par
00426                         : {\cf18 double}.Parse(ReplaceDecimalSeperator(p));\par
00427                 \}\par
00428                 {\cf19 catch} (Exception e)\par
00429                 \{\par
00430                     Console.WriteLine(e.ToString());\par
00431                     {\cf19 return} -1;\par
00432                 \}\par
00433             \}\par
00434 \par
00435             {\cf18 int} inx = line.IndexOf({\cf22 " "}, StringComparison.Ordinal);\par
00436             {\cf19 if} (inx == -1)\par
00437             \{\par
00438                 inx = line.IndexOf({\cf22 "\\t"}, StringComparison.Ordinal);\par
00439             \}\par
00440             var m = (inx == -1) ? line.Substring(8) : line.Substring(8, inx - 8);\par
00441 \par
00442             m = ReplaceDecimalSeperator(m);\par
00443             var mOverZ = GetDoubleFromString(m);\par
00444             {\cf19 return} mOverZ;\par
00445         \}\par
00446 \par
00447         {\cf17 private} {\cf17 static} {\cf18 bool} LineCanBeIgnored({\cf18 string} line)\par
00448         \{\par
00449             {\cf20 // line is not ignored }\par
00450             {\cf20 //BEGIN IONS, END IONS, TITLE, SCANS, RTINSECONDS, PEPMASS , numbers}\par
00451             {\cf19 if} ({\cf18 string}.IsNullOrWhiteSpace(line))\par
00452                 {\cf19 return} {\cf17 true};\par
00453 \par
00454             var text = line.TrimStart().ToUpper();\par
00455             {\cf20 // comment lines}\par
00456             {\cf19 if} (text.StartsWith({\cf22 "#"}, StringComparison.Ordinal))\par
00457                 {\cf19 return} {\cf17 true};\par
00458             {\cf19 if} (text.StartsWith({\cf22 "!"}, StringComparison.Ordinal))\par
00459                 {\cf19 return} {\cf17 true};\par
00460             {\cf19 if} (text.StartsWith({\cf22 ";"}, StringComparison.Ordinal))\par
00461                 {\cf19 return} {\cf17 true};\par
00462             {\cf19 if} (text.StartsWith({\cf22 "/"}, StringComparison.Ordinal))\par
00463                 {\cf19 return} {\cf17 true};\par
00464             {\cf19 if} (text.StartsWith({\cf22 "_"}, StringComparison.Ordinal))\par
00465                 {\cf19 return} {\cf17 true};\par
00466             {\cf20 // unused info in lines}\par
00467             {\cf19 if} (text.StartsWith({\cf22 "MASS"}, StringComparison.Ordinal))\par
00468                 {\cf19 return} {\cf17 true};\par
00469             {\cf19 if} (text.StartsWith({\cf22 "INSTRUMENT"}, StringComparison.Ordinal))\par
00470                 {\cf19 return} {\cf17 true};\par
00471             {\cf20 // new ignored values from http://www.matrixscience.com/help/data_file_help.html#RULES}\par
00472             {\cf19 if} (text.StartsWith({\cf22 "ACCESSION"}, StringComparison.Ordinal))\par
00473                 {\cf19 return} {\cf17 true};\par
00474             {\cf19 if} (text.StartsWith({\cf22 "CLE"}, StringComparison.Ordinal))\par
00475                 {\cf19 return} {\cf17 true};\par
00476             {\cf19 if} (text.StartsWith({\cf22 "COM"}, StringComparison.Ordinal))\par
00477                 {\cf19 return} {\cf17 true};\par
00478             {\cf19 if} (text.StartsWith({\cf22 "CUTOUT"}, StringComparison.Ordinal))\par
00479                 {\cf19 return} {\cf17 true};\par
00480             {\cf19 if} (text.StartsWith({\cf22 "COMP"}, StringComparison.Ordinal))\par
00481                 {\cf19 return} {\cf17 true};\par
00482             {\cf19 if} (text.StartsWith({\cf22 "DB"}, StringComparison.Ordinal))\par
00483                 {\cf19 return} {\cf17 true};\par
00484             {\cf19 if} (text.StartsWith({\cf22 "DECOY"}, StringComparison.Ordinal))\par
00485                 {\cf19 return} {\cf17 true};\par
00486             {\cf19 if} (text.StartsWith({\cf22 "ERRORTOLERANT"}, StringComparison.Ordinal))\par
00487                 {\cf19 return} {\cf17 true};\par
00488             {\cf19 if} (text.StartsWith({\cf22 "ETAG"}, StringComparison.Ordinal))\par
00489                 {\cf19 return} {\cf17 true};\par
00490             {\cf19 if} (text.StartsWith({\cf22 "FORMAT"}, StringComparison.Ordinal))\par
00491                 {\cf19 return} {\cf17 true};\par
00492             {\cf19 if} (text.StartsWith({\cf22 "FRAMES"}, StringComparison.Ordinal))\par
00493                 {\cf19 return} {\cf17 true};\par
00494             {\cf19 if} (text.StartsWith({\cf22 "IT_MODS"}, StringComparison.Ordinal))\par
00495                 {\cf19 return} {\cf17 true};\par
00496             {\cf19 if} (text.StartsWith({\cf22 "ITOL"}, StringComparison.Ordinal))\par
00497                 {\cf19 return} {\cf17 true};\par
00498             {\cf19 if} (text.StartsWith({\cf22 "ITOLU"}, StringComparison.Ordinal))\par
00499                 {\cf19 return} {\cf17 true};\par
00500             {\cf19 if} (text.StartsWith({\cf22 "LIBRARY_SEARCH"}, StringComparison.Ordinal))\par
00501                 {\cf19 return} {\cf17 true};\par
00502             {\cf19 if} (text.StartsWith({\cf22 "LOCUS"}, StringComparison.Ordinal))\par
00503                 {\cf19 return} {\cf17 true};\par
00504             {\cf19 if} (text.StartsWith({\cf22 "MODS"}, StringComparison.Ordinal))\par
00505                 {\cf19 return} {\cf17 true};\par
00506             {\cf19 if} (text.StartsWith({\cf22 "MULTI_SITE_MODS"}, StringComparison.Ordinal))\par
00507                 {\cf19 return} {\cf17 true};\par
00508             {\cf19 if} (text.StartsWith({\cf22 "PEP_ISOTOPE_ERROR"}, StringComparison.Ordinal))\par
00509                 {\cf19 return} {\cf17 true};\par
00510             {\cf19 if} (text.StartsWith({\cf22 "PFA"}, StringComparison.Ordinal))\par
00511                 {\cf19 return} {\cf17 true};\par
00512             {\cf20 // only used in .pks, .xml}\par
00513             {\cf19 if} (text.StartsWith({\cf22 "PRECURSOR"}, StringComparison.Ordinal))\par
00514                 {\cf19 return} {\cf17 true};\par
00515             {\cf19 if} (text.StartsWith({\cf22 "QUANTIFICATION"}, StringComparison.Ordinal))\par
00516                 {\cf19 return} {\cf17 true};\par
00517             {\cf19 if} (text.StartsWith({\cf22 "RAWFILE"}, StringComparison.Ordinal))\par
00518                 {\cf19 return} {\cf17 true};\par
00519             {\cf19 if} (text.StartsWith({\cf22 "RAWSCANS"}, StringComparison.Ordinal))\par
00520                 {\cf19 return} {\cf17 true};\par
00521             {\cf19 if} (text.StartsWith({\cf22 "REPORT"}, StringComparison.Ordinal))\par
00522                 {\cf19 return} {\cf17 true};\par
00523             {\cf19 if} (text.StartsWith({\cf22 "REPTYPE"}, StringComparison.Ordinal))\par
00524                 {\cf19 return} {\cf17 true};\par
00525             {\cf19 if} (text.StartsWith({\cf22 "SEARCH"}, StringComparison.Ordinal))\par
00526                 {\cf19 return} {\cf17 true};\par
00527             {\cf19 if} (text.StartsWith({\cf22 "SEG"}, StringComparison.Ordinal))\par
00528                 {\cf19 return} {\cf17 true};\par
00529             {\cf19 if} (text.StartsWith({\cf22 "SEQ"}, StringComparison.Ordinal))\par
00530                 {\cf19 return} {\cf17 true};\par
00531             {\cf19 if} (text.StartsWith({\cf22 "TAG"}, StringComparison.Ordinal))\par
00532                 {\cf19 return} {\cf17 true};\par
00533             {\cf19 if} (text.StartsWith({\cf22 "TAXONOMY"}, StringComparison.Ordinal))\par
00534                 {\cf19 return} {\cf17 true};\par
00535             {\cf19 if} (text.StartsWith({\cf22 "TOL"}, StringComparison.Ordinal))\par
00536                 {\cf19 return} {\cf17 true};\par
00537             {\cf20 // combines USER00 - USER12, USEREMAIL, USERNAME}\par
00538             {\cf19 if} (text.StartsWith({\cf22 "USER"}, StringComparison.Ordinal))\par
00539                 {\cf19 return} {\cf17 true};\par
00540 \par
00541             {\cf19 return} {\cf17 false};\par
00542         \}\par
00543     \}\par
00544 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CandidateSearch.cs\par \pard\plain 
{\bkmkstart AAAAAAAAAE}
{\bkmkend AAAAAAAAAE}
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf17 using }CandidateSearch.util;\par
00002 \par
00003 {\cf17 namespace }CandidateSearch\par
00004 \{\par
00010     {\cf17 public} {\cf17 class }CandidateSearch\par
00011     \{\par
00015         {\cf17 public} {\cf17 const} {\cf18 string} version = {\cf22 "1.0.0"};\par
00016 \par
00021         {\cf17 public} {\cf17 static} {\cf18 void} Main({\cf18 string}[] args)\par
00022         \{\par
00023             {\cf19 if} (args.Length == 3) \{\par
00024                 var spectraFile = args[0];\par
00025                 var databaseFile = args[1];\par
00026                 var settingsFile = args[2];\par
00027 \par
00028                 Console.WriteLine(${\cf22 "Starting Candidate Search v\{version\} ..."});\par
00029 \par
00030                 var settings = SettingsReader.readSettings(settingsFile);\par
00031                 Console.WriteLine(${\cf22 "Read settings file '\{settingsFile\}' with the following settings:"});\par
00032                 Console.WriteLine(settings.ToString());\par
00033 \par
00034                 {\cf19 if} (settings.MODE.Split({\cf22 "_"}).First().Trim() == {\cf22 "GPU"})\par
00035                 \{\par
00036                     CandidateSearchGPU.Search(spectraFile, databaseFile, settings);\par
00037                 \}\par
00038                 {\cf19 else}\par
00039                 \{\par
00040                     CandidateSearchCPU.Search(spectraFile, databaseFile, settings);\par
00041                 \}\par
00042 \par
00043                 {\cf19 return};\par
00044             \}\par
00045 \par
00046             Console.WriteLine({\cf22 "Incorrect number of arguments! CandidateSearch needs exactly 3 arguments: spectra.mgf database.fasta settings.txt"});\par
00047             {\cf19 return};\par
00048         \}\par
00049     \}\par
00050 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CandidateSearchCPU.cs\par \pard\plain 
{\bkmkstart AAAAAAAAAF}
{\bkmkend AAAAAAAAAF}
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf17 using }CandidateSearch.util;\par
00002 {\cf17 using }System.Diagnostics;\par
00003 \par
00004 {\cf17 namespace }CandidateSearch\par
00005 \{\par
00009     {\cf17 public} {\cf17 static} {\cf17 class }CandidateSearchCPU\par
00010     \{\par
00017         {\cf17 public} {\cf17 static} {\cf18 void} Search({\cf18 string} spectraFile, {\cf18 string} databaseFile, Settings settings)\par
00018         \{\par
00019             var spectra = MGFReader.readMGF(spectraFile);\par
00020             Console.WriteLine(${\cf22 "Read \{spectra.Count\} spectra."});\par
00021 \par
00022             var peptides = DatabaseReader.readFASTA(databaseFile, settings, generateDecoys: settings.DECOY_SEARCH);\par
00023             Console.WriteLine(${\cf22 "Generated \{peptides.Count\} peptides from fasta file."});\par
00024 \par
00025             {\cf20 // generating the candidateValues and candidateIdx arrays}\par
00026             {\cf18 int} candidateValuesLength = 0;\par
00027             {\cf19 foreach} (var peptide {\cf19 in} peptides)\par
00028             \{\par
00029                 var encoding = peptide.getEnconding();\par
00030                 candidateValuesLength += encoding.Length;\par
00031             \}\par
00032 \par
00033             var candidateValues = {\cf17 new} {\cf18 int}[candidateValuesLength];\par
00034             var candidateIdx = {\cf17 new} {\cf18 int}[peptides.Count];\par
00035 \par
00036             {\cf18 int} currentIdxCV = 0;\par
00037             {\cf18 int} currentIdxCI = 0;\par
00038             {\cf19 foreach} (var peptide {\cf19 in} peptides)\par
00039             \{\par
00040                 candidateIdx[currentIdxCI] = currentIdxCV;\par
00041                 currentIdxCI++;\par
00042                 var encoding = peptide.getEnconding();\par
00043                 {\cf19 foreach} (var value {\cf19 in} encoding)\par
00044                 \{\par
00045                     candidateValues[currentIdxCV] = value;\par
00046                     currentIdxCV++;\par
00047                 \}\par
00048             \}\par
00049 \par
00050             {\cf20 // generating the spectraValues and spectraIdx arrays}\par
00051             {\cf18 int} spectraValuesLength = 0;\par
00052             {\cf19 foreach} (var spectrum {\cf19 in} spectra)\par
00053             \{\par
00054                 var encoding = spectrum.getEncoding();\par
00055                 spectraValuesLength += encoding.Length;\par
00056             \}\par
00057 \par
00058             var spectraValues = {\cf17 new} {\cf18 int}[spectraValuesLength];\par
00059             var spectraIdx = {\cf17 new} {\cf18 int}[spectra.Count];\par
00060 \par
00061             {\cf18 int} currentIdxSV = 0;\par
00062             {\cf18 int} currentIdxSI = 0;\par
00063             {\cf19 foreach} (var spectrum {\cf19 in} spectra)\par
00064             \{\par
00065                 spectraIdx[currentIdxSI] = currentIdxSV;\par
00066                 currentIdxSI++;\par
00067                 var encoding = spectrum.getEncoding();\par
00068                 {\cf19 foreach} (var value {\cf19 in} encoding)\par
00069                 \{\par
00070                     spectraValues[currentIdxSV] = value;\par
00071                     currentIdxSV++;\par
00072                 \}\par
00073             \}\par
00074 \par
00075             var sw = {\cf17 new} Stopwatch();\par
00076             sw.Start();\par
00077 \par
00078             var result = VectorSearchInterface.VectorSearchAPI.searchCPU(ref candidateValues,\par
00079                                                                          ref candidateIdx,\par
00080                                                                          ref spectraValues,\par
00081                                                                          ref spectraIdx,\par
00082                                                                          topN: settings.TOP_N,\par
00083                                                                          tolerance: settings.TOLERANCE,\par
00084                                                                          normalize: settings.NORMALIZE,\par
00085                                                                          useGaussianTol: settings.USE_GAUSSIAN,\par
00086                                                                          batched: settings.MODE == {\cf22 "CPU_DM"} || settings.MODE == {\cf22 "CPU_SM"},\par
00087                                                                          batchSize: 100,\par
00088                                                                          useSparse: settings.MODE == {\cf22 "CPU_SV"} || settings.MODE == {\cf22 "CPU_SM"},\par
00089                                                                          cores: 0,\par
00090                                                                          verbose: 1000,\par
00091                                                                          memStat: out int memStat);\par
00092 \par
00093             sw.Stop();\par
00094 \par
00095             Console.WriteLine(${\cf22 "CPU search finished with code \{memStat\}. Search took \{sw.Elapsed.TotalSeconds\} seconds."});\par
00096 \par
00097             var processedResult = {\cf17 new} Result(ref result, ref peptides, ref spectra, TopN: settings.TOP_N);\par
00098             var csvStat = processedResult.export(spectraFile + {\cf22 "_results.csv"});\par
00099 \par
00100             Console.WriteLine(${\cf22 "Result file written to disk with code \{csvStat\}. Search finished!"});\par
00101 \par
00102             {\cf19 return};\par
00103         \}\par
00104     \}\par
00105 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CandidateSearchGPU.cs\par \pard\plain 
{\bkmkstart AAAAAAAAAG}
{\bkmkend AAAAAAAAAG}
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf17 using }CandidateSearch.util;\par
00002 {\cf17 using }System.Diagnostics;\par
00003 \par
00004 {\cf17 namespace }CandidateSearch\par
00005 \{\par
00009     {\cf17 public} {\cf17 static} {\cf17 class }CandidateSearchGPU\par
00010     \{\par
00017         {\cf17 public} {\cf17 static} {\cf18 void} Search({\cf18 string} spectraFile, {\cf18 string} databaseFile, Settings settings)\par
00018         \{\par
00019             var spectra = MGFReader.readMGF(spectraFile);\par
00020             Console.WriteLine(${\cf22 "Read \{spectra.Count\} spectra."});\par
00021 \par
00022             var peptides = DatabaseReader.readFASTA(databaseFile, settings, generateDecoys: settings.DECOY_SEARCH);\par
00023             Console.WriteLine(${\cf22 "Generated \{peptides.Count\} peptides from fasta file."});\par
00024 \par
00025             {\cf20 // generating the csrColIdx and csrRowoffsets arrays}\par
00026             {\cf18 int} csrColIdxLength = 0;\par
00027             {\cf19 foreach} (var peptide {\cf19 in} peptides)\par
00028             \{\par
00029                 var encoding = peptide.getEnconding();\par
00030                 csrColIdxLength += encoding.Length;\par
00031             \}\par
00032 \par
00033             var csrColIdx = {\cf17 new} {\cf18 int}[csrColIdxLength];\par
00034             var csrRowoffsets = {\cf17 new} {\cf18 int}[peptides.Count + 1];\par
00035 \par
00036             {\cf18 int} currentIdxCsrColIdx = 0;\par
00037             {\cf18 int} currentIdxCsrRowoffsets = 0;\par
00038             {\cf19 foreach} (var peptide {\cf19 in} peptides)\par
00039             \{\par
00040                 csrRowoffsets[currentIdxCsrRowoffsets] = currentIdxCsrColIdx;\par
00041                 currentIdxCsrRowoffsets++;\par
00042                 var encoding = peptide.getEnconding();\par
00043                 {\cf19 foreach} (var value {\cf19 in} encoding)\par
00044                 \{\par
00045                     csrColIdx[currentIdxCsrColIdx] = value;\par
00046                     currentIdxCsrColIdx++;\par
00047                 \}\par
00048             \}\par
00049 \par
00050             csrRowoffsets[peptides.Count] = csrColIdxLength;\par
00051 \par
00052             {\cf20 // generating the spectraValues and spectraIdx arrays}\par
00053             {\cf18 int} spectraValuesLength = 0;\par
00054             {\cf19 foreach} (var spectrum {\cf19 in} spectra)\par
00055             \{\par
00056                 var encoding = spectrum.getEncoding();\par
00057                 spectraValuesLength += encoding.Length;\par
00058             \}\par
00059 \par
00060             var spectraValues = {\cf17 new} {\cf18 int}[spectraValuesLength];\par
00061             var spectraIdx = {\cf17 new} {\cf18 int}[spectra.Count];\par
00062 \par
00063             {\cf18 int} currentIdxSV = 0;\par
00064             {\cf18 int} currentIdxSI = 0;\par
00065             {\cf19 foreach} (var spectrum {\cf19 in} spectra)\par
00066             \{\par
00067                 spectraIdx[currentIdxSI] = currentIdxSV;\par
00068                 currentIdxSI++;\par
00069                 var encoding = spectrum.getEncoding();\par
00070                 {\cf19 foreach} (var value {\cf19 in} encoding)\par
00071                 \{\par
00072                     spectraValues[currentIdxSV] = value;\par
00073                     currentIdxSV++;\par
00074                 \}\par
00075             \}\par
00076 \par
00077             var sw = {\cf17 new} Stopwatch();\par
00078             sw.Start();\par
00079 \par
00080             var result = VectorSearchInterface.VectorSearchAPI.searchGPU(ref csrRowoffsets,\par
00081                                                                          ref csrColIdx,\par
00082                                                                          ref spectraValues,\par
00083                                                                          ref spectraIdx,\par
00084                                                                          topN: settings.TOP_N,\par
00085                                                                          tolerance: settings.TOLERANCE,\par
00086                                                                          normalize: settings.NORMALIZE,\par
00087                                                                          useGaussianTol: settings.USE_GAUSSIAN,\par
00088                                                                          batched: settings.MODE == {\cf22 "GPU_DM"} || settings.MODE == {\cf22 "GPU_SM"},\par
00089                                                                          batchSize: 100,\par
00090                                                                          useSparse: settings.MODE == {\cf22 "GPU_SM"},\par
00091                                                                          verbose: 1000,\par
00092                                                                          memStat: out int memStat);\par
00093 \par
00094             sw.Stop();\par
00095 \par
00096             Console.WriteLine(${\cf22 "GPU search finished with code \{memStat\}. Search took \{sw.Elapsed.TotalSeconds\} seconds."});\par
00097 \par
00098             var processedResult = {\cf17 new} Result(ref result, ref peptides, ref spectra, TopN: settings.TOP_N);\par
00099             var csvStat = processedResult.export(spectraFile + {\cf22 "_results.csv"});\par
00100 \par
00101             Console.WriteLine(${\cf22 "Result file written to disk with code \{csvStat\}. Search finished!"});\par
00102 \par
00103             {\cf19 return};\par
00104         \}\par
00105     \}\par
00106 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
VectorSearchAPI.cs\par \pard\plain 
{\tc\tcl2 \v dll/VectorSearchAPI.cs}
{\xe \v dll/VectorSearchAPI.cs}
{\bkmkstart AAAAAAAAAH}
{\bkmkend AAAAAAAAAH}
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf17 using }System.Runtime.InteropServices;\par
00002 \par
00003 {\cf17 namespace }VectorSearchInterface\par
00004 \{\par
00005     {\cf17 public} {\cf17 class }VectorSearchAPI\par
00006     \{\par
00007         {\cf17 const} {\cf18 string} dllCPU = {\cf22 @"VectorSearch.dll"};\par
00008         {\cf17 const} {\cf18 string} dllGPU = {\cf22 @"VectorSearchCUDA.dll"};\par
00009 \par
00010 {\cf21         #region VectorSearch.dll_import}\par
00011 \par
00012         [DllImport(dllCPU, CallingConvention = CallingConvention.Cdecl)]\par
00013         {\cf17 private} {\cf17 static} {\cf17 extern} IntPtr findTopCandidates(IntPtr cV, IntPtr cI, IntPtr sV, IntPtr sI,\par
00014                                                        {\cf18 int} cVL, {\cf18 int} cIL, {\cf18 int} sVL, {\cf18 int} sIL,\par
00015                                                        {\cf18 int} n, {\cf18 float} tolerance,\par
00016                                                        {\cf18 bool} normalize, {\cf18 bool} gaussianTol,\par
00017                                                        {\cf18 int} cores, {\cf18 int} verbose);\par
00018 \par
00019         [DllImport(dllCPU, CallingConvention = CallingConvention.Cdecl)]\par
00020         {\cf17 private} {\cf17 static} {\cf17 extern} IntPtr findTopCandidatesBatched(IntPtr cV, IntPtr cI, IntPtr sV, IntPtr sI,\par
00021                                                               {\cf18 int} cVL, {\cf18 int} cIL, {\cf18 int} sVL, {\cf18 int} sIL,\par
00022                                                               {\cf18 int} n, {\cf18 float} tolerance,\par
00023                                                               {\cf18 bool} normalize, {\cf18 bool} gaussianTol,\par
00024                                                               {\cf18 int} batchSize,\par
00025                                                               {\cf18 int} cores, {\cf18 int} verbose);\par
00026 \par
00027         [DllImport(dllCPU, CallingConvention = CallingConvention.Cdecl)]\par
00028         {\cf17 private} {\cf17 static} {\cf17 extern} IntPtr findTopCandidates2(IntPtr cV, IntPtr cI, IntPtr sV, IntPtr sI,\par
00029                                                         {\cf18 int} cVL, {\cf18 int} cIL, {\cf18 int} sVL, {\cf18 int} sIL,\par
00030                                                         {\cf18 int} n, {\cf18 float} tolerance,\par
00031                                                         {\cf18 bool} normalize, {\cf18 bool} gaussianTol,\par
00032                                                         {\cf18 int} cores, {\cf18 int} verbose);\par
00033 \par
00034         [DllImport(dllCPU, CallingConvention = CallingConvention.Cdecl)]\par
00035         {\cf17 private} {\cf17 static} {\cf17 extern} IntPtr findTopCandidatesBatched2(IntPtr cV, IntPtr cI, IntPtr sV, IntPtr sI,\par
00036                                                                {\cf18 int} cVL, {\cf18 int} cIL, {\cf18 int} sVL, {\cf18 int} sIL,\par
00037                                                                {\cf18 int} n, {\cf18 float} tolerance,\par
00038                                                                {\cf18 bool} normalize, {\cf18 bool} gaussianTol,\par
00039                                                                {\cf18 int} batchSize,\par
00040                                                                {\cf18 int} cores, {\cf18 int} verbose);\par
00041 \par
00042         [DllImport(dllCPU, CallingConvention = CallingConvention.Cdecl)]\par
00043         {\cf17 private} {\cf17 static} {\cf17 extern} {\cf18 int} releaseMemory(IntPtr result);\par
00044 \par
00045 {\cf21         #endregion}\par
00046 \par
00047 {\cf21         #region VectorSearchCUDA.dll_import}\par
00048 \par
00049         [DllImport(dllGPU, CallingConvention = CallingConvention.Cdecl)]\par
00050         {\cf17 private} {\cf17 static} {\cf17 extern} IntPtr findTopCandidatesCuda(IntPtr cR, IntPtr cI, IntPtr sV, IntPtr sI,\par
00051                                                            {\cf18 int} cRL, {\cf18 int} cNNZ, {\cf18 int} sVL, {\cf18 int} sIL,\par
00052                                                            {\cf18 int} n, {\cf18 float} tolerance,\par
00053                                                            {\cf18 bool} normalize, {\cf18 bool} gaussianTol,\par
00054                                                            {\cf18 int} verbose);\par
00055 \par
00056         [DllImport(dllGPU, CallingConvention = CallingConvention.Cdecl)]\par
00057         {\cf17 private} {\cf17 static} {\cf17 extern} IntPtr findTopCandidatesCudaBatched(IntPtr cR, IntPtr cI, IntPtr sV, IntPtr sI,\par
00058                                                                   {\cf18 int} cRL, {\cf18 int} cNNZ, {\cf18 int} sVL, {\cf18 int} sIL,\par
00059                                                                   {\cf18 int} n, {\cf18 float} tolerance,\par
00060                                                                   {\cf18 bool} normalize, {\cf18 bool} gaussianTol,\par
00061                                                                   {\cf18 int} batchSize,\par
00062                                                                   {\cf18 int} verbose);\par
00063 \par
00064         [DllImport(dllGPU, CallingConvention = CallingConvention.Cdecl)]\par
00065         {\cf17 private} {\cf17 static} {\cf17 extern} IntPtr findTopCandidatesCudaBatched2(IntPtr cR, IntPtr cI, IntPtr sV, IntPtr sI,\par
00066                                                                    {\cf18 int} cRL, {\cf18 int} cNNZ, {\cf18 int} sVL, {\cf18 int} sIL,\par
00067                                                                    {\cf18 int} n, {\cf18 float} tolerance,\par
00068                                                                    {\cf18 bool} normalize, {\cf18 bool} gaussianTol,\par
00069                                                                    {\cf18 int} batchSize,\par
00070                                                                    {\cf18 int} verbose);\par
00071 \par
00072         [DllImport(dllGPU, CallingConvention = CallingConvention.Cdecl)]\par
00073         {\cf17 private} {\cf17 static} {\cf17 extern} {\cf18 int} releaseMemoryCuda(IntPtr result);\par
00074 \par
00075 {\cf21         #endregion}\par
00076 \par
00077 {\cf21         #region CPU_search}\par
00078 \par
00097         {\cf17 public} {\cf17 static} {\cf18 int}[] searchCPU(ref {\cf18 int}[] candidatesValues, ref {\cf18 int}[] candidatesIdx, ref {\cf18 int}[] spectraValues, ref {\cf18 int}[] spectraIdx,\par
00098                                       {\cf18 int} topN, {\cf18 float} tolerance, {\cf18 bool} normalize, {\cf18 bool} useGaussianTol,\par
00099                                       {\cf18 bool} batched, {\cf18 int} batchSize, {\cf18 bool} useSparse, {\cf18 int} cores, {\cf18 int} verbose,\par
00100                                       out {\cf18 int} memStat)\par
00101         \{\par
00102             var cValuesLoc = GCHandle.Alloc(candidatesValues, GCHandleType.Pinned);\par
00103             var cIdxLoc = GCHandle.Alloc(candidatesIdx, GCHandleType.Pinned);\par
00104             var sValuesLoc = GCHandle.Alloc(spectraValues, GCHandleType.Pinned);\par
00105             var sIdxLoc = GCHandle.Alloc(spectraIdx, GCHandleType.Pinned);\par
00106 \par
00107             {\cf18 int} cVLength = candidatesValues.Length;\par
00108             {\cf18 int} cILength = candidatesIdx.Length;\par
00109             {\cf18 int} sVLength = spectraValues.Length;\par
00110             {\cf18 int} sILength = spectraIdx.Length;\par
00111 \par
00112             var resultArray = {\cf17 new} {\cf18 int}[sILength * topN];\par
00113 \par
00114             memStat = 1;\par
00115 \par
00116             {\cf19 try}\par
00117             \{\par
00118                 IntPtr cValuesPtr = cValuesLoc.AddrOfPinnedObject();\par
00119                 IntPtr cIdxPtr = cIdxLoc.AddrOfPinnedObject();\par
00120                 IntPtr sValuesPtr = sValuesLoc.AddrOfPinnedObject();\par
00121                 IntPtr sIdxPtr = sIdxLoc.AddrOfPinnedObject();\par
00122 \par
00123                 {\cf19 if} (!batched && useSparse)\par
00124                 \{\par
00125                     IntPtr result = findTopCandidates(cValuesPtr, cIdxPtr, sValuesPtr, sIdxPtr,\par
00126                                                       cVLength, cILength, sVLength, sILength,\par
00127                                                       topN, tolerance, normalize, useGaussianTol,\par
00128                                                       cores, verbose);\par
00129 \par
00130                     Marshal.Copy(result, resultArray, 0, sILength * topN);\par
00131 \par
00132                     memStat = releaseMemory(result);\par
00133                 \}\par
00134                 {\cf19 else} {\cf19 if} (!batched && !useSparse)\par
00135                 \{\par
00136                     IntPtr result = findTopCandidates2(cValuesPtr, cIdxPtr, sValuesPtr, sIdxPtr,\par
00137                                                        cVLength, cILength, sVLength, sILength,\par
00138                                                        topN, tolerance, normalize, useGaussianTol,\par
00139                                                        cores, verbose);\par
00140 \par
00141                     Marshal.Copy(result, resultArray, 0, sILength * topN);\par
00142 \par
00143                     memStat = releaseMemory(result);\par
00144                 \}\par
00145                 {\cf19 else} {\cf19 if} (batched && useSparse)\par
00146                 \{\par
00147                     IntPtr result = findTopCandidatesBatched(cValuesPtr, cIdxPtr, sValuesPtr, sIdxPtr,\par
00148                                                              cVLength, cILength, sVLength, sILength,\par
00149                                                              topN, tolerance, normalize, useGaussianTol, batchSize,\par
00150                                                              cores, verbose);\par
00151 \par
00152                     Marshal.Copy(result, resultArray, 0, sILength * topN);\par
00153 \par
00154                     memStat = releaseMemory(result);\par
00155                 \}\par
00156                 {\cf19 else} {\cf19 if} (batched && !useSparse)\par
00157                 \{\par
00158                     IntPtr result = findTopCandidatesBatched2(cValuesPtr, cIdxPtr, sValuesPtr, sIdxPtr,\par
00159                                                               cVLength, cILength, sVLength, sILength,\par
00160                                                               topN, tolerance, normalize, useGaussianTol, batchSize,\par
00161                                                               cores, verbose);\par
00162 \par
00163                     Marshal.Copy(result, resultArray, 0, sILength * topN);\par
00164 \par
00165                     memStat = releaseMemory(result);\par
00166                 \}\par
00167                 {\cf19 else}\par
00168                 \{\par
00169                     Console.WriteLine({\cf22 "Impossible case!"});\par
00170                 \}\par
00171             \}\par
00172             {\cf19 catch} (Exception ex)\par
00173             \{\par
00174                 Console.WriteLine({\cf22 "Something went wrong:"});\par
00175                 Console.WriteLine(ex.ToString());\par
00176                 memStat = 1;\par
00177             \}\par
00178             {\cf19 finally}\par
00179             \{\par
00180                 {\cf19 if} (cValuesLoc.IsAllocated) \{ cValuesLoc.Free(); \}\par
00181                 {\cf19 if} (cIdxLoc.IsAllocated) \{ cIdxLoc.Free(); \}\par
00182                 {\cf19 if} (sValuesLoc.IsAllocated) \{ sValuesLoc.Free(); \}\par
00183                 {\cf19 if} (sIdxLoc.IsAllocated) \{ sIdxLoc.Free(); \}\par
00184             \}\par
00185 \par
00186             {\cf19 return} resultArray;\par
00187         \}\par
00188 \par
00189 {\cf21         #endregion}\par
00190 \par
00191 {\cf21         #region GPU_search}\par
00192 \par
00210         {\cf17 public} {\cf17 static} {\cf18 int}[] searchGPU(ref {\cf18 int}[] csrRowoffsets, ref {\cf18 int}[] csrColIdx, ref {\cf18 int}[] spectraValues, ref {\cf18 int}[] spectraIdx,\par
00211                                       {\cf18 int} topN, {\cf18 float} tolerance, {\cf18 bool} normalize, {\cf18 bool} useGaussianTol,\par
00212                                       {\cf18 bool} batched, {\cf18 int} batchSize, {\cf18 bool} useSparse, {\cf18 int} verbose,\par
00213                                       out {\cf18 int} memStat)\par
00214         \{\par
00215             var csrRowoffsetsLoc = GCHandle.Alloc(csrRowoffsets, GCHandleType.Pinned);\par
00216             var csrIdxLoc = GCHandle.Alloc(csrColIdx, GCHandleType.Pinned);\par
00217             var sValuesLoc = GCHandle.Alloc(spectraValues, GCHandleType.Pinned);\par
00218             var sIdxLoc = GCHandle.Alloc(spectraIdx, GCHandleType.Pinned);\par
00219 \par
00220             {\cf18 int} cRLength = csrRowoffsets.Length;\par
00221             {\cf18 int} cILength = csrColIdx.Length;\par
00222             {\cf18 int} sVLength = spectraValues.Length;\par
00223             {\cf18 int} sILength = spectraIdx.Length;\par
00224 \par
00225             var resultArray = {\cf17 new} {\cf18 int}[sILength * topN];\par
00226 \par
00227             memStat = 1;\par
00228 \par
00229             {\cf19 try}\par
00230             \{\par
00231                 IntPtr csrRowoffsetsPtr = csrRowoffsetsLoc.AddrOfPinnedObject();\par
00232                 IntPtr csrIdxPtr = csrIdxLoc.AddrOfPinnedObject();\par
00233                 IntPtr sValuesPtr = sValuesLoc.AddrOfPinnedObject();\par
00234                 IntPtr sIdxPtr = sIdxLoc.AddrOfPinnedObject();\par
00235 \par
00236                 {\cf19 if} (!batched)\par
00237                 \{\par
00238                     IntPtr result = findTopCandidatesCuda(csrRowoffsetsPtr, csrIdxPtr, sValuesPtr, sIdxPtr,\par
00239                                                           cRLength, cILength, sVLength, sILength,\par
00240                                                           topN, tolerance, normalize, useGaussianTol,\par
00241                                                           verbose);\par
00242 \par
00243                     Marshal.Copy(result, resultArray, 0, sILength * topN);\par
00244 \par
00245                     memStat = releaseMemoryCuda(result);\par
00246                 \}\par
00247                 {\cf19 else}\par
00248                 \{\par
00249                     {\cf19 if} (!useSparse)\par
00250                     \{\par
00251                         IntPtr result = findTopCandidatesCudaBatched2(csrRowoffsetsPtr, csrIdxPtr, sValuesPtr, sIdxPtr,\par
00252                                                                       cRLength, cILength, sVLength, sILength,\par
00253                                                                       topN, tolerance, normalize, useGaussianTol, batchSize,\par
00254                                                                       verbose);\par
00255 \par
00256                         Marshal.Copy(result, resultArray, 0, sILength * topN);\par
00257 \par
00258                         memStat = releaseMemoryCuda(result);\par
00259                     \}\par
00260                     {\cf19 else}\par
00261                     \{\par
00262 \par
00263 \par
00264                         IntPtr result = findTopCandidatesCudaBatched(csrRowoffsetsPtr, csrIdxPtr, sValuesPtr, sIdxPtr,\par
00265                                                                      cRLength, cILength, sVLength, sILength,\par
00266                                                                      topN, tolerance, normalize, useGaussianTol, batchSize,\par
00267                                                                      verbose);\par
00268 \par
00269                         Marshal.Copy(result, resultArray, 0, sILength * topN);\par
00270 \par
00271                         memStat = releaseMemoryCuda(result);\par
00272                     \}\par
00273                 \}\par
00274             \}\par
00275             {\cf19 catch} (Exception ex)\par
00276             \{\par
00277                 Console.WriteLine({\cf22 "Something went wrong:"});\par
00278                 Console.WriteLine(ex.ToString());\par
00279                 memStat = 1;\par
00280             \}\par
00281             {\cf19 finally}\par
00282             \{\par
00283                 {\cf19 if} (csrRowoffsetsLoc.IsAllocated) \{ csrRowoffsetsLoc.Free(); \}\par
00284                 {\cf19 if} (csrIdxLoc.IsAllocated) \{ csrIdxLoc.Free(); \}\par
00285                 {\cf19 if} (sValuesLoc.IsAllocated) \{ sValuesLoc.Free(); \}\par
00286                 {\cf19 if} (sIdxLoc.IsAllocated) \{ sIdxLoc.Free(); \}\par
00287             \}\par
00288 \par
00289             {\cf19 return} resultArray;\par
00290         \}\par
00291 \par
00292 {\cf21         #endregion}\par
00293     \}\par
00294 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Database.cs\par \pard\plain 
{\tc\tcl2 \v util/Database.cs}
{\xe \v util/Database.cs}
{\bkmkstart AAAAAAAAAI}
{\bkmkend AAAAAAAAAI}
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf17 using }System.Text;\par
00002 \par
00003 {\cf17 namespace }CandidateSearch.util\par
00004 \{\par
00008     {\cf17 public} {\cf17 class }Peptide\par
00009     \{\par
00013         {\cf17 public} {\cf18 string} sequence \{ {\cf17 get}; \}\par
00017         {\cf17 public} {\cf18 double} mass \{ {\cf17 get}; \}\par
00021         {\cf17 public} Dictionary<int, double> modifications \{ {\cf17 get}; \}\par
00025         {\cf17 public} {\cf18 bool} isDecoy \{ {\cf17 get}; \}\par
00029         {\cf17 public} List<double> ions \{ {\cf17 get}; \}\par
00030 \par
00039         {\cf17 public} Peptide({\cf18 string} Sequence, {\cf18 double} Mass, Dictionary<int, double> Modifications, Settings IonSettings, {\cf18 bool} IsDecoy)\par
00040         \{\par
00041             sequence = Sequence;\par
00042             mass = Mass;\par
00043             modifications = Modifications;\par
00044             isDecoy = IsDecoy;\par
00045             ions = getIons(Sequence, Mass, Modifications, IonSettings);\par
00046         \}\par
00047 \par
00054         {\cf17 public} {\cf18 int}[] getEnconding({\cf18 int} massRange = 5000, {\cf18 int} massMultiplier = 100)\par
00055         \{\par
00056             var encoding = {\cf17 new} List<int>();\par
00057 \par
00058             {\cf19 foreach} (var ion {\cf19 in} ions)\par
00059             \{\par
00060                 {\cf19 if} (ion < massRange)\par
00061                 \{\par
00062                     encoding.Add(({\cf18 int}) Math.Round(ion * massMultiplier));\par
00063                 \}\par
00064             \}\par
00065 \par
00066             {\cf19 return} encoding.ToArray();\par
00067         \}\par
00068 \par
00073         {\cf17 public} {\cf17 override} {\cf18 string} ToString()\par
00074         \{\par
00075             {\cf18 string} peptide = sequence + {\cf22 "["};\par
00076             {\cf19 foreach} (var modification {\cf19 in} modifications)\par
00077             \{\par
00078                 peptide = peptide + ${\cf22 "\{modification.Key\}:\{modification.Value\}+"};\par
00079             \}\par
00080 \par
00081             peptide = peptide.TrimEnd({\cf17 new} {\cf18 char}[] \{{\cf23 '+'}\});\par
00082 \par
00083             {\cf19 if} (isDecoy)\par
00084             \{\par
00085                 {\cf19 return} {\cf22 "_"} + peptide + {\cf22 "]"};\par
00086             \}\par
00087 \par
00088             {\cf19 return} peptide + {\cf22 "]"};\par
00089         \}\par
00090 \par
00097         {\cf17 public} {\cf18 bool} addModification({\cf18 int} position, {\cf18 double} mass)\par
00098         \{\par
00099             {\cf19 if} (modifications.ContainsKey(position))\par
00100                 {\cf19 return} {\cf17 false};\par
00101 \par
00102             modifications.Add(position, mass);\par
00103             {\cf19 return} {\cf17 true};\par
00104         \}\par
00105 \par
00114         {\cf17 private} List<double> getIons({\cf18 string} Sequence, {\cf18 double} Mass, Dictionary<int, double> Modifications, Settings IonSettings)\par
00115         \{\par
00116             var ions = {\cf17 new} List<double>();\par
00117 \par
00118             {\cf18 double}[] outIonsNoNL;\par
00119             MSAMANDA_IONCALCULATION.IonWithNL[] outIonsWithNL;\par
00120             MSAMANDA_IONCALCULATION.Modification[] mods = {\cf17 new} MSAMANDA_IONCALCULATION.Modification[sequence.Length + 2];\par
00121             {\cf19 foreach} (var mod {\cf19 in} Modifications)\par
00122             \{\par
00123                 mods[mod.Key + 1] = {\cf17 new} MSAMANDA_IONCALCULATION.Modification(title: mod.Key.ToString() + {\cf22 ":"} + mod.Value.ToString(),\par
00124                                                                              name: mod.Key.ToString() + {\cf22 ":"} + mod.Value.ToString(),\par
00125                                                                              mono: mod.Value,\par
00126                                                                              avg: mod.Value,\par
00127                                                                              aa: Sequence[mod.Key],\par
00128                                                                              fix: true, {\cf20 // this should technically be true/false depending on modification}\par
00129                                                                              neutralLosses: new double[0],\par
00130                                                                              nTerminal: false,\par
00131                                                                              cTerminal: false,\par
00132                                                                              id: mod.Key.GetHashCode() + mod.Value.GetHashCode(),\par
00133                                                                              protein: false,\par
00134                                                                              maxOccurrence: 3);\par
00135             \}\par
00136             MSAMANDA_IONCALCULATION.IonCalculator.CalculateIons(out outIonsNoNL, \par
00137                                                                 out outIonsWithNL, \par
00138                                                                 sequence: Encoding.ASCII.GetBytes(Sequence),\par
00139                                                                 mass: Mass,\par
00140                                                                 charge: IonSettings.MAX_PRECURSOR_CHARGE,\par
00141                                                                 mods: mods,\par
00142                                                                 maxNumberNeutralLoss: IonSettings.MAX_NEUTRAL_LOSSES,\par
00143                                                                 maxNumberNeutralLossModifications: IonSettings.MAX_NEUTRAL_LOSS_MODS,\par
00144                                                                 lowerBound: 0,\par
00145                                                                 upperBound: 5000,\par
00146                                                                 mono: true,\par
00147                                                                 maxAllowedChargeState: IonSettings.MAX_FRAGMENT_CHARGE);\par
00148 \par
00149             ions.AddRange(outIonsNoNL);\par
00150 \par
00151             {\cf19 return} ions.Distinct().OrderBy(x => x).ToList();\par
00152         \}\par
00153     \}\par
00154 \par
00158     {\cf17 public} {\cf17 static} {\cf17 class }DatabaseReader\par
00159     \{\par
00167         {\cf17 public} {\cf17 static} List<Peptide> readFASTA({\cf18 string} filename, Settings settings, {\cf18 bool} generateDecoys = {\cf17 false})\par
00168         \{\par
00169             {\cf20 // digestion parameters set in method}\par
00170             {\cf19 return} MSAMANDA_FASTAPARSER.FASTAParser.DigestFasta(filename, settings, generateDecoys);\par
00171         \}\par
00172     \}\par
00173 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Result.cs\par \pard\plain 
{\tc\tcl2 \v util/Result.cs}
{\xe \v util/Result.cs}
{\bkmkstart AAAAAAAAAJ}
{\bkmkend AAAAAAAAAJ}
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf17 namespace }CandidateSearch.util\par
00002 \{\par
00006     {\cf17 public} {\cf17 class }Result\par
00007     \{\par
00011         {\cf17 public} Dictionary<int, List<Peptide>> result \{ {\cf17 get}; \}\par
00012 \par
00020         {\cf17 public} Result(ref {\cf18 int}[] SearchResult, ref List<Peptide> Peptides, ref List<Spectrum> Spectra, {\cf18 int} TopN) \{\par
00021             \par
00022             result = {\cf17 new} Dictionary<int, List<Peptide>>();\par
00023             \par
00024             {\cf18 int} currentSearchResultIdx = 0;\par
00025             {\cf19 foreach} (var spectrum {\cf19 in} Spectra)\par
00026             \{\par
00027                 {\cf19 if} (!result.ContainsKey(spectrum.scanNumber))\par
00028                 \{\par
00029                     result.Add(spectrum.scanNumber, {\cf17 new} List<Peptide>());\par
00030                     {\cf19 for} ({\cf18 int} i = currentSearchResultIdx; i < currentSearchResultIdx + TopN; i++)\par
00031                     \{\par
00032                         result[spectrum.scanNumber].Add(Peptides[SearchResult[i]]);\par
00033                     \}\par
00034                 \}\par
00035                 {\cf19 else}\par
00036                 \{\par
00037                     Console.WriteLine(${\cf22 "Warning: Found duplicate scan number \{spectrum.scanNumber\}. Skipping scan number..."});\par
00038                 \}\par
00039 \par
00040                 currentSearchResultIdx += TopN;\par
00041             \}\par
00042         \}\par
00043 \par
00049         {\cf17 public} {\cf18 int} export({\cf18 string} filename)\par
00050         \{\par
00051             {\cf18 int} status;\par
00052 \par
00053             {\cf19 try}\par
00054             \{\par
00055                 var lines = {\cf17 new} List<string>()\{{\cf22 "ScanNumber;Peptides"}\};\par
00056                 {\cf19 foreach} (var item {\cf19 in} result) \{\par
00057                     var scanNr = item.Key;\par
00058                     var peptides = item.Value;\par
00059                     var line = scanNr.ToString() + {\cf22 ";"};\par
00060                     {\cf19 foreach} (var peptide {\cf19 in} peptides)\par
00061                     \{\par
00062                         line += (peptide.ToString() + {\cf22 ","});\par
00063                     \}\par
00064                     lines.Add(line);\par
00065                 \}\par
00066 \par
00067                 {\cf17 using} (StreamWriter sw = {\cf17 new} StreamWriter(filename))\par
00068                 \{\par
00069                     {\cf19 foreach} (var line {\cf19 in} lines)\par
00070                     \{\par
00071                         sw.WriteLine(line);\par
00072                     \}\par
00073                 \}\par
00074 \par
00075                 status = 0;\par
00076             \}\par
00077             {\cf19 catch} (Exception ex)\par
00078             \{\par
00079                 Console.WriteLine({\cf22 "Something went wrong:"});\par
00080                 Console.WriteLine(ex.ToString());\par
00081                 status = 1;\par
00082             \}\par
00083 \par
00084             {\cf19 return} status;\par
00085         \}\par
00086     \}\par
00087 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Settings.cs\par \pard\plain 
{\tc\tcl2 \v util/Settings.cs}
{\xe \v util/Settings.cs}
{\bkmkstart AAAAAAAAAK}
{\bkmkend AAAAAAAAAK}
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf17 using }System.Text;\par
00002 \par
00003 {\cf17 namespace }CandidateSearch.util\par
00004 \{\par
00008     {\cf17 public} {\cf17 class }Settings\par
00009     \{\par
00010         {\cf20 // config digestion}\par
00014         {\cf17 public} {\cf18 int} MAX_CLEAVAGES \{ {\cf17 get}; {\cf17 set}; \} {\cf20 // default: 2}\par
00018         {\cf17 public} {\cf18 int} MIN_PEP_LENGTH \{ {\cf17 get}; {\cf17 set}; \} {\cf20 // default: 5}\par
00022         {\cf17 public} {\cf18 int} MAX_PEP_LENGTH \{ {\cf17 get}; {\cf17 set}; \} {\cf20 // default: 30}\par
00023 \par
00024         {\cf20 // config ion calculation}\par
00028         {\cf17 public} {\cf18 int} MAX_PRECURSOR_CHARGE \{ {\cf17 get}; {\cf17 set}; \} {\cf20 // default: 4}\par
00032         {\cf17 public} {\cf18 string} MAX_FRAGMENT_CHARGE \{ {\cf17 get}; {\cf17 set}; \} {\cf20 // default: "+1";}\par
00036         {\cf17 public} {\cf18 int} MAX_NEUTRAL_LOSSES \{ {\cf17 get}; {\cf17 set}; \} {\cf20 // default: 1}\par
00040         {\cf17 public} {\cf18 int} MAX_NEUTRAL_LOSS_MODS \{ {\cf17 get}; {\cf17 set}; \} {\cf20 // default: 2}\par
00044         {\cf17 public} Dictionary<string, double> FIXED_MODIFICATIONS \{ {\cf17 get}; {\cf17 set}; \} {\cf20 // default: empty Dictionary}\par
00048         {\cf17 public} Dictionary<string, double> VARIABLE_MODIFICATIONS \{ {\cf17 get}; {\cf17 set}; \} {\cf20 // default: empty Dictionary}\par
00049 \par
00050         {\cf20 // config search parameters}\par
00054         {\cf17 public} {\cf18 bool} DECOY_SEARCH \{ {\cf17 get}; {\cf17 set}; \} {\cf20 // default: true}\par
00055 \par
00056         {\cf20 // config vector search}\par
00060         {\cf17 public} {\cf18 int} TOP_N \{ {\cf17 get}; {\cf17 set}; \} {\cf20 // default: 1000}\par
00064         {\cf17 public} {\cf18 float} TOLERANCE \{ {\cf17 get}; {\cf17 set}; \} {\cf20 // default: 0.02f}\par
00068         {\cf17 public} {\cf18 bool} NORMALIZE \{ {\cf17 get}; {\cf17 set}; \} {\cf20 // default: false}\par
00072         {\cf17 public} {\cf18 bool} USE_GAUSSIAN \{ {\cf17 get}; {\cf17 set}; \} {\cf20 // default: true}\par
00076         {\cf17 public} {\cf18 string} MODE \{ {\cf17 get}; {\cf17 set}; \} {\cf20 // default: CPU_DV}\par
00077 \par
00094         {\cf17 public} Settings({\cf18 int} MaxCleavages = 2, {\cf18 int} MinPepLength = 5, {\cf18 int} MaxPepLength = 30, \par
00095                         {\cf18 int} MaxPrecursorCharge = 4, {\cf18 string} MaxFragmentCharge = {\cf22 "+1"}, {\cf18 int} MaxNeutralLosses = 1, {\cf18 int} MaxNeutralLossMods = 2,\par
00096                         {\cf18 bool} DecoySearch = {\cf17 true},\par
00097                         {\cf18 int} TopN = 1000, {\cf18 float} Tolerance = 0.02f, {\cf18 bool} Normalize = {\cf17 false}, {\cf18 bool} UseGaussian = {\cf17 true}, {\cf18 string} Mode = {\cf22 "CPU_DV"})\par
00098         \{\par
00099             MAX_CLEAVAGES = MaxCleavages;\par
00100             MIN_PEP_LENGTH = MinPepLength;\par
00101             MAX_PEP_LENGTH = MaxPepLength;\par
00102 \par
00103             MAX_PRECURSOR_CHARGE = MaxPrecursorCharge;\par
00104             MAX_FRAGMENT_CHARGE = MaxFragmentCharge;\par
00105             MAX_NEUTRAL_LOSSES = MaxNeutralLosses;\par
00106             MAX_NEUTRAL_LOSS_MODS = MaxNeutralLossMods;\par
00107             FIXED_MODIFICATIONS = {\cf17 new} Dictionary<string, double>();\par
00108             VARIABLE_MODIFICATIONS = {\cf17 new} Dictionary<string, double>();\par
00109 \par
00110             DECOY_SEARCH = DecoySearch;\par
00111 \par
00112             TOP_N = TopN;\par
00113             TOLERANCE = Tolerance;\par
00114             NORMALIZE = Normalize;\par
00115             USE_GAUSSIAN = UseGaussian;\par
00116             MODE = Mode;\par
00117         \}\par
00118 \par
00125         {\cf17 public} {\cf18 bool} addFixedModification({\cf18 string} aminoAcid, {\cf18 double} mass)\par
00126         \{\par
00127             {\cf19 if} (FIXED_MODIFICATIONS.ContainsKey(aminoAcid))\par
00128                 {\cf19 return} {\cf17 false};\par
00129 \par
00130             FIXED_MODIFICATIONS.Add(aminoAcid, mass);\par
00131             {\cf19 return} {\cf17 true};\par
00132         \}\par
00133 \par
00140         {\cf17 public} {\cf18 bool} addVariableModification({\cf18 string} aminoAcid, {\cf18 double} mass)\par
00141         \{\par
00142             {\cf19 if} (VARIABLE_MODIFICATIONS.ContainsKey(aminoAcid))\par
00143                 {\cf19 return} {\cf17 false};\par
00144 \par
00145             VARIABLE_MODIFICATIONS.Add(aminoAcid, mass);\par
00146             {\cf19 return} {\cf17 true};\par
00147         \}\par
00148 \par
00154         {\cf17 public} {\cf18 string} modificationsToString({\cf18 bool} variable = {\cf17 false})\par
00155         \{\par
00156             var sb = {\cf17 new} StringBuilder();\par
00157             {\cf19 if} (!variable)\par
00158             \{\par
00159                 {\cf19 foreach} (var mod {\cf19 in} FIXED_MODIFICATIONS)\par
00160                 \{\par
00161                     sb.Append(${\cf22 "\{mod.Key.ToString()\}:\{mod.Value.ToString()\};"});\par
00162                 \}\par
00163             \}\par
00164             {\cf19 else}\par
00165             \{\par
00166                 {\cf19 foreach} (var mod {\cf19 in} VARIABLE_MODIFICATIONS)\par
00167                 \{\par
00168                     sb.Append(${\cf22 "\{mod.Key.ToString()\}:\{mod.Value.ToString()\};"});\par
00169                 \}\par
00170             \}\par
00171             {\cf19 return} sb.ToString();\par
00172         \}\par
00173 \par
00178         {\cf17 public} {\cf17 override} {\cf18 string} ToString()\par
00179         \{\par
00180             var sb = {\cf17 new} StringBuilder();\par
00181             sb.Append({\cf22 "---- SETTINGS: ----\\n"});\par
00182             sb.Append(${\cf22 "MAX_CLEAVAGES: \{MAX_CLEAVAGES\}\\n"});\par
00183             sb.Append(${\cf22 "MIN_PEP_LENGTH: \{MIN_PEP_LENGTH\}\\n"});\par
00184             sb.Append(${\cf22 "MAX_PEP_LENGTH: \{MAX_PEP_LENGTH\}\\n"});\par
00185             sb.Append(${\cf22 "MAX_PRECURSOR_CHARGE: \{MAX_PRECURSOR_CHARGE\}\\n"});\par
00186             sb.Append(${\cf22 "MAX_FRAGMENT_CHARGE: \{MAX_FRAGMENT_CHARGE\}\\n"});\par
00187             sb.Append(${\cf22 "MAX_NEUTRAL_LOSSES: \{MAX_NEUTRAL_LOSSES\}\\n"});\par
00188             sb.Append(${\cf22 "MAX_NEUTRAL_LOSS_MODS: \{MAX_NEUTRAL_LOSS_MODS\}\\n"});\par
00189             sb.Append(${\cf22 "FIXED_MODIFICATIONS: \{modificationsToString(false)\}\\n"});\par
00190             sb.Append(${\cf22 "VARIABLE_MODIFICATIONS: \{modificationsToString(true)\}\\n"});\par
00191             sb.Append(${\cf22 "DECOY_SEARCH: \{DECOY_SEARCH\}\\n"});\par
00192             sb.Append(${\cf22 "TOP_N: \{TOP_N\}\\n"});\par
00193             sb.Append(${\cf22 "TOLERANCE: \{TOLERANCE\}\\n"});\par
00194             sb.Append(${\cf22 "NORMALIZE: \{NORMALIZE\}\\n"});\par
00195             sb.Append(${\cf22 "USE_GAUSSIAN: \{USE_GAUSSIAN\}\\n"});\par
00196             sb.Append(${\cf22 "MODE: \{MODE\}\\n"});\par
00197             sb.Append({\cf22 "---- SETTINGS END ----"});\par
00198 \par
00199             {\cf19 return} sb.ToString();\par
00200         \}\par
00201     \}\par
00202 \par
00206     {\cf17 public} {\cf17 static} {\cf17 class }SettingsReader\par
00207     \{\par
00213         {\cf17 public} {\cf17 static} Settings readSettings({\cf18 string} filename)\par
00214         \{\par
00215             var settings = {\cf17 new} Settings();\par
00216 \par
00217             {\cf17 using} (StreamReader sr = {\cf17 new} StreamReader(filename))\par
00218             \{\par
00219                 {\cf19 while} (!sr.EndOfStream)\par
00220                 \{\par
00221                     var line = sr.ReadLine();\par
00222 \par
00223                     {\cf19 if} (line != {\cf17 null} && line.StartsWith({\cf22 "MAX_CLEAVAGES"}))\par
00224                     \{\par
00225                         var values = line.Split({\cf22 "="});\par
00226                         {\cf19 if} (values.Length > 1)\par
00227                         \{\par
00228                             var ok = {\cf18 int}.TryParse(values[1], out var value);\par
00229                             {\cf19 if} (ok)\par
00230                             \{\par
00231                                 settings.MAX_CLEAVAGES = value;\par
00232                             \}\par
00233                         \}\par
00234                     \}\par
00235 \par
00236                     {\cf19 if} (line != {\cf17 null} && line.StartsWith({\cf22 "MIN_PEP_LENGTH"}))\par
00237                     \{\par
00238                         var values = line.Split({\cf22 "="});\par
00239                         {\cf19 if} (values.Length > 1)\par
00240                         \{\par
00241                             var ok = {\cf18 int}.TryParse(values[1], out var value);\par
00242                             {\cf19 if} (ok)\par
00243                             \{\par
00244                                 settings.MIN_PEP_LENGTH = value;\par
00245                             \}\par
00246                         \}\par
00247                     \}\par
00248 \par
00249                     {\cf19 if} (line != {\cf17 null} && line.StartsWith({\cf22 "MAX_PEP_LENGTH"}))\par
00250                     \{\par
00251                         var values = line.Split({\cf22 "="});\par
00252                         {\cf19 if} (values.Length > 1)\par
00253                         \{\par
00254                             var ok = {\cf18 int}.TryParse(values[1], out var value);\par
00255                             {\cf19 if} (ok)\par
00256                             \{\par
00257                                 settings.MAX_PEP_LENGTH = value;\par
00258                             \}\par
00259                         \}\par
00260                     \}\par
00261 \par
00262                     {\cf19 if} (line != {\cf17 null} && line.StartsWith({\cf22 "MAX_PRECURSOR_CHARGE"}))\par
00263                     \{\par
00264                         var values = line.Split({\cf22 "="});\par
00265                         {\cf19 if} (values.Length > 1)\par
00266                         \{\par
00267                             var ok = {\cf18 int}.TryParse(values[1], out var value);\par
00268                             {\cf19 if} (ok)\par
00269                             \{\par
00270                                 settings.MAX_PRECURSOR_CHARGE = value;\par
00271                             \}\par
00272                         \}\par
00273                     \}\par
00274 \par
00275                     {\cf19 if} (line != {\cf17 null} && line.StartsWith({\cf22 "MAX_FRAGMENT_CHARGE"}))\par
00276                     \{\par
00277                         var values = line.Split({\cf22 "="});\par
00278                         {\cf19 if} (values.Length > 1)\par
00279                         \{\par
00280                             var maxFragmentCharge = values[1].Trim();\par
00281                             {\cf19 if} (maxFragmentCharge == {\cf22 "+2"} ||\par
00282                                 maxFragmentCharge == {\cf22 "+3"} ||\par
00283                                 maxFragmentCharge == {\cf22 "+4"} ||\par
00284                                 maxFragmentCharge == {\cf22 "Precursor - 1"})\par
00285                             \{\par
00286                                 settings.MAX_FRAGMENT_CHARGE = maxFragmentCharge;\par
00287                             \}\par
00288                         \}\par
00289                     \}\par
00290 \par
00291                     {\cf19 if} (line != {\cf17 null} && line.StartsWith({\cf22 "MAX_NEUTRAL_LOSSES"}))\par
00292                     \{\par
00293                         var values = line.Split({\cf22 "="});\par
00294                         {\cf19 if} (values.Length > 1)\par
00295                         \{\par
00296                             var ok = {\cf18 int}.TryParse(values[1], out var value);\par
00297                             {\cf19 if} (ok)\par
00298                             \{\par
00299                                 settings.MAX_NEUTRAL_LOSSES = value;\par
00300                             \}\par
00301                         \}\par
00302                     \}\par
00303 \par
00304                     {\cf19 if} (line != {\cf17 null} && line.StartsWith({\cf22 "MAX_NEUTRAL_LOSS_MODS"}))\par
00305                     \{\par
00306                         var values = line.Split({\cf22 "="});\par
00307                         {\cf19 if} (values.Length > 1)\par
00308                         \{\par
00309                             var ok = {\cf18 int}.TryParse(values[1], out var value);\par
00310                             {\cf19 if} (ok)\par
00311                             \{\par
00312                                 settings.MAX_NEUTRAL_LOSS_MODS = value;\par
00313                             \}\par
00314                         \}\par
00315                     \}\par
00316 \par
00317                     {\cf19 if} (line != {\cf17 null} && line.StartsWith({\cf22 "FIXED_MODIFICATIONS"}))\par
00318                     \{\par
00319                         var values = line.Split({\cf22 "="});\par
00320                         {\cf19 if} (values.Length > 1)\par
00321                         \{\par
00322                             var mods = values[1].Split({\cf22 ";"});\par
00323                             {\cf19 foreach} (var mod {\cf19 in} mods)\par
00324                             \{\par
00325                                 var modProps = mod.Split({\cf22 ":"});\par
00326                                 {\cf19 if} (modProps.Length == 2)\par
00327                                 \{\par
00328                                     {\cf19 if} (modProps[0].Trim().Length == 1)\par
00329                                     \{\par
00330                                         var ok = {\cf18 double}.TryParse(modProps[1], out var value);\par
00331                                         {\cf19 if} (ok)\par
00332                                         \{\par
00333                                             {\cf19 if} (!settings.FIXED_MODIFICATIONS.ContainsKey(modProps[0]))\par
00334                                             \{\par
00335                                                 settings.addFixedModification(modProps[0].Trim(), value);\par
00336                                             \}\par
00337                                         \}\par
00338                                     \}\par
00339                                 \}\par
00340                             \}\par
00341                         \}\par
00342                     \}\par
00343 \par
00344                     {\cf19 if} (line != {\cf17 null} && line.StartsWith({\cf22 "VARIABLE_MODIFICATIONS"}))\par
00345                     \{\par
00346                         var values = line.Split({\cf22 "="});\par
00347                         {\cf19 if} (values.Length > 1)\par
00348                         \{\par
00349                             var mods = values[1].Split({\cf22 ";"});\par
00350                             {\cf19 foreach} (var mod {\cf19 in} mods)\par
00351                             \{\par
00352                                 var modProps = mod.Split({\cf22 ":"});\par
00353                                 {\cf19 if} (modProps.Length == 2)\par
00354                                 \{\par
00355                                     {\cf19 if} (modProps[0].Trim().Length == 1)\par
00356                                     \{\par
00357                                         var ok = {\cf18 double}.TryParse(modProps[1], out var value);\par
00358                                         {\cf19 if} (ok)\par
00359                                         \{\par
00360                                             {\cf19 if} (!settings.VARIABLE_MODIFICATIONS.ContainsKey(modProps[0]))\par
00361                                             \{\par
00362                                                 settings.addVariableModification(modProps[0].Trim(), value);\par
00363                                             \}\par
00364                                         \}\par
00365                                     \}\par
00366                                 \}\par
00367                             \}\par
00368                         \}\par
00369                     \}\par
00370 \par
00371                     {\cf19 if} (line != {\cf17 null} && line.StartsWith({\cf22 "DECOY_SEARCH"}))\par
00372                     \{\par
00373                         var values = line.Split({\cf22 "="});\par
00374                         {\cf19 if} (values.Length > 1)\par
00375                         \{\par
00376                             var ok = {\cf18 bool}.TryParse(values[1], out var value);\par
00377                             {\cf19 if} (ok)\par
00378                             \{\par
00379                                 settings.DECOY_SEARCH = value;\par
00380                             \}\par
00381                         \}\par
00382                     \}\par
00383 \par
00384                     {\cf19 if} (line != {\cf17 null} && line.StartsWith({\cf22 "TOP_N"}))\par
00385                     \{\par
00386                         var values = line.Split({\cf22 "="});\par
00387                         {\cf19 if} (values.Length > 1)\par
00388                         \{\par
00389                             var ok = {\cf18 int}.TryParse(values[1], out var value);\par
00390                             {\cf19 if} (ok)\par
00391                             \{\par
00392                                 settings.TOP_N = value;\par
00393                             \}\par
00394                         \}\par
00395                     \}\par
00396 \par
00397                     {\cf19 if} (line != {\cf17 null} && line.StartsWith({\cf22 "TOLERANCE"}))\par
00398                     \{\par
00399                         var values = line.Split({\cf22 "="});\par
00400                         {\cf19 if} (values.Length > 1)\par
00401                         \{\par
00402                             var ok = {\cf18 float}.TryParse(values[1], out var value);\par
00403                             {\cf19 if} (ok)\par
00404                             \{\par
00405                                 settings.TOLERANCE = value;\par
00406                             \}\par
00407                         \}\par
00408                     \}\par
00409 \par
00410                     {\cf19 if} (line != {\cf17 null} && line.StartsWith({\cf22 "NORMALIZE"}))\par
00411                     \{\par
00412                         var values = line.Split({\cf22 "="});\par
00413                         {\cf19 if} (values.Length > 1)\par
00414                         \{\par
00415                             var ok = {\cf18 bool}.TryParse(values[1], out var value);\par
00416                             {\cf19 if} (ok)\par
00417                             \{\par
00418                                 settings.NORMALIZE = value;\par
00419                             \}\par
00420                         \}\par
00421                     \}\par
00422 \par
00423                     {\cf19 if} (line != {\cf17 null} && line.StartsWith({\cf22 "USE_GAUSSIAN"}))\par
00424                     \{\par
00425                         var values = line.Split({\cf22 "="});\par
00426                         {\cf19 if} (values.Length > 1)\par
00427                         \{\par
00428                             var ok = {\cf18 bool}.TryParse(values[1], out var value);\par
00429                             {\cf19 if} (ok)\par
00430                             \{\par
00431                                 settings.USE_GAUSSIAN = value;\par
00432                             \}\par
00433                         \}\par
00434                     \}\par
00435 \par
00436                     {\cf19 if} (line != {\cf17 null} && line.StartsWith({\cf22 "MODE"}))\par
00437                     \{\par
00438                         var values = line.Split({\cf22 "="});\par
00439                         {\cf19 if} (values.Length > 1)\par
00440                         \{\par
00441                             var mode = values[1].Trim();\par
00442                             {\cf19 if} (mode == {\cf22 "CPU_SV"} ||\par
00443                                 mode == {\cf22 "CPU_DM"} ||\par
00444                                 mode == {\cf22 "CPU_SM"} ||\par
00445                                 mode == {\cf22 "GPU_DV"} ||\par
00446                                 mode == {\cf22 "GPU_DM"} ||\par
00447                                 mode == {\cf22 "GPU_SM"})\par
00448                             \{\par
00449                                 settings.MODE = mode;\par
00450                             \}\par
00451                         \}\par
00452                     \}\par
00453                 \}\par
00454             \}\par
00455 \par
00456             {\cf19 return} settings;\par
00457         \}\par
00458     \}\par
00459 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Spectra.cs\par \pard\plain 
{\tc\tcl2 \v util/Spectra.cs}
{\xe \v util/Spectra.cs}
{\bkmkstart AAAAAAAAAL}
{\bkmkend AAAAAAAAAL}
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf17 namespace }CandidateSearch.util\par
00002 \{\par
00006     {\cf17 public} {\cf17 class }Spectrum\par
00007     \{\par
00011         {\cf17 public} {\cf18 double}[] mz \{ {\cf17 get}; \}\par
00015         {\cf17 public} {\cf18 double}[] intensity \{ {\cf17 get}; \}\par
00019         {\cf17 public} {\cf18 int} scanNumber \{ {\cf17 get}; \}\par
00020 \par
00027         {\cf17 public} Spectrum({\cf18 double}[] Mz, {\cf18 double}[] Intensity, {\cf18 int} ScanNumber) \par
00028         \{\par
00029             mz = Mz;\par
00030             intensity = Intensity;\par
00031             scanNumber = ScanNumber;\par
00032             Array.Sort(mz, intensity);\par
00033         \}\par
00034 \par
00041         {\cf17 public} {\cf18 int}[] getEncoding({\cf18 int} massRange = 5000, {\cf18 int} massMultiplier = 100)\par
00042         \{\par
00043             var encoding = {\cf17 new} List<int>();\par
00044 \par
00045             {\cf19 for} ({\cf18 int} i = 0; i < mz.Length; i++)\par
00046             \{\par
00047                 {\cf19 if} (mz[i] < massRange)\par
00048                 \{\par
00049                     encoding.Add(({\cf18 int}) Math.Round(mz[i] * massMultiplier));\par
00050                 \}\par
00051             \}\par
00052 \par
00053             {\cf19 return} encoding.ToArray();\par
00054         \}\par
00055     \}\par
00056 \par
00060     {\cf17 public} {\cf17 static} {\cf17 class }MGFReader\par
00061     \{\par
00067         {\cf17 public} {\cf17 static} List<Spectrum> readMGF({\cf18 string} filename)\par
00068         \{ \par
00069             var MSAMANDA_spectra = MSAMANDA_MGFPARSER.MGFParser.ParseNextSpectra(filename);\par
00070 \par
00071             var spectra = {\cf17 new} List<Spectrum>();\par
00072 \par
00073             {\cf19 foreach}(var spectrum {\cf19 in} MSAMANDA_spectra)\par
00074             \{\par
00075                 var mz = {\cf17 new} List<double>();\par
00076                 var intensity = {\cf17 new} List<double>();\par
00077 \par
00078                 {\cf19 foreach} (var peak {\cf19 in} spectrum.FragmentsPeaks)\par
00079                 \{\par
00080                     mz.Add(peak.Position);\par
00081                     intensity.Add(peak.Intensity);\par
00082                 \}\par
00083 \par
00084                 spectra.Add({\cf17 new} Spectrum(mz.ToArray(), intensity.ToArray(), spectrum.ScanNumber));\par
00085             \}\par
00086 \par
00087             {\cf19 return} spectra;\par
00088         \}\par
00089     \}\par
00090 \}\par
00091 \par
}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Index\par 
\pard\plain 
{\tc \v Index}
{\field\fldedit {\*\fldinst INDEX \\c2 \\*MERGEFORMAT}{\fldrslt INDEX}}
}
